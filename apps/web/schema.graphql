schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
History of auditable actions on audited tables, from audit.if_modified_func()
"""
type audit_logged_actions {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String!

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz!

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz!

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz!

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields(
    """JSON select path"""
    path: String
  ): jsonb

  """IP address of client that issued query. Null for unix domain socket."""
  client_addr: inet

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint!
  hasura_org: String
  hasura_user: String

  """Table OID. Changes with drop/create. Get with 'tablename'::regclass"""
  relid: oid!

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data(
    """JSON select path"""
    path: String
  ): jsonb

  """Database schema audited table for this event is in"""
  schema_name: String!

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """
  't' if audit event is from an FOR EACH STATEMENT trigger, 'f' for FOR EACH ROW
  """
  statement_only: Boolean!

  """Non-schema-qualified table name of table event occured in"""
  table_name: String!

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""
aggregated selection of "audit.logged_actions"
"""
type audit_logged_actions_aggregate {
  aggregate: audit_logged_actions_aggregate_fields
  nodes: [audit_logged_actions!]!
}

"""
aggregate fields of "audit.logged_actions"
"""
type audit_logged_actions_aggregate_fields {
  avg: audit_logged_actions_avg_fields
  count(columns: [audit_logged_actions_select_column!], distinct: Boolean): Int!
  max: audit_logged_actions_max_fields
  min: audit_logged_actions_min_fields
  stddev: audit_logged_actions_stddev_fields
  stddev_pop: audit_logged_actions_stddev_pop_fields
  stddev_samp: audit_logged_actions_stddev_samp_fields
  sum: audit_logged_actions_sum_fields
  var_pop: audit_logged_actions_var_pop_fields
  var_samp: audit_logged_actions_var_samp_fields
  variance: audit_logged_actions_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input audit_logged_actions_append_input {
  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: jsonb

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: jsonb
}

"""aggregate avg on columns"""
type audit_logged_actions_avg_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""
Boolean expression to filter rows from the table "audit.logged_actions". All fields are combined with a logical 'AND'.
"""
input audit_logged_actions_bool_exp {
  _and: [audit_logged_actions_bool_exp!]
  _not: audit_logged_actions_bool_exp
  _or: [audit_logged_actions_bool_exp!]
  action: String_comparison_exp
  action_tstamp_clk: timestamptz_comparison_exp
  action_tstamp_stm: timestamptz_comparison_exp
  action_tstamp_tx: timestamptz_comparison_exp
  application_name: String_comparison_exp
  changed_fields: jsonb_comparison_exp
  client_addr: inet_comparison_exp
  client_port: Int_comparison_exp
  client_query: String_comparison_exp
  event_id: bigint_comparison_exp
  hasura_org: String_comparison_exp
  hasura_user: String_comparison_exp
  relid: oid_comparison_exp
  row_data: jsonb_comparison_exp
  schema_name: String_comparison_exp
  session_user_name: String_comparison_exp
  statement_only: Boolean_comparison_exp
  table_name: String_comparison_exp
  transaction_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "audit.logged_actions"
"""
enum audit_logged_actions_constraint {
  """
  unique or primary key constraint on columns "event_id"
  """
  logged_actions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_logged_actions_delete_at_path_input {
  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: [String!]

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_logged_actions_delete_elem_input {
  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: Int

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_logged_actions_delete_key_input {
  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: String

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: String
}

"""
input type for incrementing numeric columns in table "audit.logged_actions"
"""
input audit_logged_actions_inc_input {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """Unique identifier for each auditable event"""
  event_id: bigint

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""
input type for inserting data into table "audit.logged_actions"
"""
input audit_logged_actions_insert_input {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: jsonb

  """IP address of client that issued query. Null for unix domain socket."""
  client_addr: inet

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint
  hasura_org: String
  hasura_user: String

  """Table OID. Changes with drop/create. Get with 'tablename'::regclass"""
  relid: oid

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: jsonb

  """Database schema audited table for this event is in"""
  schema_name: String

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """
  't' if audit event is from an FOR EACH STATEMENT trigger, 'f' for FOR EACH ROW
  """
  statement_only: Boolean

  """Non-schema-qualified table name of table event occured in"""
  table_name: String

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""aggregate max on columns"""
type audit_logged_actions_max_fields {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint
  hasura_org: String
  hasura_user: String

  """Database schema audited table for this event is in"""
  schema_name: String

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """Non-schema-qualified table name of table event occured in"""
  table_name: String

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""aggregate min on columns"""
type audit_logged_actions_min_fields {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint
  hasura_org: String
  hasura_user: String

  """Database schema audited table for this event is in"""
  schema_name: String

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """Non-schema-qualified table name of table event occured in"""
  table_name: String

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""
response of any mutation on the table "audit.logged_actions"
"""
type audit_logged_actions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [audit_logged_actions!]!
}

"""
on_conflict condition type for table "audit.logged_actions"
"""
input audit_logged_actions_on_conflict {
  constraint: audit_logged_actions_constraint!
  update_columns: [audit_logged_actions_update_column!]! = []
  where: audit_logged_actions_bool_exp
}

"""Ordering options when selecting data from "audit.logged_actions"."""
input audit_logged_actions_order_by {
  action: order_by
  action_tstamp_clk: order_by
  action_tstamp_stm: order_by
  action_tstamp_tx: order_by
  application_name: order_by
  changed_fields: order_by
  client_addr: order_by
  client_port: order_by
  client_query: order_by
  event_id: order_by
  hasura_org: order_by
  hasura_user: order_by
  relid: order_by
  row_data: order_by
  schema_name: order_by
  session_user_name: order_by
  statement_only: order_by
  table_name: order_by
  transaction_id: order_by
}

"""primary key columns input for table: audit.logged_actions"""
input audit_logged_actions_pk_columns_input {
  """Unique identifier for each auditable event"""
  event_id: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input audit_logged_actions_prepend_input {
  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: jsonb

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: jsonb
}

"""
select columns of table "audit.logged_actions"
"""
enum audit_logged_actions_select_column {
  """column name"""
  action

  """column name"""
  action_tstamp_clk

  """column name"""
  action_tstamp_stm

  """column name"""
  action_tstamp_tx

  """column name"""
  application_name

  """column name"""
  changed_fields

  """column name"""
  client_addr

  """column name"""
  client_port

  """column name"""
  client_query

  """column name"""
  event_id

  """column name"""
  hasura_org

  """column name"""
  hasura_user

  """column name"""
  relid

  """column name"""
  row_data

  """column name"""
  schema_name

  """column name"""
  session_user_name

  """column name"""
  statement_only

  """column name"""
  table_name

  """column name"""
  transaction_id
}

"""
input type for updating data in table "audit.logged_actions"
"""
input audit_logged_actions_set_input {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: jsonb

  """IP address of client that issued query. Null for unix domain socket."""
  client_addr: inet

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint
  hasura_org: String
  hasura_user: String

  """Table OID. Changes with drop/create. Get with 'tablename'::regclass"""
  relid: oid

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: jsonb

  """Database schema audited table for this event is in"""
  schema_name: String

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """
  't' if audit event is from an FOR EACH STATEMENT trigger, 'f' for FOR EACH ROW
  """
  statement_only: Boolean

  """Non-schema-qualified table name of table event occured in"""
  table_name: String

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""aggregate stddev on columns"""
type audit_logged_actions_stddev_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""aggregate stddev_pop on columns"""
type audit_logged_actions_stddev_pop_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""aggregate stddev_samp on columns"""
type audit_logged_actions_stddev_samp_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""
Streaming cursor of the table "audit_logged_actions"
"""
input audit_logged_actions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: audit_logged_actions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input audit_logged_actions_stream_cursor_value_input {
  """Action type; I = insert, D = delete, U = update, T = truncate"""
  action: String

  """Wall clock time at which audited event's trigger call occurred"""
  action_tstamp_clk: timestamptz

  """Statement start timestamp for tx in which audited event occurred"""
  action_tstamp_stm: timestamptz

  """Transaction start timestamp for tx in which audited event occurred"""
  action_tstamp_tx: timestamptz

  """
  Application name set when this audit event occurred. Can be changed in-session by client.
  """
  application_name: String

  """
  New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  """
  changed_fields: jsonb

  """IP address of client that issued query. Null for unix domain socket."""
  client_addr: inet

  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """
  Top-level query that caused this auditable event. May be more than one statement.
  """
  client_query: String

  """Unique identifier for each auditable event"""
  event_id: bigint
  hasura_org: String
  hasura_user: String

  """Table OID. Changes with drop/create. Get with 'tablename'::regclass"""
  relid: oid

  """
  Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.
  """
  row_data: jsonb

  """Database schema audited table for this event is in"""
  schema_name: String

  """Login / session user whose statement caused the audited event"""
  session_user_name: String

  """
  't' if audit event is from an FOR EACH STATEMENT trigger, 'f' for FOR EACH ROW
  """
  statement_only: Boolean

  """Non-schema-qualified table name of table event occured in"""
  table_name: String

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""aggregate sum on columns"""
type audit_logged_actions_sum_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Int

  """Unique identifier for each auditable event"""
  event_id: bigint

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: bigint
}

"""
update columns of table "audit.logged_actions"
"""
enum audit_logged_actions_update_column {
  """column name"""
  action

  """column name"""
  action_tstamp_clk

  """column name"""
  action_tstamp_stm

  """column name"""
  action_tstamp_tx

  """column name"""
  application_name

  """column name"""
  changed_fields

  """column name"""
  client_addr

  """column name"""
  client_port

  """column name"""
  client_query

  """column name"""
  event_id

  """column name"""
  hasura_org

  """column name"""
  hasura_user

  """column name"""
  relid

  """column name"""
  row_data

  """column name"""
  schema_name

  """column name"""
  session_user_name

  """column name"""
  statement_only

  """column name"""
  table_name

  """column name"""
  transaction_id
}

input audit_logged_actions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: audit_logged_actions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_logged_actions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_logged_actions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_logged_actions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: audit_logged_actions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: audit_logged_actions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: audit_logged_actions_set_input

  """filter the rows which have to be updated"""
  where: audit_logged_actions_bool_exp!
}

"""aggregate var_pop on columns"""
type audit_logged_actions_var_pop_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""aggregate var_samp on columns"""
type audit_logged_actions_var_samp_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""aggregate variance on columns"""
type audit_logged_actions_variance_fields {
  """
  Remote peer IP port address of client that issued query. Undefined for unix socket.
  """
  client_port: Float

  """Unique identifier for each auditable event"""
  event_id: Float

  """
  Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  """
  transaction_id: Float
}

"""
https://app.shortcut.com/artis-works/story/3391/ability-to-see-an-audit-history-in-umi-and-rollback-changes
"""
type audit_umi_actions {
  action_name: String!
  created_at: timestamptz!
  event_data(
    """JSON select path"""
    path: String
  ): jsonb!
  id: Int!
  umi_user_id: String!
}

"""
aggregated selection of "audit.umi_actions"
"""
type audit_umi_actions_aggregate {
  aggregate: audit_umi_actions_aggregate_fields
  nodes: [audit_umi_actions!]!
}

"""
aggregate fields of "audit.umi_actions"
"""
type audit_umi_actions_aggregate_fields {
  avg: audit_umi_actions_avg_fields
  count(columns: [audit_umi_actions_select_column!], distinct: Boolean): Int!
  max: audit_umi_actions_max_fields
  min: audit_umi_actions_min_fields
  stddev: audit_umi_actions_stddev_fields
  stddev_pop: audit_umi_actions_stddev_pop_fields
  stddev_samp: audit_umi_actions_stddev_samp_fields
  sum: audit_umi_actions_sum_fields
  var_pop: audit_umi_actions_var_pop_fields
  var_samp: audit_umi_actions_var_samp_fields
  variance: audit_umi_actions_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input audit_umi_actions_append_input {
  event_data: jsonb
}

"""aggregate avg on columns"""
type audit_umi_actions_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "audit.umi_actions". All fields are combined with a logical 'AND'.
"""
input audit_umi_actions_bool_exp {
  _and: [audit_umi_actions_bool_exp!]
  _not: audit_umi_actions_bool_exp
  _or: [audit_umi_actions_bool_exp!]
  action_name: String_comparison_exp
  created_at: timestamptz_comparison_exp
  event_data: jsonb_comparison_exp
  id: Int_comparison_exp
  umi_user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "audit.umi_actions"
"""
enum audit_umi_actions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  umi_actions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_umi_actions_delete_at_path_input {
  event_data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_umi_actions_delete_elem_input {
  event_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_umi_actions_delete_key_input {
  event_data: String
}

"""
input type for incrementing numeric columns in table "audit.umi_actions"
"""
input audit_umi_actions_inc_input {
  id: Int
}

"""
input type for inserting data into table "audit.umi_actions"
"""
input audit_umi_actions_insert_input {
  action_name: String
  created_at: timestamptz
  event_data: jsonb
  id: Int
  umi_user_id: String
}

"""aggregate max on columns"""
type audit_umi_actions_max_fields {
  action_name: String
  created_at: timestamptz
  id: Int
  umi_user_id: String
}

"""aggregate min on columns"""
type audit_umi_actions_min_fields {
  action_name: String
  created_at: timestamptz
  id: Int
  umi_user_id: String
}

"""
response of any mutation on the table "audit.umi_actions"
"""
type audit_umi_actions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [audit_umi_actions!]!
}

"""
on_conflict condition type for table "audit.umi_actions"
"""
input audit_umi_actions_on_conflict {
  constraint: audit_umi_actions_constraint!
  update_columns: [audit_umi_actions_update_column!]! = []
  where: audit_umi_actions_bool_exp
}

"""Ordering options when selecting data from "audit.umi_actions"."""
input audit_umi_actions_order_by {
  action_name: order_by
  created_at: order_by
  event_data: order_by
  id: order_by
  umi_user_id: order_by
}

"""primary key columns input for table: audit.umi_actions"""
input audit_umi_actions_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input audit_umi_actions_prepend_input {
  event_data: jsonb
}

"""
select columns of table "audit.umi_actions"
"""
enum audit_umi_actions_select_column {
  """column name"""
  action_name

  """column name"""
  created_at

  """column name"""
  event_data

  """column name"""
  id

  """column name"""
  umi_user_id
}

"""
input type for updating data in table "audit.umi_actions"
"""
input audit_umi_actions_set_input {
  action_name: String
  created_at: timestamptz
  event_data: jsonb
  id: Int
  umi_user_id: String
}

"""aggregate stddev on columns"""
type audit_umi_actions_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type audit_umi_actions_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type audit_umi_actions_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "audit_umi_actions"
"""
input audit_umi_actions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: audit_umi_actions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input audit_umi_actions_stream_cursor_value_input {
  action_name: String
  created_at: timestamptz
  event_data: jsonb
  id: Int
  umi_user_id: String
}

"""aggregate sum on columns"""
type audit_umi_actions_sum_fields {
  id: Int
}

"""
update columns of table "audit.umi_actions"
"""
enum audit_umi_actions_update_column {
  """column name"""
  action_name

  """column name"""
  created_at

  """column name"""
  event_data

  """column name"""
  id

  """column name"""
  umi_user_id
}

input audit_umi_actions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: audit_umi_actions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_umi_actions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_umi_actions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_umi_actions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: audit_umi_actions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: audit_umi_actions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: audit_umi_actions_set_input

  """filter the rows which have to be updated"""
  where: audit_umi_actions_bool_exp!
}

"""aggregate var_pop on columns"""
type audit_umi_actions_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type audit_umi_actions_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type audit_umi_actions_variance_fields {
  id: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "commodity_group"
"""
type commodity_group {
  """An object relationship"""
  commodity_parent_group: commodity_parent_group!
  id: Int!
  parent: Int!

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String
}

"""
aggregated selection of "commodity_group"
"""
type commodity_group_aggregate {
  aggregate: commodity_group_aggregate_fields
  nodes: [commodity_group!]!
}

input commodity_group_aggregate_bool_exp {
  count: commodity_group_aggregate_bool_exp_count
}

input commodity_group_aggregate_bool_exp_count {
  arguments: [commodity_group_select_column!]
  distinct: Boolean
  filter: commodity_group_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "commodity_group"
"""
type commodity_group_aggregate_fields {
  avg: commodity_group_avg_fields
  count(columns: [commodity_group_select_column!], distinct: Boolean): Int!
  max: commodity_group_max_fields
  min: commodity_group_min_fields
  stddev: commodity_group_stddev_fields
  stddev_pop: commodity_group_stddev_pop_fields
  stddev_samp: commodity_group_stddev_samp_fields
  sum: commodity_group_sum_fields
  var_pop: commodity_group_var_pop_fields
  var_samp: commodity_group_var_samp_fields
  variance: commodity_group_variance_fields
}

"""
order by aggregate values of table "commodity_group"
"""
input commodity_group_aggregate_order_by {
  avg: commodity_group_avg_order_by
  count: order_by
  max: commodity_group_max_order_by
  min: commodity_group_min_order_by
  stddev: commodity_group_stddev_order_by
  stddev_pop: commodity_group_stddev_pop_order_by
  stddev_samp: commodity_group_stddev_samp_order_by
  sum: commodity_group_sum_order_by
  var_pop: commodity_group_var_pop_order_by
  var_samp: commodity_group_var_samp_order_by
  variance: commodity_group_variance_order_by
}

"""
input type for inserting array relation for remote table "commodity_group"
"""
input commodity_group_arr_rel_insert_input {
  data: [commodity_group_insert_input!]!

  """upsert condition"""
  on_conflict: commodity_group_on_conflict
}

"""aggregate avg on columns"""
type commodity_group_avg_fields {
  id: Float
  parent: Float
}

"""
order by avg() on columns of table "commodity_group"
"""
input commodity_group_avg_order_by {
  id: order_by
  parent: order_by
}

"""
Boolean expression to filter rows from the table "commodity_group". All fields are combined with a logical 'AND'.
"""
input commodity_group_bool_exp {
  _and: [commodity_group_bool_exp!]
  _not: commodity_group_bool_exp
  _or: [commodity_group_bool_exp!]
  commodity_parent_group: commodity_parent_group_bool_exp
  id: Int_comparison_exp
  parent: Int_comparison_exp
  product_overrides: product_overrides_bool_exp
  product_overrides_aggregate: product_overrides_aggregate_bool_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "commodity_group"
"""
enum commodity_group_constraint {
  """
  unique or primary key constraint on columns "parent", "value"
  """
  commodity_group_parent_value_key

  """
  unique or primary key constraint on columns "id"
  """
  commodity_group_pkey
}

"""
input type for incrementing numeric columns in table "commodity_group"
"""
input commodity_group_inc_input {
  id: Int
  parent: Int
}

"""
input type for inserting data into table "commodity_group"
"""
input commodity_group_insert_input {
  commodity_parent_group: commodity_parent_group_obj_rel_insert_input
  id: Int
  parent: Int
  product_overrides: product_overrides_arr_rel_insert_input
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type commodity_group_max_fields {
  id: Int
  parent: Int
  value: String
}

"""
order by max() on columns of table "commodity_group"
"""
input commodity_group_max_order_by {
  id: order_by
  parent: order_by
  value: order_by
}

"""aggregate min on columns"""
type commodity_group_min_fields {
  id: Int
  parent: Int
  value: String
}

"""
order by min() on columns of table "commodity_group"
"""
input commodity_group_min_order_by {
  id: order_by
  parent: order_by
  value: order_by
}

"""
response of any mutation on the table "commodity_group"
"""
type commodity_group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [commodity_group!]!
}

"""
input type for inserting object relation for remote table "commodity_group"
"""
input commodity_group_obj_rel_insert_input {
  data: commodity_group_insert_input!

  """upsert condition"""
  on_conflict: commodity_group_on_conflict
}

"""
on_conflict condition type for table "commodity_group"
"""
input commodity_group_on_conflict {
  constraint: commodity_group_constraint!
  update_columns: [commodity_group_update_column!]! = []
  where: commodity_group_bool_exp
}

"""Ordering options when selecting data from "commodity_group"."""
input commodity_group_order_by {
  commodity_parent_group: commodity_parent_group_order_by
  id: order_by
  parent: order_by
  product_overrides_aggregate: product_overrides_aggregate_order_by
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: commodity_group"""
input commodity_group_pk_columns_input {
  id: Int!
}

"""
select columns of table "commodity_group"
"""
enum commodity_group_select_column {
  """column name"""
  id

  """column name"""
  parent

  """column name"""
  value
}

"""
input type for updating data in table "commodity_group"
"""
input commodity_group_set_input {
  id: Int
  parent: Int
  value: String
}

"""aggregate stddev on columns"""
type commodity_group_stddev_fields {
  id: Float
  parent: Float
}

"""
order by stddev() on columns of table "commodity_group"
"""
input commodity_group_stddev_order_by {
  id: order_by
  parent: order_by
}

"""aggregate stddev_pop on columns"""
type commodity_group_stddev_pop_fields {
  id: Float
  parent: Float
}

"""
order by stddev_pop() on columns of table "commodity_group"
"""
input commodity_group_stddev_pop_order_by {
  id: order_by
  parent: order_by
}

"""aggregate stddev_samp on columns"""
type commodity_group_stddev_samp_fields {
  id: Float
  parent: Float
}

"""
order by stddev_samp() on columns of table "commodity_group"
"""
input commodity_group_stddev_samp_order_by {
  id: order_by
  parent: order_by
}

"""
Streaming cursor of the table "commodity_group"
"""
input commodity_group_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: commodity_group_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input commodity_group_stream_cursor_value_input {
  id: Int
  parent: Int
  value: String
}

"""aggregate sum on columns"""
type commodity_group_sum_fields {
  id: Int
  parent: Int
}

"""
order by sum() on columns of table "commodity_group"
"""
input commodity_group_sum_order_by {
  id: order_by
  parent: order_by
}

"""
update columns of table "commodity_group"
"""
enum commodity_group_update_column {
  """column name"""
  id

  """column name"""
  parent

  """column name"""
  value
}

input commodity_group_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: commodity_group_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: commodity_group_set_input

  """filter the rows which have to be updated"""
  where: commodity_group_bool_exp!
}

"""aggregate var_pop on columns"""
type commodity_group_var_pop_fields {
  id: Float
  parent: Float
}

"""
order by var_pop() on columns of table "commodity_group"
"""
input commodity_group_var_pop_order_by {
  id: order_by
  parent: order_by
}

"""aggregate var_samp on columns"""
type commodity_group_var_samp_fields {
  id: Float
  parent: Float
}

"""
order by var_samp() on columns of table "commodity_group"
"""
input commodity_group_var_samp_order_by {
  id: order_by
  parent: order_by
}

"""aggregate variance on columns"""
type commodity_group_variance_fields {
  id: Float
  parent: Float
}

"""
order by variance() on columns of table "commodity_group"
"""
input commodity_group_variance_order_by {
  id: order_by
  parent: order_by
}

"""
columns and relationships of "commodity_parent_group"
"""
type commodity_parent_group {
  """An array relationship"""
  commodity_groups(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): [commodity_group!]!

  """An aggregate relationship"""
  commodity_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): commodity_group_aggregate!
  id: Int!
  organisation: Int

  """An object relationship"""
  organisationByOrganisation: organisation
  value: String
}

"""
aggregated selection of "commodity_parent_group"
"""
type commodity_parent_group_aggregate {
  aggregate: commodity_parent_group_aggregate_fields
  nodes: [commodity_parent_group!]!
}

input commodity_parent_group_aggregate_bool_exp {
  count: commodity_parent_group_aggregate_bool_exp_count
}

input commodity_parent_group_aggregate_bool_exp_count {
  arguments: [commodity_parent_group_select_column!]
  distinct: Boolean
  filter: commodity_parent_group_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "commodity_parent_group"
"""
type commodity_parent_group_aggregate_fields {
  avg: commodity_parent_group_avg_fields
  count(columns: [commodity_parent_group_select_column!], distinct: Boolean): Int!
  max: commodity_parent_group_max_fields
  min: commodity_parent_group_min_fields
  stddev: commodity_parent_group_stddev_fields
  stddev_pop: commodity_parent_group_stddev_pop_fields
  stddev_samp: commodity_parent_group_stddev_samp_fields
  sum: commodity_parent_group_sum_fields
  var_pop: commodity_parent_group_var_pop_fields
  var_samp: commodity_parent_group_var_samp_fields
  variance: commodity_parent_group_variance_fields
}

"""
order by aggregate values of table "commodity_parent_group"
"""
input commodity_parent_group_aggregate_order_by {
  avg: commodity_parent_group_avg_order_by
  count: order_by
  max: commodity_parent_group_max_order_by
  min: commodity_parent_group_min_order_by
  stddev: commodity_parent_group_stddev_order_by
  stddev_pop: commodity_parent_group_stddev_pop_order_by
  stddev_samp: commodity_parent_group_stddev_samp_order_by
  sum: commodity_parent_group_sum_order_by
  var_pop: commodity_parent_group_var_pop_order_by
  var_samp: commodity_parent_group_var_samp_order_by
  variance: commodity_parent_group_variance_order_by
}

"""
input type for inserting array relation for remote table "commodity_parent_group"
"""
input commodity_parent_group_arr_rel_insert_input {
  data: [commodity_parent_group_insert_input!]!

  """upsert condition"""
  on_conflict: commodity_parent_group_on_conflict
}

"""aggregate avg on columns"""
type commodity_parent_group_avg_fields {
  id: Float
  organisation: Float
}

"""
order by avg() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_avg_order_by {
  id: order_by
  organisation: order_by
}

"""
Boolean expression to filter rows from the table "commodity_parent_group". All fields are combined with a logical 'AND'.
"""
input commodity_parent_group_bool_exp {
  _and: [commodity_parent_group_bool_exp!]
  _not: commodity_parent_group_bool_exp
  _or: [commodity_parent_group_bool_exp!]
  commodity_groups: commodity_group_bool_exp
  commodity_groups_aggregate: commodity_group_aggregate_bool_exp
  id: Int_comparison_exp
  organisation: Int_comparison_exp
  organisationByOrganisation: organisation_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "commodity_parent_group"
"""
enum commodity_parent_group_constraint {
  """
  unique or primary key constraint on columns "value", "organisation"
  """
  commodity_parent_group_organisation_value_key

  """
  unique or primary key constraint on columns "id"
  """
  commodity_parent_group_pkey
}

"""
input type for incrementing numeric columns in table "commodity_parent_group"
"""
input commodity_parent_group_inc_input {
  id: Int
  organisation: Int
}

"""
input type for inserting data into table "commodity_parent_group"
"""
input commodity_parent_group_insert_input {
  commodity_groups: commodity_group_arr_rel_insert_input
  id: Int
  organisation: Int
  organisationByOrganisation: organisation_obj_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type commodity_parent_group_max_fields {
  id: Int
  organisation: Int
  value: String
}

"""
order by max() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_max_order_by {
  id: order_by
  organisation: order_by
  value: order_by
}

"""aggregate min on columns"""
type commodity_parent_group_min_fields {
  id: Int
  organisation: Int
  value: String
}

"""
order by min() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_min_order_by {
  id: order_by
  organisation: order_by
  value: order_by
}

"""
response of any mutation on the table "commodity_parent_group"
"""
type commodity_parent_group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [commodity_parent_group!]!
}

"""
input type for inserting object relation for remote table "commodity_parent_group"
"""
input commodity_parent_group_obj_rel_insert_input {
  data: commodity_parent_group_insert_input!

  """upsert condition"""
  on_conflict: commodity_parent_group_on_conflict
}

"""
on_conflict condition type for table "commodity_parent_group"
"""
input commodity_parent_group_on_conflict {
  constraint: commodity_parent_group_constraint!
  update_columns: [commodity_parent_group_update_column!]! = []
  where: commodity_parent_group_bool_exp
}

"""Ordering options when selecting data from "commodity_parent_group"."""
input commodity_parent_group_order_by {
  commodity_groups_aggregate: commodity_group_aggregate_order_by
  id: order_by
  organisation: order_by
  organisationByOrganisation: organisation_order_by
  value: order_by
}

"""primary key columns input for table: commodity_parent_group"""
input commodity_parent_group_pk_columns_input {
  id: Int!
}

"""
select columns of table "commodity_parent_group"
"""
enum commodity_parent_group_select_column {
  """column name"""
  id

  """column name"""
  organisation

  """column name"""
  value
}

"""
input type for updating data in table "commodity_parent_group"
"""
input commodity_parent_group_set_input {
  id: Int
  organisation: Int
  value: String
}

"""aggregate stddev on columns"""
type commodity_parent_group_stddev_fields {
  id: Float
  organisation: Float
}

"""
order by stddev() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_stddev_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate stddev_pop on columns"""
type commodity_parent_group_stddev_pop_fields {
  id: Float
  organisation: Float
}

"""
order by stddev_pop() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_stddev_pop_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate stddev_samp on columns"""
type commodity_parent_group_stddev_samp_fields {
  id: Float
  organisation: Float
}

"""
order by stddev_samp() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_stddev_samp_order_by {
  id: order_by
  organisation: order_by
}

"""
Streaming cursor of the table "commodity_parent_group"
"""
input commodity_parent_group_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: commodity_parent_group_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input commodity_parent_group_stream_cursor_value_input {
  id: Int
  organisation: Int
  value: String
}

"""aggregate sum on columns"""
type commodity_parent_group_sum_fields {
  id: Int
  organisation: Int
}

"""
order by sum() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_sum_order_by {
  id: order_by
  organisation: order_by
}

"""
update columns of table "commodity_parent_group"
"""
enum commodity_parent_group_update_column {
  """column name"""
  id

  """column name"""
  organisation

  """column name"""
  value
}

input commodity_parent_group_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: commodity_parent_group_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: commodity_parent_group_set_input

  """filter the rows which have to be updated"""
  where: commodity_parent_group_bool_exp!
}

"""aggregate var_pop on columns"""
type commodity_parent_group_var_pop_fields {
  id: Float
  organisation: Float
}

"""
order by var_pop() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_var_pop_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate var_samp on columns"""
type commodity_parent_group_var_samp_fields {
  id: Float
  organisation: Float
}

"""
order by var_samp() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_var_samp_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate variance on columns"""
type commodity_parent_group_variance_fields {
  id: Float
  organisation: Float
}

"""
order by variance() on columns of table "commodity_parent_group"
"""
input commodity_parent_group_variance_order_by {
  id: order_by
  organisation: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "eod"
"""
type eod {
  id: Int!
  source: Int!

  """An object relationship"""
  sourceBySource: source!
}

"""
aggregated selection of "eod"
"""
type eod_aggregate {
  aggregate: eod_aggregate_fields
  nodes: [eod!]!
}

input eod_aggregate_bool_exp {
  count: eod_aggregate_bool_exp_count
}

input eod_aggregate_bool_exp_count {
  arguments: [eod_select_column!]
  distinct: Boolean
  filter: eod_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "eod"
"""
type eod_aggregate_fields {
  avg: eod_avg_fields
  count(columns: [eod_select_column!], distinct: Boolean): Int!
  max: eod_max_fields
  min: eod_min_fields
  stddev: eod_stddev_fields
  stddev_pop: eod_stddev_pop_fields
  stddev_samp: eod_stddev_samp_fields
  sum: eod_sum_fields
  var_pop: eod_var_pop_fields
  var_samp: eod_var_samp_fields
  variance: eod_variance_fields
}

"""
order by aggregate values of table "eod"
"""
input eod_aggregate_order_by {
  avg: eod_avg_order_by
  count: order_by
  max: eod_max_order_by
  min: eod_min_order_by
  stddev: eod_stddev_order_by
  stddev_pop: eod_stddev_pop_order_by
  stddev_samp: eod_stddev_samp_order_by
  sum: eod_sum_order_by
  var_pop: eod_var_pop_order_by
  var_samp: eod_var_samp_order_by
  variance: eod_variance_order_by
}

"""
input type for inserting array relation for remote table "eod"
"""
input eod_arr_rel_insert_input {
  data: [eod_insert_input!]!

  """upsert condition"""
  on_conflict: eod_on_conflict
}

"""aggregate avg on columns"""
type eod_avg_fields {
  id: Float
  source: Float
}

"""
order by avg() on columns of table "eod"
"""
input eod_avg_order_by {
  id: order_by
  source: order_by
}

"""
Boolean expression to filter rows from the table "eod". All fields are combined with a logical 'AND'.
"""
input eod_bool_exp {
  _and: [eod_bool_exp!]
  _not: eod_bool_exp
  _or: [eod_bool_exp!]
  id: Int_comparison_exp
  source: Int_comparison_exp
  sourceBySource: source_bool_exp
}

"""
unique or primary key constraints on table "eod"
"""
enum eod_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  eod_pkey

  """
  unique or primary key constraint on columns "source"
  """
  eod_source_key
}

"""
columns and relationships of "eod_entry"
"""
type eod_entry {
  evaluation_date: date!
  id: bigint!
  month: date!
  ppend: date
  ppstart: date
  product: uuid!

  """An object relationship"""
  productByProduct: product!
  relative_period: Int
  value: numeric!
}

"""
aggregated selection of "eod_entry"
"""
type eod_entry_aggregate {
  aggregate: eod_entry_aggregate_fields
  nodes: [eod_entry!]!
}

input eod_entry_aggregate_bool_exp {
  count: eod_entry_aggregate_bool_exp_count
}

input eod_entry_aggregate_bool_exp_count {
  arguments: [eod_entry_select_column!]
  distinct: Boolean
  filter: eod_entry_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "eod_entry"
"""
type eod_entry_aggregate_fields {
  avg: eod_entry_avg_fields
  count(columns: [eod_entry_select_column!], distinct: Boolean): Int!
  max: eod_entry_max_fields
  min: eod_entry_min_fields
  stddev: eod_entry_stddev_fields
  stddev_pop: eod_entry_stddev_pop_fields
  stddev_samp: eod_entry_stddev_samp_fields
  sum: eod_entry_sum_fields
  var_pop: eod_entry_var_pop_fields
  var_samp: eod_entry_var_samp_fields
  variance: eod_entry_variance_fields
}

"""
order by aggregate values of table "eod_entry"
"""
input eod_entry_aggregate_order_by {
  avg: eod_entry_avg_order_by
  count: order_by
  max: eod_entry_max_order_by
  min: eod_entry_min_order_by
  stddev: eod_entry_stddev_order_by
  stddev_pop: eod_entry_stddev_pop_order_by
  stddev_samp: eod_entry_stddev_samp_order_by
  sum: eod_entry_sum_order_by
  var_pop: eod_entry_var_pop_order_by
  var_samp: eod_entry_var_samp_order_by
  variance: eod_entry_variance_order_by
}

"""
input type for inserting array relation for remote table "eod_entry"
"""
input eod_entry_arr_rel_insert_input {
  data: [eod_entry_insert_input!]!

  """upsert condition"""
  on_conflict: eod_entry_on_conflict
}

"""aggregate avg on columns"""
type eod_entry_avg_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by avg() on columns of table "eod_entry"
"""
input eod_entry_avg_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "eod_entry". All fields are combined with a logical 'AND'.
"""
input eod_entry_bool_exp {
  _and: [eod_entry_bool_exp!]
  _not: eod_entry_bool_exp
  _or: [eod_entry_bool_exp!]
  evaluation_date: date_comparison_exp
  id: bigint_comparison_exp
  month: date_comparison_exp
  ppend: date_comparison_exp
  ppstart: date_comparison_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
  relative_period: Int_comparison_exp
  value: numeric_comparison_exp
}

"""
unique or primary key constraints on table "eod_entry"
"""
enum eod_entry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  eod_entry_id_key

  """
  unique or primary key constraint on columns "evaluation_date", "product", "month"
  """
  eod_entry_pkey
}

"""
input type for incrementing numeric columns in table "eod_entry"
"""
input eod_entry_inc_input {
  id: bigint
  relative_period: Int
  value: numeric
}

"""
input type for inserting data into table "eod_entry"
"""
input eod_entry_insert_input {
  evaluation_date: date
  id: bigint
  month: date
  ppend: date
  ppstart: date
  product: uuid
  productByProduct: product_obj_rel_insert_input
  relative_period: Int
  value: numeric
}

"""aggregate max on columns"""
type eod_entry_max_fields {
  evaluation_date: date
  id: bigint
  month: date
  ppend: date
  ppstart: date
  product: uuid
  relative_period: Int
  value: numeric
}

"""
order by max() on columns of table "eod_entry"
"""
input eod_entry_max_order_by {
  evaluation_date: order_by
  id: order_by
  month: order_by
  ppend: order_by
  ppstart: order_by
  product: order_by
  relative_period: order_by
  value: order_by
}

"""aggregate min on columns"""
type eod_entry_min_fields {
  evaluation_date: date
  id: bigint
  month: date
  ppend: date
  ppstart: date
  product: uuid
  relative_period: Int
  value: numeric
}

"""
order by min() on columns of table "eod_entry"
"""
input eod_entry_min_order_by {
  evaluation_date: order_by
  id: order_by
  month: order_by
  ppend: order_by
  ppstart: order_by
  product: order_by
  relative_period: order_by
  value: order_by
}

"""
response of any mutation on the table "eod_entry"
"""
type eod_entry_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [eod_entry!]!
}

"""
on_conflict condition type for table "eod_entry"
"""
input eod_entry_on_conflict {
  constraint: eod_entry_constraint!
  update_columns: [eod_entry_update_column!]! = []
  where: eod_entry_bool_exp
}

"""Ordering options when selecting data from "eod_entry"."""
input eod_entry_order_by {
  evaluation_date: order_by
  id: order_by
  month: order_by
  ppend: order_by
  ppstart: order_by
  product: order_by
  productByProduct: product_order_by
  relative_period: order_by
  value: order_by
}

"""
columns and relationships of "eod_entry_per_eval_date_mview"
"""
type eod_entry_per_eval_date_mview {
  evaluation_date: date
}

"""
aggregated selection of "eod_entry_per_eval_date_mview"
"""
type eod_entry_per_eval_date_mview_aggregate {
  aggregate: eod_entry_per_eval_date_mview_aggregate_fields
  nodes: [eod_entry_per_eval_date_mview!]!
}

"""
aggregate fields of "eod_entry_per_eval_date_mview"
"""
type eod_entry_per_eval_date_mview_aggregate_fields {
  count(columns: [eod_entry_per_eval_date_mview_select_column!], distinct: Boolean): Int!
  max: eod_entry_per_eval_date_mview_max_fields
  min: eod_entry_per_eval_date_mview_min_fields
}

"""
Boolean expression to filter rows from the table "eod_entry_per_eval_date_mview". All fields are combined with a logical 'AND'.
"""
input eod_entry_per_eval_date_mview_bool_exp {
  _and: [eod_entry_per_eval_date_mview_bool_exp!]
  _not: eod_entry_per_eval_date_mview_bool_exp
  _or: [eod_entry_per_eval_date_mview_bool_exp!]
  evaluation_date: date_comparison_exp
}

"""aggregate max on columns"""
type eod_entry_per_eval_date_mview_max_fields {
  evaluation_date: date
}

"""aggregate min on columns"""
type eod_entry_per_eval_date_mview_min_fields {
  evaluation_date: date
}

"""
Ordering options when selecting data from "eod_entry_per_eval_date_mview".
"""
input eod_entry_per_eval_date_mview_order_by {
  evaluation_date: order_by
}

"""
select columns of table "eod_entry_per_eval_date_mview"
"""
enum eod_entry_per_eval_date_mview_select_column {
  """column name"""
  evaluation_date
}

"""
Streaming cursor of the table "eod_entry_per_eval_date_mview"
"""
input eod_entry_per_eval_date_mview_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: eod_entry_per_eval_date_mview_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input eod_entry_per_eval_date_mview_stream_cursor_value_input {
  evaluation_date: date
}

"""
columns and relationships of "eod_entry_per_eval_date_package_mview"
"""
type eod_entry_per_eval_date_package_mview {
  evaluation_date: date
  package: Int
}

"""
aggregated selection of "eod_entry_per_eval_date_package_mview"
"""
type eod_entry_per_eval_date_package_mview_aggregate {
  aggregate: eod_entry_per_eval_date_package_mview_aggregate_fields
  nodes: [eod_entry_per_eval_date_package_mview!]!
}

"""
aggregate fields of "eod_entry_per_eval_date_package_mview"
"""
type eod_entry_per_eval_date_package_mview_aggregate_fields {
  avg: eod_entry_per_eval_date_package_mview_avg_fields
  count(columns: [eod_entry_per_eval_date_package_mview_select_column!], distinct: Boolean): Int!
  max: eod_entry_per_eval_date_package_mview_max_fields
  min: eod_entry_per_eval_date_package_mview_min_fields
  stddev: eod_entry_per_eval_date_package_mview_stddev_fields
  stddev_pop: eod_entry_per_eval_date_package_mview_stddev_pop_fields
  stddev_samp: eod_entry_per_eval_date_package_mview_stddev_samp_fields
  sum: eod_entry_per_eval_date_package_mview_sum_fields
  var_pop: eod_entry_per_eval_date_package_mview_var_pop_fields
  var_samp: eod_entry_per_eval_date_package_mview_var_samp_fields
  variance: eod_entry_per_eval_date_package_mview_variance_fields
}

"""aggregate avg on columns"""
type eod_entry_per_eval_date_package_mview_avg_fields {
  package: Float
}

"""
Boolean expression to filter rows from the table "eod_entry_per_eval_date_package_mview". All fields are combined with a logical 'AND'.
"""
input eod_entry_per_eval_date_package_mview_bool_exp {
  _and: [eod_entry_per_eval_date_package_mview_bool_exp!]
  _not: eod_entry_per_eval_date_package_mview_bool_exp
  _or: [eod_entry_per_eval_date_package_mview_bool_exp!]
  evaluation_date: date_comparison_exp
  package: Int_comparison_exp
}

"""aggregate max on columns"""
type eod_entry_per_eval_date_package_mview_max_fields {
  evaluation_date: date
  package: Int
}

"""aggregate min on columns"""
type eod_entry_per_eval_date_package_mview_min_fields {
  evaluation_date: date
  package: Int
}

"""
Ordering options when selecting data from "eod_entry_per_eval_date_package_mview".
"""
input eod_entry_per_eval_date_package_mview_order_by {
  evaluation_date: order_by
  package: order_by
}

"""
select columns of table "eod_entry_per_eval_date_package_mview"
"""
enum eod_entry_per_eval_date_package_mview_select_column {
  """column name"""
  evaluation_date

  """column name"""
  package
}

"""aggregate stddev on columns"""
type eod_entry_per_eval_date_package_mview_stddev_fields {
  package: Float
}

"""aggregate stddev_pop on columns"""
type eod_entry_per_eval_date_package_mview_stddev_pop_fields {
  package: Float
}

"""aggregate stddev_samp on columns"""
type eod_entry_per_eval_date_package_mview_stddev_samp_fields {
  package: Float
}

"""
Streaming cursor of the table "eod_entry_per_eval_date_package_mview"
"""
input eod_entry_per_eval_date_package_mview_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: eod_entry_per_eval_date_package_mview_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input eod_entry_per_eval_date_package_mview_stream_cursor_value_input {
  evaluation_date: date
  package: Int
}

"""aggregate sum on columns"""
type eod_entry_per_eval_date_package_mview_sum_fields {
  package: Int
}

"""aggregate var_pop on columns"""
type eod_entry_per_eval_date_package_mview_var_pop_fields {
  package: Float
}

"""aggregate var_samp on columns"""
type eod_entry_per_eval_date_package_mview_var_samp_fields {
  package: Float
}

"""aggregate variance on columns"""
type eod_entry_per_eval_date_package_mview_variance_fields {
  package: Float
}

"""primary key columns input for table: eod_entry"""
input eod_entry_pk_columns_input {
  evaluation_date: date!
  month: date!
  product: uuid!
}

"""
select columns of table "eod_entry"
"""
enum eod_entry_select_column {
  """column name"""
  evaluation_date

  """column name"""
  id

  """column name"""
  month

  """column name"""
  ppend

  """column name"""
  ppstart

  """column name"""
  product

  """column name"""
  relative_period

  """column name"""
  value
}

"""
input type for updating data in table "eod_entry"
"""
input eod_entry_set_input {
  evaluation_date: date
  id: bigint
  month: date
  ppend: date
  ppstart: date
  product: uuid
  relative_period: Int
  value: numeric
}

"""aggregate stddev on columns"""
type eod_entry_stddev_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by stddev() on columns of table "eod_entry"
"""
input eod_entry_stddev_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type eod_entry_stddev_pop_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "eod_entry"
"""
input eod_entry_stddev_pop_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type eod_entry_stddev_samp_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "eod_entry"
"""
input eod_entry_stddev_samp_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""
Streaming cursor of the table "eod_entry"
"""
input eod_entry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: eod_entry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input eod_entry_stream_cursor_value_input {
  evaluation_date: date
  id: bigint
  month: date
  ppend: date
  ppstart: date
  product: uuid
  relative_period: Int
  value: numeric
}

"""aggregate sum on columns"""
type eod_entry_sum_fields {
  id: bigint
  relative_period: Int
  value: numeric
}

"""
order by sum() on columns of table "eod_entry"
"""
input eod_entry_sum_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""
update columns of table "eod_entry"
"""
enum eod_entry_update_column {
  """column name"""
  evaluation_date

  """column name"""
  id

  """column name"""
  month

  """column name"""
  ppend

  """column name"""
  ppstart

  """column name"""
  product

  """column name"""
  relative_period

  """column name"""
  value
}

input eod_entry_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: eod_entry_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: eod_entry_set_input

  """filter the rows which have to be updated"""
  where: eod_entry_bool_exp!
}

"""aggregate var_pop on columns"""
type eod_entry_var_pop_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by var_pop() on columns of table "eod_entry"
"""
input eod_entry_var_pop_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type eod_entry_var_samp_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by var_samp() on columns of table "eod_entry"
"""
input eod_entry_var_samp_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""aggregate variance on columns"""
type eod_entry_variance_fields {
  id: Float
  relative_period: Float
  value: Float
}

"""
order by variance() on columns of table "eod_entry"
"""
input eod_entry_variance_order_by {
  id: order_by
  relative_period: order_by
  value: order_by
}

"""
input type for incrementing numeric columns in table "eod"
"""
input eod_inc_input {
  id: Int
  source: Int
}

"""
input type for inserting data into table "eod"
"""
input eod_insert_input {
  id: Int
  source: Int
  sourceBySource: source_obj_rel_insert_input
}

"""aggregate max on columns"""
type eod_max_fields {
  id: Int
  source: Int
}

"""
order by max() on columns of table "eod"
"""
input eod_max_order_by {
  id: order_by
  source: order_by
}

"""aggregate min on columns"""
type eod_min_fields {
  id: Int
  source: Int
}

"""
order by min() on columns of table "eod"
"""
input eod_min_order_by {
  id: order_by
  source: order_by
}

"""
response of any mutation on the table "eod"
"""
type eod_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [eod!]!
}

"""
input type for inserting object relation for remote table "eod"
"""
input eod_obj_rel_insert_input {
  data: eod_insert_input!

  """upsert condition"""
  on_conflict: eod_on_conflict
}

"""
on_conflict condition type for table "eod"
"""
input eod_on_conflict {
  constraint: eod_constraint!
  update_columns: [eod_update_column!]! = []
  where: eod_bool_exp
}

"""Ordering options when selecting data from "eod"."""
input eod_order_by {
  id: order_by
  source: order_by
  sourceBySource: source_order_by
}

"""primary key columns input for table: eod"""
input eod_pk_columns_input {
  id: Int!
}

"""
select columns of table "eod"
"""
enum eod_select_column {
  """column name"""
  id

  """column name"""
  source
}

"""
input type for updating data in table "eod"
"""
input eod_set_input {
  id: Int
  source: Int
}

"""aggregate stddev on columns"""
type eod_stddev_fields {
  id: Float
  source: Float
}

"""
order by stddev() on columns of table "eod"
"""
input eod_stddev_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_pop on columns"""
type eod_stddev_pop_fields {
  id: Float
  source: Float
}

"""
order by stddev_pop() on columns of table "eod"
"""
input eod_stddev_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_samp on columns"""
type eod_stddev_samp_fields {
  id: Float
  source: Float
}

"""
order by stddev_samp() on columns of table "eod"
"""
input eod_stddev_samp_order_by {
  id: order_by
  source: order_by
}

"""
Streaming cursor of the table "eod"
"""
input eod_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: eod_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input eod_stream_cursor_value_input {
  id: Int
  source: Int
}

"""aggregate sum on columns"""
type eod_sum_fields {
  id: Int
  source: Int
}

"""
order by sum() on columns of table "eod"
"""
input eod_sum_order_by {
  id: order_by
  source: order_by
}

"""
update columns of table "eod"
"""
enum eod_update_column {
  """column name"""
  id

  """column name"""
  source
}

input eod_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: eod_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: eod_set_input

  """filter the rows which have to be updated"""
  where: eod_bool_exp!
}

"""aggregate var_pop on columns"""
type eod_var_pop_fields {
  id: Float
  source: Float
}

"""
order by var_pop() on columns of table "eod"
"""
input eod_var_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate var_samp on columns"""
type eod_var_samp_fields {
  id: Float
  source: Float
}

"""
order by var_samp() on columns of table "eod"
"""
input eod_var_samp_order_by {
  id: order_by
  source: order_by
}

"""aggregate variance on columns"""
type eod_variance_fields {
  id: Float
  source: Float
}

"""
order by variance() on columns of table "eod"
"""
input eod_variance_order_by {
  id: order_by
  source: order_by
}

"""
columns and relationships of "exchange"
"""
type exchange {
  code: Int!
  future_code_gen_template: String!
  future_code_parse_template: String!
  future_time_spread_gen_template: String!
  id: Int!
  source: Int!

  """An object relationship"""
  sourceBySource: source!
}

"""
aggregated selection of "exchange"
"""
type exchange_aggregate {
  aggregate: exchange_aggregate_fields
  nodes: [exchange!]!
}

input exchange_aggregate_bool_exp {
  count: exchange_aggregate_bool_exp_count
}

input exchange_aggregate_bool_exp_count {
  arguments: [exchange_select_column!]
  distinct: Boolean
  filter: exchange_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "exchange"
"""
type exchange_aggregate_fields {
  avg: exchange_avg_fields
  count(columns: [exchange_select_column!], distinct: Boolean): Int!
  max: exchange_max_fields
  min: exchange_min_fields
  stddev: exchange_stddev_fields
  stddev_pop: exchange_stddev_pop_fields
  stddev_samp: exchange_stddev_samp_fields
  sum: exchange_sum_fields
  var_pop: exchange_var_pop_fields
  var_samp: exchange_var_samp_fields
  variance: exchange_variance_fields
}

"""
order by aggregate values of table "exchange"
"""
input exchange_aggregate_order_by {
  avg: exchange_avg_order_by
  count: order_by
  max: exchange_max_order_by
  min: exchange_min_order_by
  stddev: exchange_stddev_order_by
  stddev_pop: exchange_stddev_pop_order_by
  stddev_samp: exchange_stddev_samp_order_by
  sum: exchange_sum_order_by
  var_pop: exchange_var_pop_order_by
  var_samp: exchange_var_samp_order_by
  variance: exchange_variance_order_by
}

"""
input type for inserting array relation for remote table "exchange"
"""
input exchange_arr_rel_insert_input {
  data: [exchange_insert_input!]!

  """upsert condition"""
  on_conflict: exchange_on_conflict
}

"""aggregate avg on columns"""
type exchange_avg_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by avg() on columns of table "exchange"
"""
input exchange_avg_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""
Boolean expression to filter rows from the table "exchange". All fields are combined with a logical 'AND'.
"""
input exchange_bool_exp {
  _and: [exchange_bool_exp!]
  _not: exchange_bool_exp
  _or: [exchange_bool_exp!]
  code: Int_comparison_exp
  future_code_gen_template: String_comparison_exp
  future_code_parse_template: String_comparison_exp
  future_time_spread_gen_template: String_comparison_exp
  id: Int_comparison_exp
  source: Int_comparison_exp
  sourceBySource: source_bool_exp
}

"""
unique or primary key constraints on table "exchange"
"""
enum exchange_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  exchange_code_key

  """
  unique or primary key constraint on columns "id"
  """
  exchange_pkey

  """
  unique or primary key constraint on columns "source"
  """
  exchange_source_key
}

"""
columns and relationships of "exchange_event_type"
"""
type exchange_event_type {
  value: String!
}

"""
aggregated selection of "exchange_event_type"
"""
type exchange_event_type_aggregate {
  aggregate: exchange_event_type_aggregate_fields
  nodes: [exchange_event_type!]!
}

"""
aggregate fields of "exchange_event_type"
"""
type exchange_event_type_aggregate_fields {
  count(columns: [exchange_event_type_select_column!], distinct: Boolean): Int!
  max: exchange_event_type_max_fields
  min: exchange_event_type_min_fields
}

"""
Boolean expression to filter rows from the table "exchange_event_type". All fields are combined with a logical 'AND'.
"""
input exchange_event_type_bool_exp {
  _and: [exchange_event_type_bool_exp!]
  _not: exchange_event_type_bool_exp
  _or: [exchange_event_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "exchange_event_type"
"""
enum exchange_event_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  exchange_event_type_pkey
}

"""
input type for inserting data into table "exchange_event_type"
"""
input exchange_event_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type exchange_event_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type exchange_event_type_min_fields {
  value: String
}

"""
response of any mutation on the table "exchange_event_type"
"""
type exchange_event_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [exchange_event_type!]!
}

"""
on_conflict condition type for table "exchange_event_type"
"""
input exchange_event_type_on_conflict {
  constraint: exchange_event_type_constraint!
  update_columns: [exchange_event_type_update_column!]! = []
  where: exchange_event_type_bool_exp
}

"""Ordering options when selecting data from "exchange_event_type"."""
input exchange_event_type_order_by {
  value: order_by
}

"""primary key columns input for table: exchange_event_type"""
input exchange_event_type_pk_columns_input {
  value: String!
}

"""
select columns of table "exchange_event_type"
"""
enum exchange_event_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "exchange_event_type"
"""
input exchange_event_type_set_input {
  value: String
}

"""
Streaming cursor of the table "exchange_event_type"
"""
input exchange_event_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: exchange_event_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input exchange_event_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "exchange_event_type"
"""
enum exchange_event_type_update_column {
  """column name"""
  value
}

input exchange_event_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: exchange_event_type_set_input

  """filter the rows which have to be updated"""
  where: exchange_event_type_bool_exp!
}

"""
input type for incrementing numeric columns in table "exchange"
"""
input exchange_inc_input {
  code: Int
  id: Int
  source: Int
}

"""
input type for inserting data into table "exchange"
"""
input exchange_insert_input {
  code: Int
  future_code_gen_template: String
  future_code_parse_template: String
  future_time_spread_gen_template: String
  id: Int
  source: Int
  sourceBySource: source_obj_rel_insert_input
}

"""aggregate max on columns"""
type exchange_max_fields {
  code: Int
  future_code_gen_template: String
  future_code_parse_template: String
  future_time_spread_gen_template: String
  id: Int
  source: Int
}

"""
order by max() on columns of table "exchange"
"""
input exchange_max_order_by {
  code: order_by
  future_code_gen_template: order_by
  future_code_parse_template: order_by
  future_time_spread_gen_template: order_by
  id: order_by
  source: order_by
}

"""aggregate min on columns"""
type exchange_min_fields {
  code: Int
  future_code_gen_template: String
  future_code_parse_template: String
  future_time_spread_gen_template: String
  id: Int
  source: Int
}

"""
order by min() on columns of table "exchange"
"""
input exchange_min_order_by {
  code: order_by
  future_code_gen_template: order_by
  future_code_parse_template: order_by
  future_time_spread_gen_template: order_by
  id: order_by
  source: order_by
}

"""
response of any mutation on the table "exchange"
"""
type exchange_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [exchange!]!
}

"""
input type for inserting object relation for remote table "exchange"
"""
input exchange_obj_rel_insert_input {
  data: exchange_insert_input!

  """upsert condition"""
  on_conflict: exchange_on_conflict
}

"""
on_conflict condition type for table "exchange"
"""
input exchange_on_conflict {
  constraint: exchange_constraint!
  update_columns: [exchange_update_column!]! = []
  where: exchange_bool_exp
}

"""Ordering options when selecting data from "exchange"."""
input exchange_order_by {
  code: order_by
  future_code_gen_template: order_by
  future_code_parse_template: order_by
  future_time_spread_gen_template: order_by
  id: order_by
  source: order_by
  sourceBySource: source_order_by
}

"""primary key columns input for table: exchange"""
input exchange_pk_columns_input {
  id: Int!
}

"""
select columns of table "exchange"
"""
enum exchange_select_column {
  """column name"""
  code

  """column name"""
  future_code_gen_template

  """column name"""
  future_code_parse_template

  """column name"""
  future_time_spread_gen_template

  """column name"""
  id

  """column name"""
  source
}

"""
input type for updating data in table "exchange"
"""
input exchange_set_input {
  code: Int
  future_code_gen_template: String
  future_code_parse_template: String
  future_time_spread_gen_template: String
  id: Int
  source: Int
}

"""aggregate stddev on columns"""
type exchange_stddev_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by stddev() on columns of table "exchange"
"""
input exchange_stddev_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""aggregate stddev_pop on columns"""
type exchange_stddev_pop_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by stddev_pop() on columns of table "exchange"
"""
input exchange_stddev_pop_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""aggregate stddev_samp on columns"""
type exchange_stddev_samp_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by stddev_samp() on columns of table "exchange"
"""
input exchange_stddev_samp_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""
Streaming cursor of the table "exchange"
"""
input exchange_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: exchange_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input exchange_stream_cursor_value_input {
  code: Int
  future_code_gen_template: String
  future_code_parse_template: String
  future_time_spread_gen_template: String
  id: Int
  source: Int
}

"""aggregate sum on columns"""
type exchange_sum_fields {
  code: Int
  id: Int
  source: Int
}

"""
order by sum() on columns of table "exchange"
"""
input exchange_sum_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""
update columns of table "exchange"
"""
enum exchange_update_column {
  """column name"""
  code

  """column name"""
  future_code_gen_template

  """column name"""
  future_code_parse_template

  """column name"""
  future_time_spread_gen_template

  """column name"""
  id

  """column name"""
  source
}

input exchange_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: exchange_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: exchange_set_input

  """filter the rows which have to be updated"""
  where: exchange_bool_exp!
}

"""
columns and relationships of "exchange_usage"
"""
type exchange_usage {
  event: String!
  event_date: timestamptz!

  """An object relationship"""
  exchangeUsageByFolioUser: folio_user
  folio_user: String!
  id: Int!
  source: Int!
}

"""
aggregated selection of "exchange_usage"
"""
type exchange_usage_aggregate {
  aggregate: exchange_usage_aggregate_fields
  nodes: [exchange_usage!]!
}

"""
aggregate fields of "exchange_usage"
"""
type exchange_usage_aggregate_fields {
  avg: exchange_usage_avg_fields
  count(columns: [exchange_usage_select_column!], distinct: Boolean): Int!
  max: exchange_usage_max_fields
  min: exchange_usage_min_fields
  stddev: exchange_usage_stddev_fields
  stddev_pop: exchange_usage_stddev_pop_fields
  stddev_samp: exchange_usage_stddev_samp_fields
  sum: exchange_usage_sum_fields
  var_pop: exchange_usage_var_pop_fields
  var_samp: exchange_usage_var_samp_fields
  variance: exchange_usage_variance_fields
}

"""aggregate avg on columns"""
type exchange_usage_avg_fields {
  id: Float
  source: Float
}

"""
Boolean expression to filter rows from the table "exchange_usage". All fields are combined with a logical 'AND'.
"""
input exchange_usage_bool_exp {
  _and: [exchange_usage_bool_exp!]
  _not: exchange_usage_bool_exp
  _or: [exchange_usage_bool_exp!]
  event: String_comparison_exp
  event_date: timestamptz_comparison_exp
  exchangeUsageByFolioUser: folio_user_bool_exp
  folio_user: String_comparison_exp
  id: Int_comparison_exp
  source: Int_comparison_exp
}

"""
unique or primary key constraints on table "exchange_usage"
"""
enum exchange_usage_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  exchange_usage_pkey
}

"""
input type for incrementing numeric columns in table "exchange_usage"
"""
input exchange_usage_inc_input {
  id: Int
  source: Int
}

"""
input type for inserting data into table "exchange_usage"
"""
input exchange_usage_insert_input {
  event: String
  event_date: timestamptz
  exchangeUsageByFolioUser: folio_user_obj_rel_insert_input
  folio_user: String
  id: Int
  source: Int
}

"""
columns and relationships of "exchange_usage_last"
"""
type exchange_usage_last {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""
aggregated selection of "exchange_usage_last"
"""
type exchange_usage_last_aggregate {
  aggregate: exchange_usage_last_aggregate_fields
  nodes: [exchange_usage_last!]!
}

"""
aggregate fields of "exchange_usage_last"
"""
type exchange_usage_last_aggregate_fields {
  avg: exchange_usage_last_avg_fields
  count(columns: [exchange_usage_last_select_column!], distinct: Boolean): Int!
  max: exchange_usage_last_max_fields
  min: exchange_usage_last_min_fields
  stddev: exchange_usage_last_stddev_fields
  stddev_pop: exchange_usage_last_stddev_pop_fields
  stddev_samp: exchange_usage_last_stddev_samp_fields
  sum: exchange_usage_last_sum_fields
  var_pop: exchange_usage_last_var_pop_fields
  var_samp: exchange_usage_last_var_samp_fields
  variance: exchange_usage_last_variance_fields
}

"""aggregate avg on columns"""
type exchange_usage_last_avg_fields {
  source: Float
}

"""
Boolean expression to filter rows from the table "exchange_usage_last". All fields are combined with a logical 'AND'.
"""
input exchange_usage_last_bool_exp {
  _and: [exchange_usage_last_bool_exp!]
  _not: exchange_usage_last_bool_exp
  _or: [exchange_usage_last_bool_exp!]
  event: String_comparison_exp
  event_date: timestamptz_comparison_exp
  folio_user: String_comparison_exp
  source: Int_comparison_exp
}

"""aggregate max on columns"""
type exchange_usage_last_max_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""aggregate min on columns"""
type exchange_usage_last_min_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""Ordering options when selecting data from "exchange_usage_last"."""
input exchange_usage_last_order_by {
  event: order_by
  event_date: order_by
  folio_user: order_by
  source: order_by
}

"""
select columns of table "exchange_usage_last"
"""
enum exchange_usage_last_select_column {
  """column name"""
  event

  """column name"""
  event_date

  """column name"""
  folio_user

  """column name"""
  source
}

"""aggregate stddev on columns"""
type exchange_usage_last_stddev_fields {
  source: Float
}

"""aggregate stddev_pop on columns"""
type exchange_usage_last_stddev_pop_fields {
  source: Float
}

"""aggregate stddev_samp on columns"""
type exchange_usage_last_stddev_samp_fields {
  source: Float
}

"""
Streaming cursor of the table "exchange_usage_last"
"""
input exchange_usage_last_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: exchange_usage_last_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input exchange_usage_last_stream_cursor_value_input {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""aggregate sum on columns"""
type exchange_usage_last_sum_fields {
  source: Int
}

"""aggregate var_pop on columns"""
type exchange_usage_last_var_pop_fields {
  source: Float
}

"""aggregate var_samp on columns"""
type exchange_usage_last_var_samp_fields {
  source: Float
}

"""aggregate variance on columns"""
type exchange_usage_last_variance_fields {
  source: Float
}

"""aggregate max on columns"""
type exchange_usage_max_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  id: Int
  source: Int
}

"""aggregate min on columns"""
type exchange_usage_min_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  id: Int
  source: Int
}

"""
response of any mutation on the table "exchange_usage"
"""
type exchange_usage_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [exchange_usage!]!
}

"""
on_conflict condition type for table "exchange_usage"
"""
input exchange_usage_on_conflict {
  constraint: exchange_usage_constraint!
  update_columns: [exchange_usage_update_column!]! = []
  where: exchange_usage_bool_exp
}

"""Ordering options when selecting data from "exchange_usage"."""
input exchange_usage_order_by {
  event: order_by
  event_date: order_by
  exchangeUsageByFolioUser: folio_user_order_by
  folio_user: order_by
  id: order_by
  source: order_by
}

"""primary key columns input for table: exchange_usage"""
input exchange_usage_pk_columns_input {
  id: Int!
}

"""
select columns of table "exchange_usage"
"""
enum exchange_usage_select_column {
  """column name"""
  event

  """column name"""
  event_date

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  source
}

"""
input type for updating data in table "exchange_usage"
"""
input exchange_usage_set_input {
  event: String
  event_date: timestamptz
  folio_user: String
  id: Int
  source: Int
}

"""
columns and relationships of "exchange_usage_start"
"""
type exchange_usage_start {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""
aggregated selection of "exchange_usage_start"
"""
type exchange_usage_start_aggregate {
  aggregate: exchange_usage_start_aggregate_fields
  nodes: [exchange_usage_start!]!
}

"""
aggregate fields of "exchange_usage_start"
"""
type exchange_usage_start_aggregate_fields {
  avg: exchange_usage_start_avg_fields
  count(columns: [exchange_usage_start_select_column!], distinct: Boolean): Int!
  max: exchange_usage_start_max_fields
  min: exchange_usage_start_min_fields
  stddev: exchange_usage_start_stddev_fields
  stddev_pop: exchange_usage_start_stddev_pop_fields
  stddev_samp: exchange_usage_start_stddev_samp_fields
  sum: exchange_usage_start_sum_fields
  var_pop: exchange_usage_start_var_pop_fields
  var_samp: exchange_usage_start_var_samp_fields
  variance: exchange_usage_start_variance_fields
}

"""aggregate avg on columns"""
type exchange_usage_start_avg_fields {
  source: Float
}

"""
Boolean expression to filter rows from the table "exchange_usage_start". All fields are combined with a logical 'AND'.
"""
input exchange_usage_start_bool_exp {
  _and: [exchange_usage_start_bool_exp!]
  _not: exchange_usage_start_bool_exp
  _or: [exchange_usage_start_bool_exp!]
  event: String_comparison_exp
  event_date: timestamptz_comparison_exp
  folio_user: String_comparison_exp
  source: Int_comparison_exp
}

"""aggregate max on columns"""
type exchange_usage_start_max_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""aggregate min on columns"""
type exchange_usage_start_min_fields {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""Ordering options when selecting data from "exchange_usage_start"."""
input exchange_usage_start_order_by {
  event: order_by
  event_date: order_by
  folio_user: order_by
  source: order_by
}

"""
select columns of table "exchange_usage_start"
"""
enum exchange_usage_start_select_column {
  """column name"""
  event

  """column name"""
  event_date

  """column name"""
  folio_user

  """column name"""
  source
}

"""aggregate stddev on columns"""
type exchange_usage_start_stddev_fields {
  source: Float
}

"""aggregate stddev_pop on columns"""
type exchange_usage_start_stddev_pop_fields {
  source: Float
}

"""aggregate stddev_samp on columns"""
type exchange_usage_start_stddev_samp_fields {
  source: Float
}

"""
Streaming cursor of the table "exchange_usage_start"
"""
input exchange_usage_start_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: exchange_usage_start_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input exchange_usage_start_stream_cursor_value_input {
  event: String
  event_date: timestamptz
  folio_user: String
  source: Int
}

"""aggregate sum on columns"""
type exchange_usage_start_sum_fields {
  source: Int
}

"""aggregate var_pop on columns"""
type exchange_usage_start_var_pop_fields {
  source: Float
}

"""aggregate var_samp on columns"""
type exchange_usage_start_var_samp_fields {
  source: Float
}

"""aggregate variance on columns"""
type exchange_usage_start_variance_fields {
  source: Float
}

"""aggregate stddev on columns"""
type exchange_usage_stddev_fields {
  id: Float
  source: Float
}

"""aggregate stddev_pop on columns"""
type exchange_usage_stddev_pop_fields {
  id: Float
  source: Float
}

"""aggregate stddev_samp on columns"""
type exchange_usage_stddev_samp_fields {
  id: Float
  source: Float
}

"""
Streaming cursor of the table "exchange_usage"
"""
input exchange_usage_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: exchange_usage_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input exchange_usage_stream_cursor_value_input {
  event: String
  event_date: timestamptz
  folio_user: String
  id: Int
  source: Int
}

"""aggregate sum on columns"""
type exchange_usage_sum_fields {
  id: Int
  source: Int
}

"""
update columns of table "exchange_usage"
"""
enum exchange_usage_update_column {
  """column name"""
  event

  """column name"""
  event_date

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  source
}

input exchange_usage_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: exchange_usage_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: exchange_usage_set_input

  """filter the rows which have to be updated"""
  where: exchange_usage_bool_exp!
}

"""aggregate var_pop on columns"""
type exchange_usage_var_pop_fields {
  id: Float
  source: Float
}

"""aggregate var_samp on columns"""
type exchange_usage_var_samp_fields {
  id: Float
  source: Float
}

"""aggregate variance on columns"""
type exchange_usage_variance_fields {
  id: Float
  source: Float
}

"""aggregate var_pop on columns"""
type exchange_var_pop_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by var_pop() on columns of table "exchange"
"""
input exchange_var_pop_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""aggregate var_samp on columns"""
type exchange_var_samp_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by var_samp() on columns of table "exchange"
"""
input exchange_var_samp_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""aggregate variance on columns"""
type exchange_variance_fields {
  code: Float
  id: Float
  source: Float
}

"""
order by variance() on columns of table "exchange"
"""
input exchange_variance_order_by {
  code: order_by
  id: order_by
  source: order_by
}

"""Users column-settings as JSON scoped by page-id."""
type folio_column_settings {
  folio_user: String!
  state(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "folio_column_settings"
"""
type folio_column_settings_aggregate {
  aggregate: folio_column_settings_aggregate_fields
  nodes: [folio_column_settings!]!
}

"""
aggregate fields of "folio_column_settings"
"""
type folio_column_settings_aggregate_fields {
  count(columns: [folio_column_settings_select_column!], distinct: Boolean): Int!
  max: folio_column_settings_max_fields
  min: folio_column_settings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input folio_column_settings_append_input {
  state: jsonb
}

"""
Boolean expression to filter rows from the table "folio_column_settings". All fields are combined with a logical 'AND'.
"""
input folio_column_settings_bool_exp {
  _and: [folio_column_settings_bool_exp!]
  _not: folio_column_settings_bool_exp
  _or: [folio_column_settings_bool_exp!]
  folio_user: String_comparison_exp
  state: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "folio_column_settings"
"""
enum folio_column_settings_constraint {
  """
  unique or primary key constraint on columns "folio_user"
  """
  folio_column_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input folio_column_settings_delete_at_path_input {
  state: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input folio_column_settings_delete_elem_input {
  state: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input folio_column_settings_delete_key_input {
  state: String
}

"""
input type for inserting data into table "folio_column_settings"
"""
input folio_column_settings_insert_input {
  folio_user: String
  state: jsonb
}

"""aggregate max on columns"""
type folio_column_settings_max_fields {
  folio_user: String
}

"""aggregate min on columns"""
type folio_column_settings_min_fields {
  folio_user: String
}

"""
response of any mutation on the table "folio_column_settings"
"""
type folio_column_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [folio_column_settings!]!
}

"""
on_conflict condition type for table "folio_column_settings"
"""
input folio_column_settings_on_conflict {
  constraint: folio_column_settings_constraint!
  update_columns: [folio_column_settings_update_column!]! = []
  where: folio_column_settings_bool_exp
}

"""Ordering options when selecting data from "folio_column_settings"."""
input folio_column_settings_order_by {
  folio_user: order_by
  state: order_by
}

"""primary key columns input for table: folio_column_settings"""
input folio_column_settings_pk_columns_input {
  folio_user: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input folio_column_settings_prepend_input {
  state: jsonb
}

"""
select columns of table "folio_column_settings"
"""
enum folio_column_settings_select_column {
  """column name"""
  folio_user

  """column name"""
  state
}

"""
input type for updating data in table "folio_column_settings"
"""
input folio_column_settings_set_input {
  folio_user: String
  state: jsonb
}

"""
Streaming cursor of the table "folio_column_settings"
"""
input folio_column_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: folio_column_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input folio_column_settings_stream_cursor_value_input {
  folio_user: String
  state: jsonb
}

"""
update columns of table "folio_column_settings"
"""
enum folio_column_settings_update_column {
  """column name"""
  folio_user

  """column name"""
  state
}

input folio_column_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: folio_column_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: folio_column_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: folio_column_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: folio_column_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: folio_column_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: folio_column_settings_set_input

  """filter the rows which have to be updated"""
  where: folio_column_settings_bool_exp!
}

"""
Stores state of 'shadow' curves like extra months and divider columns. Separated from page settings so it doesn't interfere with the api or openfin
"""
type folio_shadow_curves {
  folio_user: String!
  state(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "folio_shadow_curves"
"""
type folio_shadow_curves_aggregate {
  aggregate: folio_shadow_curves_aggregate_fields
  nodes: [folio_shadow_curves!]!
}

"""
aggregate fields of "folio_shadow_curves"
"""
type folio_shadow_curves_aggregate_fields {
  count(columns: [folio_shadow_curves_select_column!], distinct: Boolean): Int!
  max: folio_shadow_curves_max_fields
  min: folio_shadow_curves_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input folio_shadow_curves_append_input {
  state: jsonb
}

"""
Boolean expression to filter rows from the table "folio_shadow_curves". All fields are combined with a logical 'AND'.
"""
input folio_shadow_curves_bool_exp {
  _and: [folio_shadow_curves_bool_exp!]
  _not: folio_shadow_curves_bool_exp
  _or: [folio_shadow_curves_bool_exp!]
  folio_user: String_comparison_exp
  state: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "folio_shadow_curves"
"""
enum folio_shadow_curves_constraint {
  """
  unique or primary key constraint on columns "folio_user"
  """
  folio_shadow_curves_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input folio_shadow_curves_delete_at_path_input {
  state: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input folio_shadow_curves_delete_elem_input {
  state: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input folio_shadow_curves_delete_key_input {
  state: String
}

"""
input type for inserting data into table "folio_shadow_curves"
"""
input folio_shadow_curves_insert_input {
  folio_user: String
  state: jsonb
}

"""aggregate max on columns"""
type folio_shadow_curves_max_fields {
  folio_user: String
}

"""aggregate min on columns"""
type folio_shadow_curves_min_fields {
  folio_user: String
}

"""
response of any mutation on the table "folio_shadow_curves"
"""
type folio_shadow_curves_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [folio_shadow_curves!]!
}

"""
on_conflict condition type for table "folio_shadow_curves"
"""
input folio_shadow_curves_on_conflict {
  constraint: folio_shadow_curves_constraint!
  update_columns: [folio_shadow_curves_update_column!]! = []
  where: folio_shadow_curves_bool_exp
}

"""Ordering options when selecting data from "folio_shadow_curves"."""
input folio_shadow_curves_order_by {
  folio_user: order_by
  state: order_by
}

"""primary key columns input for table: folio_shadow_curves"""
input folio_shadow_curves_pk_columns_input {
  folio_user: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input folio_shadow_curves_prepend_input {
  state: jsonb
}

"""
select columns of table "folio_shadow_curves"
"""
enum folio_shadow_curves_select_column {
  """column name"""
  folio_user

  """column name"""
  state
}

"""
input type for updating data in table "folio_shadow_curves"
"""
input folio_shadow_curves_set_input {
  folio_user: String
  state: jsonb
}

"""
Streaming cursor of the table "folio_shadow_curves"
"""
input folio_shadow_curves_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: folio_shadow_curves_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input folio_shadow_curves_stream_cursor_value_input {
  folio_user: String
  state: jsonb
}

"""
update columns of table "folio_shadow_curves"
"""
enum folio_shadow_curves_update_column {
  """column name"""
  folio_user

  """column name"""
  state
}

input folio_shadow_curves_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: folio_shadow_curves_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: folio_shadow_curves_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: folio_shadow_curves_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: folio_shadow_curves_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: folio_shadow_curves_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: folio_shadow_curves_set_input

  """filter the rows which have to be updated"""
  where: folio_shadow_curves_bool_exp!
}

"""
columns and relationships of "folio_user"
"""
type folio_user {
  blocked: Boolean!
  created: timestamptz!
  email: citext!
  firstname: String!

  """An object relationship"""
  hfc_card_setting: hfc_card_settings

  """An object relationship"""
  hfc_user_setting: hfc_user_settings
  id: String!
  last_login: timestamptz!
  last_seen: timestamptz
  lastname: String!
  licence_agreements(
    """JSON select path"""
    path: String
  ): jsonb!

  """An array relationship"""
  local_instruments(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): [local_instrument!]!

  """An aggregate relationship"""
  local_instruments_aggregate(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): local_instrument_aggregate!
  login_count: Int!
  logout_requested_at: timestamptz

  """An array relationship"""
  logout_requests(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): [logout_request!]!

  """An aggregate relationship"""
  logout_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): logout_request_aggregate!
  organisation: Int!

  """An object relationship"""
  organisationByOrganisation: organisation!
  package: Int

  """An object relationship"""
  page_setting: page_settings

  """An array relationship"""
  page_settings(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): [page_settings!]!

  """An aggregate relationship"""
  page_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): page_settings_aggregate!

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): permission_aggregate!
  roles(
    """JSON select path"""
    path: String
  ): jsonb!

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """An array relationship"""
  shared_instruments(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]!

  """An aggregate relationship"""
  shared_instruments_aggregate(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): shared_instrument_aggregate!
  username: citext!

  """An object relationship"""
  userpackageByUser: package
}

"""
aggregated selection of "folio_user"
"""
type folio_user_aggregate {
  aggregate: folio_user_aggregate_fields
  nodes: [folio_user!]!
}

input folio_user_aggregate_bool_exp {
  bool_and: folio_user_aggregate_bool_exp_bool_and
  bool_or: folio_user_aggregate_bool_exp_bool_or
  count: folio_user_aggregate_bool_exp_count
}

input folio_user_aggregate_bool_exp_bool_and {
  arguments: folio_user_select_column_folio_user_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: folio_user_bool_exp
  predicate: Boolean_comparison_exp!
}

input folio_user_aggregate_bool_exp_bool_or {
  arguments: folio_user_select_column_folio_user_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: folio_user_bool_exp
  predicate: Boolean_comparison_exp!
}

input folio_user_aggregate_bool_exp_count {
  arguments: [folio_user_select_column!]
  distinct: Boolean
  filter: folio_user_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "folio_user"
"""
type folio_user_aggregate_fields {
  avg: folio_user_avg_fields
  count(columns: [folio_user_select_column!], distinct: Boolean): Int!
  max: folio_user_max_fields
  min: folio_user_min_fields
  stddev: folio_user_stddev_fields
  stddev_pop: folio_user_stddev_pop_fields
  stddev_samp: folio_user_stddev_samp_fields
  sum: folio_user_sum_fields
  var_pop: folio_user_var_pop_fields
  var_samp: folio_user_var_samp_fields
  variance: folio_user_variance_fields
}

"""
order by aggregate values of table "folio_user"
"""
input folio_user_aggregate_order_by {
  avg: folio_user_avg_order_by
  count: order_by
  max: folio_user_max_order_by
  min: folio_user_min_order_by
  stddev: folio_user_stddev_order_by
  stddev_pop: folio_user_stddev_pop_order_by
  stddev_samp: folio_user_stddev_samp_order_by
  sum: folio_user_sum_order_by
  var_pop: folio_user_var_pop_order_by
  var_samp: folio_user_var_samp_order_by
  variance: folio_user_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input folio_user_append_input {
  licence_agreements: jsonb
  roles: jsonb
}

"""
input type for inserting array relation for remote table "folio_user"
"""
input folio_user_arr_rel_insert_input {
  data: [folio_user_insert_input!]!

  """upsert condition"""
  on_conflict: folio_user_on_conflict
}

"""aggregate avg on columns"""
type folio_user_avg_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by avg() on columns of table "folio_user"
"""
input folio_user_avg_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""
columns and relationships of "folio_user_basic_profile"
"""
type folio_user_basic_profile {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""
aggregated selection of "folio_user_basic_profile"
"""
type folio_user_basic_profile_aggregate {
  aggregate: folio_user_basic_profile_aggregate_fields
  nodes: [folio_user_basic_profile!]!
}

"""
aggregate fields of "folio_user_basic_profile"
"""
type folio_user_basic_profile_aggregate_fields {
  avg: folio_user_basic_profile_avg_fields
  count(columns: [folio_user_basic_profile_select_column!], distinct: Boolean): Int!
  max: folio_user_basic_profile_max_fields
  min: folio_user_basic_profile_min_fields
  stddev: folio_user_basic_profile_stddev_fields
  stddev_pop: folio_user_basic_profile_stddev_pop_fields
  stddev_samp: folio_user_basic_profile_stddev_samp_fields
  sum: folio_user_basic_profile_sum_fields
  var_pop: folio_user_basic_profile_var_pop_fields
  var_samp: folio_user_basic_profile_var_samp_fields
  variance: folio_user_basic_profile_variance_fields
}

"""aggregate avg on columns"""
type folio_user_basic_profile_avg_fields {
  organisation: Float
}

"""
Boolean expression to filter rows from the table "folio_user_basic_profile". All fields are combined with a logical 'AND'.
"""
input folio_user_basic_profile_bool_exp {
  _and: [folio_user_basic_profile_bool_exp!]
  _not: folio_user_basic_profile_bool_exp
  _or: [folio_user_basic_profile_bool_exp!]
  firstname: String_comparison_exp
  id: String_comparison_exp
  lastname: String_comparison_exp
  organisation: Int_comparison_exp
  username: citext_comparison_exp
}

"""
input type for incrementing numeric columns in table "folio_user_basic_profile"
"""
input folio_user_basic_profile_inc_input {
  organisation: Int
}

"""
input type for inserting data into table "folio_user_basic_profile"
"""
input folio_user_basic_profile_insert_input {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""aggregate max on columns"""
type folio_user_basic_profile_max_fields {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""aggregate min on columns"""
type folio_user_basic_profile_min_fields {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""
response of any mutation on the table "folio_user_basic_profile"
"""
type folio_user_basic_profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [folio_user_basic_profile!]!
}

"""
input type for inserting object relation for remote table "folio_user_basic_profile"
"""
input folio_user_basic_profile_obj_rel_insert_input {
  data: folio_user_basic_profile_insert_input!
}

"""Ordering options when selecting data from "folio_user_basic_profile"."""
input folio_user_basic_profile_order_by {
  firstname: order_by
  id: order_by
  lastname: order_by
  organisation: order_by
  username: order_by
}

"""
select columns of table "folio_user_basic_profile"
"""
enum folio_user_basic_profile_select_column {
  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  lastname

  """column name"""
  organisation

  """column name"""
  username
}

"""
input type for updating data in table "folio_user_basic_profile"
"""
input folio_user_basic_profile_set_input {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""aggregate stddev on columns"""
type folio_user_basic_profile_stddev_fields {
  organisation: Float
}

"""aggregate stddev_pop on columns"""
type folio_user_basic_profile_stddev_pop_fields {
  organisation: Float
}

"""aggregate stddev_samp on columns"""
type folio_user_basic_profile_stddev_samp_fields {
  organisation: Float
}

"""
Streaming cursor of the table "folio_user_basic_profile"
"""
input folio_user_basic_profile_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: folio_user_basic_profile_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input folio_user_basic_profile_stream_cursor_value_input {
  firstname: String
  id: String
  lastname: String
  organisation: Int
  username: citext
}

"""aggregate sum on columns"""
type folio_user_basic_profile_sum_fields {
  organisation: Int
}

input folio_user_basic_profile_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: folio_user_basic_profile_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: folio_user_basic_profile_set_input

  """filter the rows which have to be updated"""
  where: folio_user_basic_profile_bool_exp!
}

"""aggregate var_pop on columns"""
type folio_user_basic_profile_var_pop_fields {
  organisation: Float
}

"""aggregate var_samp on columns"""
type folio_user_basic_profile_var_samp_fields {
  organisation: Float
}

"""aggregate variance on columns"""
type folio_user_basic_profile_variance_fields {
  organisation: Float
}

"""
Boolean expression to filter rows from the table "folio_user". All fields are combined with a logical 'AND'.
"""
input folio_user_bool_exp {
  _and: [folio_user_bool_exp!]
  _not: folio_user_bool_exp
  _or: [folio_user_bool_exp!]
  blocked: Boolean_comparison_exp
  created: timestamptz_comparison_exp
  email: citext_comparison_exp
  firstname: String_comparison_exp
  hfc_card_setting: hfc_card_settings_bool_exp
  hfc_user_setting: hfc_user_settings_bool_exp
  id: String_comparison_exp
  last_login: timestamptz_comparison_exp
  last_seen: timestamptz_comparison_exp
  lastname: String_comparison_exp
  licence_agreements: jsonb_comparison_exp
  local_instruments: local_instrument_bool_exp
  local_instruments_aggregate: local_instrument_aggregate_bool_exp
  login_count: Int_comparison_exp
  logout_requested_at: timestamptz_comparison_exp
  logout_requests: logout_request_bool_exp
  logout_requests_aggregate: logout_request_aggregate_bool_exp
  organisation: Int_comparison_exp
  organisationByOrganisation: organisation_bool_exp
  package: Int_comparison_exp
  page_setting: page_settings_bool_exp
  page_settings: page_settings_bool_exp
  page_settings_aggregate: page_settings_aggregate_bool_exp
  permissions: permission_bool_exp
  permissions_aggregate: permission_aggregate_bool_exp
  roles: jsonb_comparison_exp
  sessions: session_bool_exp
  sessions_aggregate: session_aggregate_bool_exp
  shared_instruments: shared_instrument_bool_exp
  shared_instruments_aggregate: shared_instrument_aggregate_bool_exp
  username: citext_comparison_exp
  userpackageByUser: package_bool_exp
}

"""
unique or primary key constraints on table "folio_user"
"""
enum folio_user_constraint {
  """
  unique or primary key constraint on columns "organisation", "email"
  """
  folio_user_email_organisation_key

  """
  unique or primary key constraint on columns "id"
  """
  folio_user_pkey

  """
  unique or primary key constraint on columns "username", "organisation"
  """
  folio_user_username_organisation_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input folio_user_delete_at_path_input {
  licence_agreements: [String!]
  roles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input folio_user_delete_elem_input {
  licence_agreements: Int
  roles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input folio_user_delete_key_input {
  licence_agreements: String
  roles: String
}

"""
input type for incrementing numeric columns in table "folio_user"
"""
input folio_user_inc_input {
  login_count: Int
  organisation: Int
  package: Int
}

"""
input type for inserting data into table "folio_user"
"""
input folio_user_insert_input {
  blocked: Boolean
  created: timestamptz
  email: citext
  firstname: String
  hfc_card_setting: hfc_card_settings_obj_rel_insert_input
  hfc_user_setting: hfc_user_settings_obj_rel_insert_input
  id: String
  last_login: timestamptz
  last_seen: timestamptz
  lastname: String
  licence_agreements: jsonb
  local_instruments: local_instrument_arr_rel_insert_input
  login_count: Int
  logout_requested_at: timestamptz
  logout_requests: logout_request_arr_rel_insert_input
  organisation: Int
  organisationByOrganisation: organisation_obj_rel_insert_input
  package: Int
  page_setting: page_settings_obj_rel_insert_input
  page_settings: page_settings_arr_rel_insert_input
  permissions: permission_arr_rel_insert_input
  roles: jsonb
  sessions: session_arr_rel_insert_input
  shared_instruments: shared_instrument_arr_rel_insert_input
  username: citext
  userpackageByUser: package_obj_rel_insert_input
}

"""aggregate max on columns"""
type folio_user_max_fields {
  created: timestamptz
  email: citext
  firstname: String
  id: String
  last_login: timestamptz
  last_seen: timestamptz
  lastname: String
  login_count: Int
  logout_requested_at: timestamptz
  organisation: Int
  package: Int
  username: citext
}

"""
order by max() on columns of table "folio_user"
"""
input folio_user_max_order_by {
  created: order_by
  email: order_by
  firstname: order_by
  id: order_by
  last_login: order_by
  last_seen: order_by
  lastname: order_by
  login_count: order_by
  logout_requested_at: order_by
  organisation: order_by
  package: order_by
  username: order_by
}

"""aggregate min on columns"""
type folio_user_min_fields {
  created: timestamptz
  email: citext
  firstname: String
  id: String
  last_login: timestamptz
  last_seen: timestamptz
  lastname: String
  login_count: Int
  logout_requested_at: timestamptz
  organisation: Int
  package: Int
  username: citext
}

"""
order by min() on columns of table "folio_user"
"""
input folio_user_min_order_by {
  created: order_by
  email: order_by
  firstname: order_by
  id: order_by
  last_login: order_by
  last_seen: order_by
  lastname: order_by
  login_count: order_by
  logout_requested_at: order_by
  organisation: order_by
  package: order_by
  username: order_by
}

"""
response of any mutation on the table "folio_user"
"""
type folio_user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [folio_user!]!
}

"""
input type for inserting object relation for remote table "folio_user"
"""
input folio_user_obj_rel_insert_input {
  data: folio_user_insert_input!

  """upsert condition"""
  on_conflict: folio_user_on_conflict
}

"""
on_conflict condition type for table "folio_user"
"""
input folio_user_on_conflict {
  constraint: folio_user_constraint!
  update_columns: [folio_user_update_column!]! = []
  where: folio_user_bool_exp
}

"""Ordering options when selecting data from "folio_user"."""
input folio_user_order_by {
  blocked: order_by
  created: order_by
  email: order_by
  firstname: order_by
  hfc_card_setting: hfc_card_settings_order_by
  hfc_user_setting: hfc_user_settings_order_by
  id: order_by
  last_login: order_by
  last_seen: order_by
  lastname: order_by
  licence_agreements: order_by
  local_instruments_aggregate: local_instrument_aggregate_order_by
  login_count: order_by
  logout_requested_at: order_by
  logout_requests_aggregate: logout_request_aggregate_order_by
  organisation: order_by
  organisationByOrganisation: organisation_order_by
  package: order_by
  page_setting: page_settings_order_by
  page_settings_aggregate: page_settings_aggregate_order_by
  permissions_aggregate: permission_aggregate_order_by
  roles: order_by
  sessions_aggregate: session_aggregate_order_by
  shared_instruments_aggregate: shared_instrument_aggregate_order_by
  username: order_by
  userpackageByUser: package_order_by
}

"""primary key columns input for table: folio_user"""
input folio_user_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input folio_user_prepend_input {
  licence_agreements: jsonb
  roles: jsonb
}

"""
select columns of table "folio_user"
"""
enum folio_user_select_column {
  """column name"""
  blocked

  """column name"""
  created

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  last_login

  """column name"""
  last_seen

  """column name"""
  lastname

  """column name"""
  licence_agreements

  """column name"""
  login_count

  """column name"""
  logout_requested_at

  """column name"""
  organisation

  """column name"""
  package

  """column name"""
  roles

  """column name"""
  username
}

"""
select "folio_user_aggregate_bool_exp_bool_and_arguments_columns" columns of table "folio_user"
"""
enum folio_user_select_column_folio_user_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  blocked
}

"""
select "folio_user_aggregate_bool_exp_bool_or_arguments_columns" columns of table "folio_user"
"""
enum folio_user_select_column_folio_user_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  blocked
}

"""
input type for updating data in table "folio_user"
"""
input folio_user_set_input {
  blocked: Boolean
  created: timestamptz
  email: citext
  firstname: String
  id: String
  last_login: timestamptz
  last_seen: timestamptz
  lastname: String
  licence_agreements: jsonb
  login_count: Int
  logout_requested_at: timestamptz
  organisation: Int
  package: Int
  roles: jsonb
  username: citext
}

"""aggregate stddev on columns"""
type folio_user_stddev_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by stddev() on columns of table "folio_user"
"""
input folio_user_stddev_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""aggregate stddev_pop on columns"""
type folio_user_stddev_pop_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by stddev_pop() on columns of table "folio_user"
"""
input folio_user_stddev_pop_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""aggregate stddev_samp on columns"""
type folio_user_stddev_samp_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by stddev_samp() on columns of table "folio_user"
"""
input folio_user_stddev_samp_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""
Streaming cursor of the table "folio_user"
"""
input folio_user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: folio_user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input folio_user_stream_cursor_value_input {
  blocked: Boolean
  created: timestamptz
  email: citext
  firstname: String
  id: String
  last_login: timestamptz
  last_seen: timestamptz
  lastname: String
  licence_agreements: jsonb
  login_count: Int
  logout_requested_at: timestamptz
  organisation: Int
  package: Int
  roles: jsonb
  username: citext
}

"""aggregate sum on columns"""
type folio_user_sum_fields {
  login_count: Int
  organisation: Int
  package: Int
}

"""
order by sum() on columns of table "folio_user"
"""
input folio_user_sum_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""
update columns of table "folio_user"
"""
enum folio_user_update_column {
  """column name"""
  blocked

  """column name"""
  created

  """column name"""
  email

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  last_login

  """column name"""
  last_seen

  """column name"""
  lastname

  """column name"""
  licence_agreements

  """column name"""
  login_count

  """column name"""
  logout_requested_at

  """column name"""
  organisation

  """column name"""
  package

  """column name"""
  roles

  """column name"""
  username
}

input folio_user_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: folio_user_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: folio_user_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: folio_user_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: folio_user_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: folio_user_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: folio_user_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: folio_user_set_input

  """filter the rows which have to be updated"""
  where: folio_user_bool_exp!
}

"""aggregate var_pop on columns"""
type folio_user_var_pop_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by var_pop() on columns of table "folio_user"
"""
input folio_user_var_pop_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""aggregate var_samp on columns"""
type folio_user_var_samp_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by var_samp() on columns of table "folio_user"
"""
input folio_user_var_samp_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""aggregate variance on columns"""
type folio_user_variance_fields {
  login_count: Float
  organisation: Float
  package: Float
}

"""
order by variance() on columns of table "folio_user"
"""
input folio_user_variance_order_by {
  login_count: order_by
  organisation: order_by
  package: order_by
}

"""
columns and relationships of "geographical_region"
"""
type geographical_region {
  id: Int!
  organisation: Int

  """An object relationship"""
  organisationByOrganisation: organisation

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String
}

"""
aggregated selection of "geographical_region"
"""
type geographical_region_aggregate {
  aggregate: geographical_region_aggregate_fields
  nodes: [geographical_region!]!
}

input geographical_region_aggregate_bool_exp {
  count: geographical_region_aggregate_bool_exp_count
}

input geographical_region_aggregate_bool_exp_count {
  arguments: [geographical_region_select_column!]
  distinct: Boolean
  filter: geographical_region_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "geographical_region"
"""
type geographical_region_aggregate_fields {
  avg: geographical_region_avg_fields
  count(columns: [geographical_region_select_column!], distinct: Boolean): Int!
  max: geographical_region_max_fields
  min: geographical_region_min_fields
  stddev: geographical_region_stddev_fields
  stddev_pop: geographical_region_stddev_pop_fields
  stddev_samp: geographical_region_stddev_samp_fields
  sum: geographical_region_sum_fields
  var_pop: geographical_region_var_pop_fields
  var_samp: geographical_region_var_samp_fields
  variance: geographical_region_variance_fields
}

"""
order by aggregate values of table "geographical_region"
"""
input geographical_region_aggregate_order_by {
  avg: geographical_region_avg_order_by
  count: order_by
  max: geographical_region_max_order_by
  min: geographical_region_min_order_by
  stddev: geographical_region_stddev_order_by
  stddev_pop: geographical_region_stddev_pop_order_by
  stddev_samp: geographical_region_stddev_samp_order_by
  sum: geographical_region_sum_order_by
  var_pop: geographical_region_var_pop_order_by
  var_samp: geographical_region_var_samp_order_by
  variance: geographical_region_variance_order_by
}

"""
input type for inserting array relation for remote table "geographical_region"
"""
input geographical_region_arr_rel_insert_input {
  data: [geographical_region_insert_input!]!

  """upsert condition"""
  on_conflict: geographical_region_on_conflict
}

"""aggregate avg on columns"""
type geographical_region_avg_fields {
  id: Float
  organisation: Float
}

"""
order by avg() on columns of table "geographical_region"
"""
input geographical_region_avg_order_by {
  id: order_by
  organisation: order_by
}

"""
Boolean expression to filter rows from the table "geographical_region". All fields are combined with a logical 'AND'.
"""
input geographical_region_bool_exp {
  _and: [geographical_region_bool_exp!]
  _not: geographical_region_bool_exp
  _or: [geographical_region_bool_exp!]
  id: Int_comparison_exp
  organisation: Int_comparison_exp
  organisationByOrganisation: organisation_bool_exp
  product_overrides: product_overrides_bool_exp
  product_overrides_aggregate: product_overrides_aggregate_bool_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "geographical_region"
"""
enum geographical_region_constraint {
  """
  unique or primary key constraint on columns "value", "organisation"
  """
  geographical_region_organisation_value_key

  """
  unique or primary key constraint on columns "id"
  """
  geographical_region_pkey
}

"""
input type for incrementing numeric columns in table "geographical_region"
"""
input geographical_region_inc_input {
  id: Int
  organisation: Int
}

"""
input type for inserting data into table "geographical_region"
"""
input geographical_region_insert_input {
  id: Int
  organisation: Int
  organisationByOrganisation: organisation_obj_rel_insert_input
  product_overrides: product_overrides_arr_rel_insert_input
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type geographical_region_max_fields {
  id: Int
  organisation: Int
  value: String
}

"""
order by max() on columns of table "geographical_region"
"""
input geographical_region_max_order_by {
  id: order_by
  organisation: order_by
  value: order_by
}

"""aggregate min on columns"""
type geographical_region_min_fields {
  id: Int
  organisation: Int
  value: String
}

"""
order by min() on columns of table "geographical_region"
"""
input geographical_region_min_order_by {
  id: order_by
  organisation: order_by
  value: order_by
}

"""
response of any mutation on the table "geographical_region"
"""
type geographical_region_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [geographical_region!]!
}

"""
input type for inserting object relation for remote table "geographical_region"
"""
input geographical_region_obj_rel_insert_input {
  data: geographical_region_insert_input!

  """upsert condition"""
  on_conflict: geographical_region_on_conflict
}

"""
on_conflict condition type for table "geographical_region"
"""
input geographical_region_on_conflict {
  constraint: geographical_region_constraint!
  update_columns: [geographical_region_update_column!]! = []
  where: geographical_region_bool_exp
}

"""Ordering options when selecting data from "geographical_region"."""
input geographical_region_order_by {
  id: order_by
  organisation: order_by
  organisationByOrganisation: organisation_order_by
  product_overrides_aggregate: product_overrides_aggregate_order_by
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: geographical_region"""
input geographical_region_pk_columns_input {
  id: Int!
}

"""
select columns of table "geographical_region"
"""
enum geographical_region_select_column {
  """column name"""
  id

  """column name"""
  organisation

  """column name"""
  value
}

"""
input type for updating data in table "geographical_region"
"""
input geographical_region_set_input {
  id: Int
  organisation: Int
  value: String
}

"""aggregate stddev on columns"""
type geographical_region_stddev_fields {
  id: Float
  organisation: Float
}

"""
order by stddev() on columns of table "geographical_region"
"""
input geographical_region_stddev_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate stddev_pop on columns"""
type geographical_region_stddev_pop_fields {
  id: Float
  organisation: Float
}

"""
order by stddev_pop() on columns of table "geographical_region"
"""
input geographical_region_stddev_pop_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate stddev_samp on columns"""
type geographical_region_stddev_samp_fields {
  id: Float
  organisation: Float
}

"""
order by stddev_samp() on columns of table "geographical_region"
"""
input geographical_region_stddev_samp_order_by {
  id: order_by
  organisation: order_by
}

"""
Streaming cursor of the table "geographical_region"
"""
input geographical_region_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: geographical_region_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input geographical_region_stream_cursor_value_input {
  id: Int
  organisation: Int
  value: String
}

"""aggregate sum on columns"""
type geographical_region_sum_fields {
  id: Int
  organisation: Int
}

"""
order by sum() on columns of table "geographical_region"
"""
input geographical_region_sum_order_by {
  id: order_by
  organisation: order_by
}

"""
update columns of table "geographical_region"
"""
enum geographical_region_update_column {
  """column name"""
  id

  """column name"""
  organisation

  """column name"""
  value
}

input geographical_region_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: geographical_region_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: geographical_region_set_input

  """filter the rows which have to be updated"""
  where: geographical_region_bool_exp!
}

"""aggregate var_pop on columns"""
type geographical_region_var_pop_fields {
  id: Float
  organisation: Float
}

"""
order by var_pop() on columns of table "geographical_region"
"""
input geographical_region_var_pop_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate var_samp on columns"""
type geographical_region_var_samp_fields {
  id: Float
  organisation: Float
}

"""
order by var_samp() on columns of table "geographical_region"
"""
input geographical_region_var_samp_order_by {
  id: order_by
  organisation: order_by
}

"""aggregate variance on columns"""
type geographical_region_variance_fields {
  id: Float
  organisation: Float
}

"""
order by variance() on columns of table "geographical_region"
"""
input geographical_region_variance_order_by {
  id: order_by
  organisation: order_by
}

"""
columns and relationships of "global_instrument"
"""
type global_instrument {
  edited_at: timestamptz!
  edited_by: String!

  """An object relationship"""
  globalProductByGlobalProduct: global_product!
  global_product: uuid!
  id: Int!
  month: date!
  shared_at: timestamptz!
  value: numeric
}

"""
aggregated selection of "global_instrument"
"""
type global_instrument_aggregate {
  aggregate: global_instrument_aggregate_fields
  nodes: [global_instrument!]!
}

input global_instrument_aggregate_bool_exp {
  count: global_instrument_aggregate_bool_exp_count
}

input global_instrument_aggregate_bool_exp_count {
  arguments: [global_instrument_select_column!]
  distinct: Boolean
  filter: global_instrument_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "global_instrument"
"""
type global_instrument_aggregate_fields {
  avg: global_instrument_avg_fields
  count(columns: [global_instrument_select_column!], distinct: Boolean): Int!
  max: global_instrument_max_fields
  min: global_instrument_min_fields
  stddev: global_instrument_stddev_fields
  stddev_pop: global_instrument_stddev_pop_fields
  stddev_samp: global_instrument_stddev_samp_fields
  sum: global_instrument_sum_fields
  var_pop: global_instrument_var_pop_fields
  var_samp: global_instrument_var_samp_fields
  variance: global_instrument_variance_fields
}

"""
order by aggregate values of table "global_instrument"
"""
input global_instrument_aggregate_order_by {
  avg: global_instrument_avg_order_by
  count: order_by
  max: global_instrument_max_order_by
  min: global_instrument_min_order_by
  stddev: global_instrument_stddev_order_by
  stddev_pop: global_instrument_stddev_pop_order_by
  stddev_samp: global_instrument_stddev_samp_order_by
  sum: global_instrument_sum_order_by
  var_pop: global_instrument_var_pop_order_by
  var_samp: global_instrument_var_samp_order_by
  variance: global_instrument_variance_order_by
}

"""
input type for inserting array relation for remote table "global_instrument"
"""
input global_instrument_arr_rel_insert_input {
  data: [global_instrument_insert_input!]!

  """upsert condition"""
  on_conflict: global_instrument_on_conflict
}

"""aggregate avg on columns"""
type global_instrument_avg_fields {
  id: Float
  value: Float
}

"""
order by avg() on columns of table "global_instrument"
"""
input global_instrument_avg_order_by {
  id: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "global_instrument". All fields are combined with a logical 'AND'.
"""
input global_instrument_bool_exp {
  _and: [global_instrument_bool_exp!]
  _not: global_instrument_bool_exp
  _or: [global_instrument_bool_exp!]
  edited_at: timestamptz_comparison_exp
  edited_by: String_comparison_exp
  globalProductByGlobalProduct: global_product_bool_exp
  global_product: uuid_comparison_exp
  id: Int_comparison_exp
  month: date_comparison_exp
  shared_at: timestamptz_comparison_exp
  value: numeric_comparison_exp
}

"""
unique or primary key constraints on table "global_instrument"
"""
enum global_instrument_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  global_instrument_id_key

  """
  unique or primary key constraint on columns "global_product", "month"
  """
  global_instrument_pkey
}

"""
input type for incrementing numeric columns in table "global_instrument"
"""
input global_instrument_inc_input {
  id: Int
  value: numeric
}

"""
input type for inserting data into table "global_instrument"
"""
input global_instrument_insert_input {
  edited_at: timestamptz
  edited_by: String
  globalProductByGlobalProduct: global_product_obj_rel_insert_input
  global_product: uuid
  id: Int
  month: date
  shared_at: timestamptz
  value: numeric
}

"""aggregate max on columns"""
type global_instrument_max_fields {
  edited_at: timestamptz
  edited_by: String
  global_product: uuid
  id: Int
  month: date
  shared_at: timestamptz
  value: numeric
}

"""
order by max() on columns of table "global_instrument"
"""
input global_instrument_max_order_by {
  edited_at: order_by
  edited_by: order_by
  global_product: order_by
  id: order_by
  month: order_by
  shared_at: order_by
  value: order_by
}

"""aggregate min on columns"""
type global_instrument_min_fields {
  edited_at: timestamptz
  edited_by: String
  global_product: uuid
  id: Int
  month: date
  shared_at: timestamptz
  value: numeric
}

"""
order by min() on columns of table "global_instrument"
"""
input global_instrument_min_order_by {
  edited_at: order_by
  edited_by: order_by
  global_product: order_by
  id: order_by
  month: order_by
  shared_at: order_by
  value: order_by
}

"""
response of any mutation on the table "global_instrument"
"""
type global_instrument_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [global_instrument!]!
}

"""
on_conflict condition type for table "global_instrument"
"""
input global_instrument_on_conflict {
  constraint: global_instrument_constraint!
  update_columns: [global_instrument_update_column!]! = []
  where: global_instrument_bool_exp
}

"""Ordering options when selecting data from "global_instrument"."""
input global_instrument_order_by {
  edited_at: order_by
  edited_by: order_by
  globalProductByGlobalProduct: global_product_order_by
  global_product: order_by
  id: order_by
  month: order_by
  shared_at: order_by
  value: order_by
}

"""primary key columns input for table: global_instrument"""
input global_instrument_pk_columns_input {
  global_product: uuid!
  month: date!
}

"""
select columns of table "global_instrument"
"""
enum global_instrument_select_column {
  """column name"""
  edited_at

  """column name"""
  edited_by

  """column name"""
  global_product

  """column name"""
  id

  """column name"""
  month

  """column name"""
  shared_at

  """column name"""
  value
}

"""
input type for updating data in table "global_instrument"
"""
input global_instrument_set_input {
  edited_at: timestamptz
  edited_by: String
  global_product: uuid
  id: Int
  month: date
  shared_at: timestamptz
  value: numeric
}

"""aggregate stddev on columns"""
type global_instrument_stddev_fields {
  id: Float
  value: Float
}

"""
order by stddev() on columns of table "global_instrument"
"""
input global_instrument_stddev_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type global_instrument_stddev_pop_fields {
  id: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "global_instrument"
"""
input global_instrument_stddev_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type global_instrument_stddev_samp_fields {
  id: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "global_instrument"
"""
input global_instrument_stddev_samp_order_by {
  id: order_by
  value: order_by
}

"""
Streaming cursor of the table "global_instrument"
"""
input global_instrument_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: global_instrument_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input global_instrument_stream_cursor_value_input {
  edited_at: timestamptz
  edited_by: String
  global_product: uuid
  id: Int
  month: date
  shared_at: timestamptz
  value: numeric
}

"""aggregate sum on columns"""
type global_instrument_sum_fields {
  id: Int
  value: numeric
}

"""
order by sum() on columns of table "global_instrument"
"""
input global_instrument_sum_order_by {
  id: order_by
  value: order_by
}

"""
update columns of table "global_instrument"
"""
enum global_instrument_update_column {
  """column name"""
  edited_at

  """column name"""
  edited_by

  """column name"""
  global_product

  """column name"""
  id

  """column name"""
  month

  """column name"""
  shared_at

  """column name"""
  value
}

input global_instrument_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: global_instrument_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: global_instrument_set_input

  """filter the rows which have to be updated"""
  where: global_instrument_bool_exp!
}

"""aggregate var_pop on columns"""
type global_instrument_var_pop_fields {
  id: Float
  value: Float
}

"""
order by var_pop() on columns of table "global_instrument"
"""
input global_instrument_var_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type global_instrument_var_samp_fields {
  id: Float
  value: Float
}

"""
order by var_samp() on columns of table "global_instrument"
"""
input global_instrument_var_samp_order_by {
  id: order_by
  value: order_by
}

"""aggregate variance on columns"""
type global_instrument_variance_fields {
  id: Float
  value: Float
}

"""
order by variance() on columns of table "global_instrument"
"""
input global_instrument_variance_order_by {
  id: order_by
  value: order_by
}

"""
columns and relationships of "global_package"
"""
type global_package {
  description: String

  """An array relationship"""
  global_permissions(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): [global_permission!]!

  """An aggregate relationship"""
  global_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): global_permission_aggregate!

  """An array relationship"""
  global_products(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): [global_product!]!

  """An aggregate relationship"""
  global_products_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): global_product_aggregate!
  id: Int!
  name: String!
  package_type: String
  source: Int

  """An object relationship"""
  sourceBySource: source
}

"""
aggregated selection of "global_package"
"""
type global_package_aggregate {
  aggregate: global_package_aggregate_fields
  nodes: [global_package!]!
}

"""
aggregate fields of "global_package"
"""
type global_package_aggregate_fields {
  avg: global_package_avg_fields
  count(columns: [global_package_select_column!], distinct: Boolean): Int!
  max: global_package_max_fields
  min: global_package_min_fields
  stddev: global_package_stddev_fields
  stddev_pop: global_package_stddev_pop_fields
  stddev_samp: global_package_stddev_samp_fields
  sum: global_package_sum_fields
  var_pop: global_package_var_pop_fields
  var_samp: global_package_var_samp_fields
  variance: global_package_variance_fields
}

"""aggregate avg on columns"""
type global_package_avg_fields {
  id: Float
  source: Float
}

"""
Boolean expression to filter rows from the table "global_package". All fields are combined with a logical 'AND'.
"""
input global_package_bool_exp {
  _and: [global_package_bool_exp!]
  _not: global_package_bool_exp
  _or: [global_package_bool_exp!]
  description: String_comparison_exp
  global_permissions: global_permission_bool_exp
  global_permissions_aggregate: global_permission_aggregate_bool_exp
  global_products: global_product_bool_exp
  global_products_aggregate: global_product_aggregate_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  package_type: String_comparison_exp
  source: Int_comparison_exp
  sourceBySource: source_bool_exp
}

"""
unique or primary key constraints on table "global_package"
"""
enum global_package_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  global_package_pkey
}

"""
input type for incrementing numeric columns in table "global_package"
"""
input global_package_inc_input {
  id: Int
  source: Int
}

"""
input type for inserting data into table "global_package"
"""
input global_package_insert_input {
  description: String
  global_permissions: global_permission_arr_rel_insert_input
  global_products: global_product_arr_rel_insert_input
  id: Int
  name: String
  package_type: String
  source: Int
  sourceBySource: source_obj_rel_insert_input
}

"""aggregate max on columns"""
type global_package_max_fields {
  description: String
  id: Int
  name: String
  package_type: String
  source: Int
}

"""aggregate min on columns"""
type global_package_min_fields {
  description: String
  id: Int
  name: String
  package_type: String
  source: Int
}

"""
response of any mutation on the table "global_package"
"""
type global_package_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [global_package!]!
}

"""
input type for inserting object relation for remote table "global_package"
"""
input global_package_obj_rel_insert_input {
  data: global_package_insert_input!

  """upsert condition"""
  on_conflict: global_package_on_conflict
}

"""
on_conflict condition type for table "global_package"
"""
input global_package_on_conflict {
  constraint: global_package_constraint!
  update_columns: [global_package_update_column!]! = []
  where: global_package_bool_exp
}

"""Ordering options when selecting data from "global_package"."""
input global_package_order_by {
  description: order_by
  global_permissions_aggregate: global_permission_aggregate_order_by
  global_products_aggregate: global_product_aggregate_order_by
  id: order_by
  name: order_by
  package_type: order_by
  source: order_by
  sourceBySource: source_order_by
}

"""primary key columns input for table: global_package"""
input global_package_pk_columns_input {
  id: Int!
}

"""
select columns of table "global_package"
"""
enum global_package_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  package_type

  """column name"""
  source
}

"""
input type for updating data in table "global_package"
"""
input global_package_set_input {
  description: String
  id: Int
  name: String
  package_type: String
  source: Int
}

"""aggregate stddev on columns"""
type global_package_stddev_fields {
  id: Float
  source: Float
}

"""aggregate stddev_pop on columns"""
type global_package_stddev_pop_fields {
  id: Float
  source: Float
}

"""aggregate stddev_samp on columns"""
type global_package_stddev_samp_fields {
  id: Float
  source: Float
}

"""
Streaming cursor of the table "global_package"
"""
input global_package_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: global_package_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input global_package_stream_cursor_value_input {
  description: String
  id: Int
  name: String
  package_type: String
  source: Int
}

"""aggregate sum on columns"""
type global_package_sum_fields {
  id: Int
  source: Int
}

"""
update columns of table "global_package"
"""
enum global_package_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  package_type

  """column name"""
  source
}

input global_package_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: global_package_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: global_package_set_input

  """filter the rows which have to be updated"""
  where: global_package_bool_exp!
}

"""aggregate var_pop on columns"""
type global_package_var_pop_fields {
  id: Float
  source: Float
}

"""aggregate var_samp on columns"""
type global_package_var_samp_fields {
  id: Float
  source: Float
}

"""aggregate variance on columns"""
type global_package_variance_fields {
  id: Float
  source: Float
}

"""
columns and relationships of "global_permission"
"""
type global_permission {
  folio_user: String!

  """An object relationship"""
  globalPackageByGlobalPackage: global_package!
  global_package: Int!
  id: Int!
  permission: user_right_enum!

  """An object relationship"""
  user_right: user_right!
}

"""
aggregated selection of "global_permission"
"""
type global_permission_aggregate {
  aggregate: global_permission_aggregate_fields
  nodes: [global_permission!]!
}

input global_permission_aggregate_bool_exp {
  count: global_permission_aggregate_bool_exp_count
}

input global_permission_aggregate_bool_exp_count {
  arguments: [global_permission_select_column!]
  distinct: Boolean
  filter: global_permission_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "global_permission"
"""
type global_permission_aggregate_fields {
  avg: global_permission_avg_fields
  count(columns: [global_permission_select_column!], distinct: Boolean): Int!
  max: global_permission_max_fields
  min: global_permission_min_fields
  stddev: global_permission_stddev_fields
  stddev_pop: global_permission_stddev_pop_fields
  stddev_samp: global_permission_stddev_samp_fields
  sum: global_permission_sum_fields
  var_pop: global_permission_var_pop_fields
  var_samp: global_permission_var_samp_fields
  variance: global_permission_variance_fields
}

"""
order by aggregate values of table "global_permission"
"""
input global_permission_aggregate_order_by {
  avg: global_permission_avg_order_by
  count: order_by
  max: global_permission_max_order_by
  min: global_permission_min_order_by
  stddev: global_permission_stddev_order_by
  stddev_pop: global_permission_stddev_pop_order_by
  stddev_samp: global_permission_stddev_samp_order_by
  sum: global_permission_sum_order_by
  var_pop: global_permission_var_pop_order_by
  var_samp: global_permission_var_samp_order_by
  variance: global_permission_variance_order_by
}

"""
input type for inserting array relation for remote table "global_permission"
"""
input global_permission_arr_rel_insert_input {
  data: [global_permission_insert_input!]!

  """upsert condition"""
  on_conflict: global_permission_on_conflict
}

"""aggregate avg on columns"""
type global_permission_avg_fields {
  global_package: Float
  id: Float
}

"""
order by avg() on columns of table "global_permission"
"""
input global_permission_avg_order_by {
  global_package: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "global_permission". All fields are combined with a logical 'AND'.
"""
input global_permission_bool_exp {
  _and: [global_permission_bool_exp!]
  _not: global_permission_bool_exp
  _or: [global_permission_bool_exp!]
  folio_user: String_comparison_exp
  globalPackageByGlobalPackage: global_package_bool_exp
  global_package: Int_comparison_exp
  id: Int_comparison_exp
  permission: user_right_enum_comparison_exp
  user_right: user_right_bool_exp
}

"""
unique or primary key constraints on table "global_permission"
"""
enum global_permission_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  global_permission_id_key

  """
  unique or primary key constraint on columns "folio_user", "global_package"
  """
  global_permission_pkey
}

"""
input type for incrementing numeric columns in table "global_permission"
"""
input global_permission_inc_input {
  global_package: Int
  id: Int
}

"""
input type for inserting data into table "global_permission"
"""
input global_permission_insert_input {
  folio_user: String
  globalPackageByGlobalPackage: global_package_obj_rel_insert_input
  global_package: Int
  id: Int
  permission: user_right_enum
  user_right: user_right_obj_rel_insert_input
}

"""aggregate max on columns"""
type global_permission_max_fields {
  folio_user: String
  global_package: Int
  id: Int
}

"""
order by max() on columns of table "global_permission"
"""
input global_permission_max_order_by {
  folio_user: order_by
  global_package: order_by
  id: order_by
}

"""aggregate min on columns"""
type global_permission_min_fields {
  folio_user: String
  global_package: Int
  id: Int
}

"""
order by min() on columns of table "global_permission"
"""
input global_permission_min_order_by {
  folio_user: order_by
  global_package: order_by
  id: order_by
}

"""
response of any mutation on the table "global_permission"
"""
type global_permission_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [global_permission!]!
}

"""
on_conflict condition type for table "global_permission"
"""
input global_permission_on_conflict {
  constraint: global_permission_constraint!
  update_columns: [global_permission_update_column!]! = []
  where: global_permission_bool_exp
}

"""Ordering options when selecting data from "global_permission"."""
input global_permission_order_by {
  folio_user: order_by
  globalPackageByGlobalPackage: global_package_order_by
  global_package: order_by
  id: order_by
  permission: order_by
  user_right: user_right_order_by
}

"""primary key columns input for table: global_permission"""
input global_permission_pk_columns_input {
  folio_user: String!
  global_package: Int!
}

"""
select columns of table "global_permission"
"""
enum global_permission_select_column {
  """column name"""
  folio_user

  """column name"""
  global_package

  """column name"""
  id

  """column name"""
  permission
}

"""
input type for updating data in table "global_permission"
"""
input global_permission_set_input {
  folio_user: String
  global_package: Int
  id: Int
  permission: user_right_enum
}

"""aggregate stddev on columns"""
type global_permission_stddev_fields {
  global_package: Float
  id: Float
}

"""
order by stddev() on columns of table "global_permission"
"""
input global_permission_stddev_order_by {
  global_package: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type global_permission_stddev_pop_fields {
  global_package: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "global_permission"
"""
input global_permission_stddev_pop_order_by {
  global_package: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type global_permission_stddev_samp_fields {
  global_package: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "global_permission"
"""
input global_permission_stddev_samp_order_by {
  global_package: order_by
  id: order_by
}

"""
Streaming cursor of the table "global_permission"
"""
input global_permission_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: global_permission_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input global_permission_stream_cursor_value_input {
  folio_user: String
  global_package: Int
  id: Int
  permission: user_right_enum
}

"""aggregate sum on columns"""
type global_permission_sum_fields {
  global_package: Int
  id: Int
}

"""
order by sum() on columns of table "global_permission"
"""
input global_permission_sum_order_by {
  global_package: order_by
  id: order_by
}

"""
update columns of table "global_permission"
"""
enum global_permission_update_column {
  """column name"""
  folio_user

  """column name"""
  global_package

  """column name"""
  id

  """column name"""
  permission
}

input global_permission_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: global_permission_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: global_permission_set_input

  """filter the rows which have to be updated"""
  where: global_permission_bool_exp!
}

"""aggregate var_pop on columns"""
type global_permission_var_pop_fields {
  global_package: Float
  id: Float
}

"""
order by var_pop() on columns of table "global_permission"
"""
input global_permission_var_pop_order_by {
  global_package: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type global_permission_var_samp_fields {
  global_package: Float
  id: Float
}

"""
order by var_samp() on columns of table "global_permission"
"""
input global_permission_var_samp_order_by {
  global_package: order_by
  id: order_by
}

"""aggregate variance on columns"""
type global_permission_variance_fields {
  global_package: Float
  id: Float
}

"""
order by variance() on columns of table "global_permission"
"""
input global_permission_variance_order_by {
  global_package: order_by
  id: order_by
}

"""
columns and relationships of "global_product"
"""
type global_product {
  """An object relationship"""
  commodityGroupByCommodityGroup: commodity_group
  commodity_group: Int
  description: String

  """An object relationship"""
  geographicalRegionByGeographicalRegion: geographical_region
  geographical_region: Int

  """An object relationship"""
  globalPackageByGlobalPackage: global_package!

  """An array relationship"""
  global_instruments(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): [global_instrument!]!

  """An aggregate relationship"""
  global_instruments_aggregate(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): global_instrument_aggregate!
  global_package: Int!

  """An array relationship"""
  global_product_configs(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): [global_product_config!]!

  """An aggregate relationship"""
  global_product_configs_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): global_product_config_aggregate!
  id: uuid!
  name: String!

  """An object relationship"""
  product_uom: product_uom!
  uom: product_uom_enum!
}

"""
aggregated selection of "global_product"
"""
type global_product_aggregate {
  aggregate: global_product_aggregate_fields
  nodes: [global_product!]!
}

input global_product_aggregate_bool_exp {
  count: global_product_aggregate_bool_exp_count
}

input global_product_aggregate_bool_exp_count {
  arguments: [global_product_select_column!]
  distinct: Boolean
  filter: global_product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "global_product"
"""
type global_product_aggregate_fields {
  avg: global_product_avg_fields
  count(columns: [global_product_select_column!], distinct: Boolean): Int!
  max: global_product_max_fields
  min: global_product_min_fields
  stddev: global_product_stddev_fields
  stddev_pop: global_product_stddev_pop_fields
  stddev_samp: global_product_stddev_samp_fields
  sum: global_product_sum_fields
  var_pop: global_product_var_pop_fields
  var_samp: global_product_var_samp_fields
  variance: global_product_variance_fields
}

"""
order by aggregate values of table "global_product"
"""
input global_product_aggregate_order_by {
  avg: global_product_avg_order_by
  count: order_by
  max: global_product_max_order_by
  min: global_product_min_order_by
  stddev: global_product_stddev_order_by
  stddev_pop: global_product_stddev_pop_order_by
  stddev_samp: global_product_stddev_samp_order_by
  sum: global_product_sum_order_by
  var_pop: global_product_var_pop_order_by
  var_samp: global_product_var_samp_order_by
  variance: global_product_variance_order_by
}

"""
input type for inserting array relation for remote table "global_product"
"""
input global_product_arr_rel_insert_input {
  data: [global_product_insert_input!]!

  """upsert condition"""
  on_conflict: global_product_on_conflict
}

"""aggregate avg on columns"""
type global_product_avg_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by avg() on columns of table "global_product"
"""
input global_product_avg_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""
Boolean expression to filter rows from the table "global_product". All fields are combined with a logical 'AND'.
"""
input global_product_bool_exp {
  _and: [global_product_bool_exp!]
  _not: global_product_bool_exp
  _or: [global_product_bool_exp!]
  commodityGroupByCommodityGroup: commodity_group_bool_exp
  commodity_group: Int_comparison_exp
  description: String_comparison_exp
  geographicalRegionByGeographicalRegion: geographical_region_bool_exp
  geographical_region: Int_comparison_exp
  globalPackageByGlobalPackage: global_package_bool_exp
  global_instruments: global_instrument_bool_exp
  global_instruments_aggregate: global_instrument_aggregate_bool_exp
  global_package: Int_comparison_exp
  global_product_configs: global_product_config_bool_exp
  global_product_configs_aggregate: global_product_config_aggregate_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  product_uom: product_uom_bool_exp
  uom: product_uom_enum_comparison_exp
}

"""Product configs for global configs"""
type global_product_config {
  created_at: timestamptz!
  formula: String

  """An object relationship"""
  global_product: global_product!
  id: Int!
  product: uuid!
  relative_month: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "global_product_config"
"""
type global_product_config_aggregate {
  aggregate: global_product_config_aggregate_fields
  nodes: [global_product_config!]!
}

input global_product_config_aggregate_bool_exp {
  count: global_product_config_aggregate_bool_exp_count
}

input global_product_config_aggregate_bool_exp_count {
  arguments: [global_product_config_select_column!]
  distinct: Boolean
  filter: global_product_config_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "global_product_config"
"""
type global_product_config_aggregate_fields {
  avg: global_product_config_avg_fields
  count(columns: [global_product_config_select_column!], distinct: Boolean): Int!
  max: global_product_config_max_fields
  min: global_product_config_min_fields
  stddev: global_product_config_stddev_fields
  stddev_pop: global_product_config_stddev_pop_fields
  stddev_samp: global_product_config_stddev_samp_fields
  sum: global_product_config_sum_fields
  var_pop: global_product_config_var_pop_fields
  var_samp: global_product_config_var_samp_fields
  variance: global_product_config_variance_fields
}

"""
order by aggregate values of table "global_product_config"
"""
input global_product_config_aggregate_order_by {
  avg: global_product_config_avg_order_by
  count: order_by
  max: global_product_config_max_order_by
  min: global_product_config_min_order_by
  stddev: global_product_config_stddev_order_by
  stddev_pop: global_product_config_stddev_pop_order_by
  stddev_samp: global_product_config_stddev_samp_order_by
  sum: global_product_config_sum_order_by
  var_pop: global_product_config_var_pop_order_by
  var_samp: global_product_config_var_samp_order_by
  variance: global_product_config_variance_order_by
}

"""
input type for inserting array relation for remote table "global_product_config"
"""
input global_product_config_arr_rel_insert_input {
  data: [global_product_config_insert_input!]!

  """upsert condition"""
  on_conflict: global_product_config_on_conflict
}

"""aggregate avg on columns"""
type global_product_config_avg_fields {
  id: Float
  relative_month: Float
}

"""
order by avg() on columns of table "global_product_config"
"""
input global_product_config_avg_order_by {
  id: order_by
  relative_month: order_by
}

"""
Boolean expression to filter rows from the table "global_product_config". All fields are combined with a logical 'AND'.
"""
input global_product_config_bool_exp {
  _and: [global_product_config_bool_exp!]
  _not: global_product_config_bool_exp
  _or: [global_product_config_bool_exp!]
  created_at: timestamptz_comparison_exp
  formula: String_comparison_exp
  global_product: global_product_bool_exp
  id: Int_comparison_exp
  product: uuid_comparison_exp
  relative_month: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "global_product_config"
"""
enum global_product_config_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  global_product_config_id_key

  """
  unique or primary key constraint on columns "product", "relative_month"
  """
  global_product_config_pkey
}

"""
input type for incrementing numeric columns in table "global_product_config"
"""
input global_product_config_inc_input {
  id: Int
  relative_month: Int
}

"""
input type for inserting data into table "global_product_config"
"""
input global_product_config_insert_input {
  created_at: timestamptz
  formula: String
  global_product: global_product_obj_rel_insert_input
  id: Int
  product: uuid
  relative_month: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type global_product_config_max_fields {
  created_at: timestamptz
  formula: String
  id: Int
  product: uuid
  relative_month: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "global_product_config"
"""
input global_product_config_max_order_by {
  created_at: order_by
  formula: order_by
  id: order_by
  product: order_by
  relative_month: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type global_product_config_min_fields {
  created_at: timestamptz
  formula: String
  id: Int
  product: uuid
  relative_month: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "global_product_config"
"""
input global_product_config_min_order_by {
  created_at: order_by
  formula: order_by
  id: order_by
  product: order_by
  relative_month: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "global_product_config"
"""
type global_product_config_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [global_product_config!]!
}

"""
on_conflict condition type for table "global_product_config"
"""
input global_product_config_on_conflict {
  constraint: global_product_config_constraint!
  update_columns: [global_product_config_update_column!]! = []
  where: global_product_config_bool_exp
}

"""Ordering options when selecting data from "global_product_config"."""
input global_product_config_order_by {
  created_at: order_by
  formula: order_by
  global_product: global_product_order_by
  id: order_by
  product: order_by
  relative_month: order_by
  updated_at: order_by
}

"""primary key columns input for table: global_product_config"""
input global_product_config_pk_columns_input {
  product: uuid!
  relative_month: Int!
}

"""
select columns of table "global_product_config"
"""
enum global_product_config_select_column {
  """column name"""
  created_at

  """column name"""
  formula

  """column name"""
  id

  """column name"""
  product

  """column name"""
  relative_month

  """column name"""
  updated_at
}

"""
input type for updating data in table "global_product_config"
"""
input global_product_config_set_input {
  created_at: timestamptz
  formula: String
  id: Int
  product: uuid
  relative_month: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type global_product_config_stddev_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev() on columns of table "global_product_config"
"""
input global_product_config_stddev_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate stddev_pop on columns"""
type global_product_config_stddev_pop_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev_pop() on columns of table "global_product_config"
"""
input global_product_config_stddev_pop_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate stddev_samp on columns"""
type global_product_config_stddev_samp_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev_samp() on columns of table "global_product_config"
"""
input global_product_config_stddev_samp_order_by {
  id: order_by
  relative_month: order_by
}

"""
Streaming cursor of the table "global_product_config"
"""
input global_product_config_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: global_product_config_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input global_product_config_stream_cursor_value_input {
  created_at: timestamptz
  formula: String
  id: Int
  product: uuid
  relative_month: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type global_product_config_sum_fields {
  id: Int
  relative_month: Int
}

"""
order by sum() on columns of table "global_product_config"
"""
input global_product_config_sum_order_by {
  id: order_by
  relative_month: order_by
}

"""
update columns of table "global_product_config"
"""
enum global_product_config_update_column {
  """column name"""
  created_at

  """column name"""
  formula

  """column name"""
  id

  """column name"""
  product

  """column name"""
  relative_month

  """column name"""
  updated_at
}

input global_product_config_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: global_product_config_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: global_product_config_set_input

  """filter the rows which have to be updated"""
  where: global_product_config_bool_exp!
}

"""aggregate var_pop on columns"""
type global_product_config_var_pop_fields {
  id: Float
  relative_month: Float
}

"""
order by var_pop() on columns of table "global_product_config"
"""
input global_product_config_var_pop_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate var_samp on columns"""
type global_product_config_var_samp_fields {
  id: Float
  relative_month: Float
}

"""
order by var_samp() on columns of table "global_product_config"
"""
input global_product_config_var_samp_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate variance on columns"""
type global_product_config_variance_fields {
  id: Float
  relative_month: Float
}

"""
order by variance() on columns of table "global_product_config"
"""
input global_product_config_variance_order_by {
  id: order_by
  relative_month: order_by
}

"""
unique or primary key constraints on table "global_product"
"""
enum global_product_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  global_product_pkey
}

"""
input type for incrementing numeric columns in table "global_product"
"""
input global_product_inc_input {
  commodity_group: Int
  geographical_region: Int
  global_package: Int
}

"""
input type for inserting data into table "global_product"
"""
input global_product_insert_input {
  commodityGroupByCommodityGroup: commodity_group_obj_rel_insert_input
  commodity_group: Int
  description: String
  geographicalRegionByGeographicalRegion: geographical_region_obj_rel_insert_input
  geographical_region: Int
  globalPackageByGlobalPackage: global_package_obj_rel_insert_input
  global_instruments: global_instrument_arr_rel_insert_input
  global_package: Int
  global_product_configs: global_product_config_arr_rel_insert_input
  id: uuid
  name: String
  product_uom: product_uom_obj_rel_insert_input
  uom: product_uom_enum
}

"""aggregate max on columns"""
type global_product_max_fields {
  commodity_group: Int
  description: String
  geographical_region: Int
  global_package: Int
  id: uuid
  name: String
}

"""
order by max() on columns of table "global_product"
"""
input global_product_max_order_by {
  commodity_group: order_by
  description: order_by
  geographical_region: order_by
  global_package: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type global_product_min_fields {
  commodity_group: Int
  description: String
  geographical_region: Int
  global_package: Int
  id: uuid
  name: String
}

"""
order by min() on columns of table "global_product"
"""
input global_product_min_order_by {
  commodity_group: order_by
  description: order_by
  geographical_region: order_by
  global_package: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "global_product"
"""
type global_product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [global_product!]!
}

"""
input type for inserting object relation for remote table "global_product"
"""
input global_product_obj_rel_insert_input {
  data: global_product_insert_input!

  """upsert condition"""
  on_conflict: global_product_on_conflict
}

"""
on_conflict condition type for table "global_product"
"""
input global_product_on_conflict {
  constraint: global_product_constraint!
  update_columns: [global_product_update_column!]! = []
  where: global_product_bool_exp
}

"""Ordering options when selecting data from "global_product"."""
input global_product_order_by {
  commodityGroupByCommodityGroup: commodity_group_order_by
  commodity_group: order_by
  description: order_by
  geographicalRegionByGeographicalRegion: geographical_region_order_by
  geographical_region: order_by
  globalPackageByGlobalPackage: global_package_order_by
  global_instruments_aggregate: global_instrument_aggregate_order_by
  global_package: order_by
  global_product_configs_aggregate: global_product_config_aggregate_order_by
  id: order_by
  name: order_by
  product_uom: product_uom_order_by
  uom: order_by
}

"""primary key columns input for table: global_product"""
input global_product_pk_columns_input {
  id: uuid!
}

"""
select columns of table "global_product"
"""
enum global_product_select_column {
  """column name"""
  commodity_group

  """column name"""
  description

  """column name"""
  geographical_region

  """column name"""
  global_package

  """column name"""
  id

  """column name"""
  name

  """column name"""
  uom
}

"""
input type for updating data in table "global_product"
"""
input global_product_set_input {
  commodity_group: Int
  description: String
  geographical_region: Int
  global_package: Int
  id: uuid
  name: String
  uom: product_uom_enum
}

"""aggregate stddev on columns"""
type global_product_stddev_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by stddev() on columns of table "global_product"
"""
input global_product_stddev_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""aggregate stddev_pop on columns"""
type global_product_stddev_pop_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by stddev_pop() on columns of table "global_product"
"""
input global_product_stddev_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""aggregate stddev_samp on columns"""
type global_product_stddev_samp_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by stddev_samp() on columns of table "global_product"
"""
input global_product_stddev_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""
Streaming cursor of the table "global_product"
"""
input global_product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: global_product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input global_product_stream_cursor_value_input {
  commodity_group: Int
  description: String
  geographical_region: Int
  global_package: Int
  id: uuid
  name: String
  uom: product_uom_enum
}

"""aggregate sum on columns"""
type global_product_sum_fields {
  commodity_group: Int
  geographical_region: Int
  global_package: Int
}

"""
order by sum() on columns of table "global_product"
"""
input global_product_sum_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""
update columns of table "global_product"
"""
enum global_product_update_column {
  """column name"""
  commodity_group

  """column name"""
  description

  """column name"""
  geographical_region

  """column name"""
  global_package

  """column name"""
  id

  """column name"""
  name

  """column name"""
  uom
}

input global_product_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: global_product_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: global_product_set_input

  """filter the rows which have to be updated"""
  where: global_product_bool_exp!
}

"""aggregate var_pop on columns"""
type global_product_var_pop_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by var_pop() on columns of table "global_product"
"""
input global_product_var_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""aggregate var_samp on columns"""
type global_product_var_samp_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by var_samp() on columns of table "global_product"
"""
input global_product_var_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""aggregate variance on columns"""
type global_product_variance_fields {
  commodity_group: Float
  geographical_region: Float
  global_package: Float
}

"""
order by variance() on columns of table "global_product"
"""
input global_product_variance_order_by {
  commodity_group: order_by
  geographical_region: order_by
  global_package: order_by
}

"""Saved card settings for each user"""
type hfc_card_settings {
  """An object relationship"""
  folio_user: folio_user!
  settings_blob: String
  user: String!
}

"""
aggregated selection of "hfc_card_settings"
"""
type hfc_card_settings_aggregate {
  aggregate: hfc_card_settings_aggregate_fields
  nodes: [hfc_card_settings!]!
}

"""
aggregate fields of "hfc_card_settings"
"""
type hfc_card_settings_aggregate_fields {
  count(columns: [hfc_card_settings_select_column!], distinct: Boolean): Int!
  max: hfc_card_settings_max_fields
  min: hfc_card_settings_min_fields
}

"""
Boolean expression to filter rows from the table "hfc_card_settings". All fields are combined with a logical 'AND'.
"""
input hfc_card_settings_bool_exp {
  _and: [hfc_card_settings_bool_exp!]
  _not: hfc_card_settings_bool_exp
  _or: [hfc_card_settings_bool_exp!]
  folio_user: folio_user_bool_exp
  settings_blob: String_comparison_exp
  user: String_comparison_exp
}

"""
unique or primary key constraints on table "hfc_card_settings"
"""
enum hfc_card_settings_constraint {
  """
  unique or primary key constraint on columns "user"
  """
  hfc_card_settings_pkey
}

"""
input type for inserting data into table "hfc_card_settings"
"""
input hfc_card_settings_insert_input {
  folio_user: folio_user_obj_rel_insert_input
  settings_blob: String
  user: String
}

"""aggregate max on columns"""
type hfc_card_settings_max_fields {
  settings_blob: String
  user: String
}

"""aggregate min on columns"""
type hfc_card_settings_min_fields {
  settings_blob: String
  user: String
}

"""
response of any mutation on the table "hfc_card_settings"
"""
type hfc_card_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hfc_card_settings!]!
}

"""
input type for inserting object relation for remote table "hfc_card_settings"
"""
input hfc_card_settings_obj_rel_insert_input {
  data: hfc_card_settings_insert_input!

  """upsert condition"""
  on_conflict: hfc_card_settings_on_conflict
}

"""
on_conflict condition type for table "hfc_card_settings"
"""
input hfc_card_settings_on_conflict {
  constraint: hfc_card_settings_constraint!
  update_columns: [hfc_card_settings_update_column!]! = []
  where: hfc_card_settings_bool_exp
}

"""Ordering options when selecting data from "hfc_card_settings"."""
input hfc_card_settings_order_by {
  folio_user: folio_user_order_by
  settings_blob: order_by
  user: order_by
}

"""primary key columns input for table: hfc_card_settings"""
input hfc_card_settings_pk_columns_input {
  user: String!
}

"""
select columns of table "hfc_card_settings"
"""
enum hfc_card_settings_select_column {
  """column name"""
  settings_blob

  """column name"""
  user
}

"""
input type for updating data in table "hfc_card_settings"
"""
input hfc_card_settings_set_input {
  settings_blob: String
  user: String
}

"""
Streaming cursor of the table "hfc_card_settings"
"""
input hfc_card_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: hfc_card_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input hfc_card_settings_stream_cursor_value_input {
  settings_blob: String
  user: String
}

"""
update columns of table "hfc_card_settings"
"""
enum hfc_card_settings_update_column {
  """column name"""
  settings_blob

  """column name"""
  user
}

input hfc_card_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: hfc_card_settings_set_input

  """filter the rows which have to be updated"""
  where: hfc_card_settings_bool_exp!
}

"""Track user settings. (i.e. colour scheme for years)"""
type hfc_user_settings {
  settings_blob: String
  user: String!
}

"""
aggregated selection of "hfc_user_settings"
"""
type hfc_user_settings_aggregate {
  aggregate: hfc_user_settings_aggregate_fields
  nodes: [hfc_user_settings!]!
}

"""
aggregate fields of "hfc_user_settings"
"""
type hfc_user_settings_aggregate_fields {
  count(columns: [hfc_user_settings_select_column!], distinct: Boolean): Int!
  max: hfc_user_settings_max_fields
  min: hfc_user_settings_min_fields
}

"""
Boolean expression to filter rows from the table "hfc_user_settings". All fields are combined with a logical 'AND'.
"""
input hfc_user_settings_bool_exp {
  _and: [hfc_user_settings_bool_exp!]
  _not: hfc_user_settings_bool_exp
  _or: [hfc_user_settings_bool_exp!]
  settings_blob: String_comparison_exp
  user: String_comparison_exp
}

"""
unique or primary key constraints on table "hfc_user_settings"
"""
enum hfc_user_settings_constraint {
  """
  unique or primary key constraint on columns "user"
  """
  hfc_user_settings_pkey
}

"""
input type for inserting data into table "hfc_user_settings"
"""
input hfc_user_settings_insert_input {
  settings_blob: String
  user: String
}

"""aggregate max on columns"""
type hfc_user_settings_max_fields {
  settings_blob: String
  user: String
}

"""aggregate min on columns"""
type hfc_user_settings_min_fields {
  settings_blob: String
  user: String
}

"""
response of any mutation on the table "hfc_user_settings"
"""
type hfc_user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [hfc_user_settings!]!
}

"""
input type for inserting object relation for remote table "hfc_user_settings"
"""
input hfc_user_settings_obj_rel_insert_input {
  data: hfc_user_settings_insert_input!

  """upsert condition"""
  on_conflict: hfc_user_settings_on_conflict
}

"""
on_conflict condition type for table "hfc_user_settings"
"""
input hfc_user_settings_on_conflict {
  constraint: hfc_user_settings_constraint!
  update_columns: [hfc_user_settings_update_column!]! = []
  where: hfc_user_settings_bool_exp
}

"""Ordering options when selecting data from "hfc_user_settings"."""
input hfc_user_settings_order_by {
  settings_blob: order_by
  user: order_by
}

"""primary key columns input for table: hfc_user_settings"""
input hfc_user_settings_pk_columns_input {
  user: String!
}

"""
select columns of table "hfc_user_settings"
"""
enum hfc_user_settings_select_column {
  """column name"""
  settings_blob

  """column name"""
  user
}

"""
input type for updating data in table "hfc_user_settings"
"""
input hfc_user_settings_set_input {
  settings_blob: String
  user: String
}

"""
Streaming cursor of the table "hfc_user_settings"
"""
input hfc_user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: hfc_user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input hfc_user_settings_stream_cursor_value_input {
  settings_blob: String
  user: String
}

"""
update columns of table "hfc_user_settings"
"""
enum hfc_user_settings_update_column {
  """column name"""
  settings_blob

  """column name"""
  user
}

input hfc_user_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: hfc_user_settings_set_input

  """filter the rows which have to be updated"""
  where: hfc_user_settings_bool_exp!
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "live_users_new"
"""
type live_users_new {
  folio_user: String
  id: String
  is_mobile: Boolean
  last_seen: timestamptz
  organisation: Int
}

"""
aggregated selection of "live_users_new"
"""
type live_users_new_aggregate {
  aggregate: live_users_new_aggregate_fields
  nodes: [live_users_new!]!
}

"""
aggregate fields of "live_users_new"
"""
type live_users_new_aggregate_fields {
  avg: live_users_new_avg_fields
  count(columns: [live_users_new_select_column!], distinct: Boolean): Int!
  max: live_users_new_max_fields
  min: live_users_new_min_fields
  stddev: live_users_new_stddev_fields
  stddev_pop: live_users_new_stddev_pop_fields
  stddev_samp: live_users_new_stddev_samp_fields
  sum: live_users_new_sum_fields
  var_pop: live_users_new_var_pop_fields
  var_samp: live_users_new_var_samp_fields
  variance: live_users_new_variance_fields
}

"""aggregate avg on columns"""
type live_users_new_avg_fields {
  organisation: Float
}

"""
Boolean expression to filter rows from the table "live_users_new". All fields are combined with a logical 'AND'.
"""
input live_users_new_bool_exp {
  _and: [live_users_new_bool_exp!]
  _not: live_users_new_bool_exp
  _or: [live_users_new_bool_exp!]
  folio_user: String_comparison_exp
  id: String_comparison_exp
  is_mobile: Boolean_comparison_exp
  last_seen: timestamptz_comparison_exp
  organisation: Int_comparison_exp
}

"""aggregate max on columns"""
type live_users_new_max_fields {
  folio_user: String
  id: String
  last_seen: timestamptz
  organisation: Int
}

"""aggregate min on columns"""
type live_users_new_min_fields {
  folio_user: String
  id: String
  last_seen: timestamptz
  organisation: Int
}

"""Ordering options when selecting data from "live_users_new"."""
input live_users_new_order_by {
  folio_user: order_by
  id: order_by
  is_mobile: order_by
  last_seen: order_by
  organisation: order_by
}

"""
select columns of table "live_users_new"
"""
enum live_users_new_select_column {
  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  is_mobile

  """column name"""
  last_seen

  """column name"""
  organisation
}

"""aggregate stddev on columns"""
type live_users_new_stddev_fields {
  organisation: Float
}

"""aggregate stddev_pop on columns"""
type live_users_new_stddev_pop_fields {
  organisation: Float
}

"""aggregate stddev_samp on columns"""
type live_users_new_stddev_samp_fields {
  organisation: Float
}

"""
Streaming cursor of the table "live_users_new"
"""
input live_users_new_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: live_users_new_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input live_users_new_stream_cursor_value_input {
  folio_user: String
  id: String
  is_mobile: Boolean
  last_seen: timestamptz
  organisation: Int
}

"""aggregate sum on columns"""
type live_users_new_sum_fields {
  organisation: Int
}

"""aggregate var_pop on columns"""
type live_users_new_var_pop_fields {
  organisation: Float
}

"""aggregate var_samp on columns"""
type live_users_new_var_samp_fields {
  organisation: Float
}

"""aggregate variance on columns"""
type live_users_new_variance_fields {
  organisation: Float
}

"""
columns and relationships of "local_instrument"
"""
type local_instrument {
  edited_at: timestamptz!

  """An object relationship"""
  folioUserByFolioUser: folio_user!
  folio_user: String!
  id: bigint!
  month: date!
  product: uuid!

  """An object relationship"""
  productByProduct: product!
  storage_type: user_storage_enum!
  value: numeric
}

"""
aggregated selection of "local_instrument"
"""
type local_instrument_aggregate {
  aggregate: local_instrument_aggregate_fields
  nodes: [local_instrument!]!
}

input local_instrument_aggregate_bool_exp {
  count: local_instrument_aggregate_bool_exp_count
}

input local_instrument_aggregate_bool_exp_count {
  arguments: [local_instrument_select_column!]
  distinct: Boolean
  filter: local_instrument_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "local_instrument"
"""
type local_instrument_aggregate_fields {
  avg: local_instrument_avg_fields
  count(columns: [local_instrument_select_column!], distinct: Boolean): Int!
  max: local_instrument_max_fields
  min: local_instrument_min_fields
  stddev: local_instrument_stddev_fields
  stddev_pop: local_instrument_stddev_pop_fields
  stddev_samp: local_instrument_stddev_samp_fields
  sum: local_instrument_sum_fields
  var_pop: local_instrument_var_pop_fields
  var_samp: local_instrument_var_samp_fields
  variance: local_instrument_variance_fields
}

"""
order by aggregate values of table "local_instrument"
"""
input local_instrument_aggregate_order_by {
  avg: local_instrument_avg_order_by
  count: order_by
  max: local_instrument_max_order_by
  min: local_instrument_min_order_by
  stddev: local_instrument_stddev_order_by
  stddev_pop: local_instrument_stddev_pop_order_by
  stddev_samp: local_instrument_stddev_samp_order_by
  sum: local_instrument_sum_order_by
  var_pop: local_instrument_var_pop_order_by
  var_samp: local_instrument_var_samp_order_by
  variance: local_instrument_variance_order_by
}

"""
input type for inserting array relation for remote table "local_instrument"
"""
input local_instrument_arr_rel_insert_input {
  data: [local_instrument_insert_input!]!

  """upsert condition"""
  on_conflict: local_instrument_on_conflict
}

"""aggregate avg on columns"""
type local_instrument_avg_fields {
  id: Float
  value: Float
}

"""
order by avg() on columns of table "local_instrument"
"""
input local_instrument_avg_order_by {
  id: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "local_instrument". All fields are combined with a logical 'AND'.
"""
input local_instrument_bool_exp {
  _and: [local_instrument_bool_exp!]
  _not: local_instrument_bool_exp
  _or: [local_instrument_bool_exp!]
  edited_at: timestamptz_comparison_exp
  folioUserByFolioUser: folio_user_bool_exp
  folio_user: String_comparison_exp
  id: bigint_comparison_exp
  month: date_comparison_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
  storage_type: user_storage_enum_comparison_exp
  value: numeric_comparison_exp
}

"""
unique or primary key constraints on table "local_instrument"
"""
enum local_instrument_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  local_instrument_id_key

  """
  unique or primary key constraint on columns "product", "folio_user", "storage_type", "month"
  """
  local_instrument_pkey
}

"""
input type for incrementing numeric columns in table "local_instrument"
"""
input local_instrument_inc_input {
  id: bigint
  value: numeric
}

"""
input type for inserting data into table "local_instrument"
"""
input local_instrument_insert_input {
  edited_at: timestamptz
  folioUserByFolioUser: folio_user_obj_rel_insert_input
  folio_user: String
  id: bigint
  month: date
  product: uuid
  productByProduct: product_obj_rel_insert_input
  storage_type: user_storage_enum
  value: numeric
}

"""aggregate max on columns"""
type local_instrument_max_fields {
  edited_at: timestamptz
  folio_user: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""
order by max() on columns of table "local_instrument"
"""
input local_instrument_max_order_by {
  edited_at: order_by
  folio_user: order_by
  id: order_by
  month: order_by
  product: order_by
  value: order_by
}

"""aggregate min on columns"""
type local_instrument_min_fields {
  edited_at: timestamptz
  folio_user: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""
order by min() on columns of table "local_instrument"
"""
input local_instrument_min_order_by {
  edited_at: order_by
  folio_user: order_by
  id: order_by
  month: order_by
  product: order_by
  value: order_by
}

"""
response of any mutation on the table "local_instrument"
"""
type local_instrument_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [local_instrument!]!
}

"""
on_conflict condition type for table "local_instrument"
"""
input local_instrument_on_conflict {
  constraint: local_instrument_constraint!
  update_columns: [local_instrument_update_column!]! = []
  where: local_instrument_bool_exp
}

"""Ordering options when selecting data from "local_instrument"."""
input local_instrument_order_by {
  edited_at: order_by
  folioUserByFolioUser: folio_user_order_by
  folio_user: order_by
  id: order_by
  month: order_by
  product: order_by
  productByProduct: product_order_by
  storage_type: order_by
  value: order_by
}

"""primary key columns input for table: local_instrument"""
input local_instrument_pk_columns_input {
  folio_user: String!
  month: date!
  product: uuid!
  storage_type: user_storage_enum!
}

"""
select columns of table "local_instrument"
"""
enum local_instrument_select_column {
  """column name"""
  edited_at

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  month

  """column name"""
  product

  """column name"""
  storage_type

  """column name"""
  value
}

"""
input type for updating data in table "local_instrument"
"""
input local_instrument_set_input {
  edited_at: timestamptz
  folio_user: String
  id: bigint
  month: date
  product: uuid
  storage_type: user_storage_enum
  value: numeric
}

"""aggregate stddev on columns"""
type local_instrument_stddev_fields {
  id: Float
  value: Float
}

"""
order by stddev() on columns of table "local_instrument"
"""
input local_instrument_stddev_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type local_instrument_stddev_pop_fields {
  id: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "local_instrument"
"""
input local_instrument_stddev_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type local_instrument_stddev_samp_fields {
  id: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "local_instrument"
"""
input local_instrument_stddev_samp_order_by {
  id: order_by
  value: order_by
}

"""
Streaming cursor of the table "local_instrument"
"""
input local_instrument_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: local_instrument_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input local_instrument_stream_cursor_value_input {
  edited_at: timestamptz
  folio_user: String
  id: bigint
  month: date
  product: uuid
  storage_type: user_storage_enum
  value: numeric
}

"""aggregate sum on columns"""
type local_instrument_sum_fields {
  id: bigint
  value: numeric
}

"""
order by sum() on columns of table "local_instrument"
"""
input local_instrument_sum_order_by {
  id: order_by
  value: order_by
}

"""
update columns of table "local_instrument"
"""
enum local_instrument_update_column {
  """column name"""
  edited_at

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  month

  """column name"""
  product

  """column name"""
  storage_type

  """column name"""
  value
}

input local_instrument_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: local_instrument_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: local_instrument_set_input

  """filter the rows which have to be updated"""
  where: local_instrument_bool_exp!
}

"""aggregate var_pop on columns"""
type local_instrument_var_pop_fields {
  id: Float
  value: Float
}

"""
order by var_pop() on columns of table "local_instrument"
"""
input local_instrument_var_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type local_instrument_var_samp_fields {
  id: Float
  value: Float
}

"""
order by var_samp() on columns of table "local_instrument"
"""
input local_instrument_var_samp_order_by {
  id: order_by
  value: order_by
}

"""aggregate variance on columns"""
type local_instrument_variance_fields {
  id: Float
  value: Float
}

"""
order by variance() on columns of table "local_instrument"
"""
input local_instrument_variance_order_by {
  id: order_by
  value: order_by
}

"""
columns and relationships of "logout_request"
"""
type logout_request {
  context: String
  folio_user: String!
  id: Int!

  """An object relationship"""
  logout_request_folio_user: folio_user!
  logout_requested_at: timestamptz!
}

"""
aggregated selection of "logout_request"
"""
type logout_request_aggregate {
  aggregate: logout_request_aggregate_fields
  nodes: [logout_request!]!
}

input logout_request_aggregate_bool_exp {
  count: logout_request_aggregate_bool_exp_count
}

input logout_request_aggregate_bool_exp_count {
  arguments: [logout_request_select_column!]
  distinct: Boolean
  filter: logout_request_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "logout_request"
"""
type logout_request_aggregate_fields {
  avg: logout_request_avg_fields
  count(columns: [logout_request_select_column!], distinct: Boolean): Int!
  max: logout_request_max_fields
  min: logout_request_min_fields
  stddev: logout_request_stddev_fields
  stddev_pop: logout_request_stddev_pop_fields
  stddev_samp: logout_request_stddev_samp_fields
  sum: logout_request_sum_fields
  var_pop: logout_request_var_pop_fields
  var_samp: logout_request_var_samp_fields
  variance: logout_request_variance_fields
}

"""
order by aggregate values of table "logout_request"
"""
input logout_request_aggregate_order_by {
  avg: logout_request_avg_order_by
  count: order_by
  max: logout_request_max_order_by
  min: logout_request_min_order_by
  stddev: logout_request_stddev_order_by
  stddev_pop: logout_request_stddev_pop_order_by
  stddev_samp: logout_request_stddev_samp_order_by
  sum: logout_request_sum_order_by
  var_pop: logout_request_var_pop_order_by
  var_samp: logout_request_var_samp_order_by
  variance: logout_request_variance_order_by
}

"""
input type for inserting array relation for remote table "logout_request"
"""
input logout_request_arr_rel_insert_input {
  data: [logout_request_insert_input!]!

  """upsert condition"""
  on_conflict: logout_request_on_conflict
}

"""aggregate avg on columns"""
type logout_request_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "logout_request"
"""
input logout_request_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "logout_request". All fields are combined with a logical 'AND'.
"""
input logout_request_bool_exp {
  _and: [logout_request_bool_exp!]
  _not: logout_request_bool_exp
  _or: [logout_request_bool_exp!]
  context: String_comparison_exp
  folio_user: String_comparison_exp
  id: Int_comparison_exp
  logout_request_folio_user: folio_user_bool_exp
  logout_requested_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "logout_request"
"""
enum logout_request_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  logout_request_pkey

  """
  unique or primary key constraint on columns "folio_user", "context"
  """
  logout_request_user_context_unique
}

"""
input type for incrementing numeric columns in table "logout_request"
"""
input logout_request_inc_input {
  id: Int
}

"""
input type for inserting data into table "logout_request"
"""
input logout_request_insert_input {
  context: String
  folio_user: String
  id: Int
  logout_request_folio_user: folio_user_obj_rel_insert_input
  logout_requested_at: timestamptz
}

"""aggregate max on columns"""
type logout_request_max_fields {
  context: String
  folio_user: String
  id: Int
  logout_requested_at: timestamptz
}

"""
order by max() on columns of table "logout_request"
"""
input logout_request_max_order_by {
  context: order_by
  folio_user: order_by
  id: order_by
  logout_requested_at: order_by
}

"""aggregate min on columns"""
type logout_request_min_fields {
  context: String
  folio_user: String
  id: Int
  logout_requested_at: timestamptz
}

"""
order by min() on columns of table "logout_request"
"""
input logout_request_min_order_by {
  context: order_by
  folio_user: order_by
  id: order_by
  logout_requested_at: order_by
}

"""
response of any mutation on the table "logout_request"
"""
type logout_request_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [logout_request!]!
}

"""
on_conflict condition type for table "logout_request"
"""
input logout_request_on_conflict {
  constraint: logout_request_constraint!
  update_columns: [logout_request_update_column!]! = []
  where: logout_request_bool_exp
}

"""Ordering options when selecting data from "logout_request"."""
input logout_request_order_by {
  context: order_by
  folio_user: order_by
  id: order_by
  logout_request_folio_user: folio_user_order_by
  logout_requested_at: order_by
}

"""primary key columns input for table: logout_request"""
input logout_request_pk_columns_input {
  id: Int!
}

"""
select columns of table "logout_request"
"""
enum logout_request_select_column {
  """column name"""
  context

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  logout_requested_at
}

"""
input type for updating data in table "logout_request"
"""
input logout_request_set_input {
  context: String
  folio_user: String
  id: Int
  logout_requested_at: timestamptz
}

"""aggregate stddev on columns"""
type logout_request_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "logout_request"
"""
input logout_request_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type logout_request_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "logout_request"
"""
input logout_request_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type logout_request_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "logout_request"
"""
input logout_request_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "logout_request"
"""
input logout_request_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: logout_request_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input logout_request_stream_cursor_value_input {
  context: String
  folio_user: String
  id: Int
  logout_requested_at: timestamptz
}

"""aggregate sum on columns"""
type logout_request_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "logout_request"
"""
input logout_request_sum_order_by {
  id: order_by
}

"""
update columns of table "logout_request"
"""
enum logout_request_update_column {
  """column name"""
  context

  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  logout_requested_at
}

input logout_request_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: logout_request_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: logout_request_set_input

  """filter the rows which have to be updated"""
  where: logout_request_bool_exp!
}

"""aggregate var_pop on columns"""
type logout_request_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "logout_request"
"""
input logout_request_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type logout_request_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "logout_request"
"""
input logout_request_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type logout_request_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "logout_request"
"""
input logout_request_variance_order_by {
  id: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "audit.logged_actions"
  """
  delete_audit_logged_actions(
    """filter the rows which have to be deleted"""
    where: audit_logged_actions_bool_exp!
  ): audit_logged_actions_mutation_response

  """
  delete single row from the table: "audit.logged_actions"
  """
  delete_audit_logged_actions_by_pk(
    """Unique identifier for each auditable event"""
    event_id: bigint!
  ): audit_logged_actions

  """
  delete data from the table: "audit.umi_actions"
  """
  delete_audit_umi_actions(
    """filter the rows which have to be deleted"""
    where: audit_umi_actions_bool_exp!
  ): audit_umi_actions_mutation_response

  """
  delete single row from the table: "audit.umi_actions"
  """
  delete_audit_umi_actions_by_pk(id: Int!): audit_umi_actions

  """
  delete data from the table: "commodity_group"
  """
  delete_commodity_group(
    """filter the rows which have to be deleted"""
    where: commodity_group_bool_exp!
  ): commodity_group_mutation_response

  """
  delete single row from the table: "commodity_group"
  """
  delete_commodity_group_by_pk(id: Int!): commodity_group

  """
  delete data from the table: "commodity_parent_group"
  """
  delete_commodity_parent_group(
    """filter the rows which have to be deleted"""
    where: commodity_parent_group_bool_exp!
  ): commodity_parent_group_mutation_response

  """
  delete single row from the table: "commodity_parent_group"
  """
  delete_commodity_parent_group_by_pk(id: Int!): commodity_parent_group

  """
  delete data from the table: "eod"
  """
  delete_eod(
    """filter the rows which have to be deleted"""
    where: eod_bool_exp!
  ): eod_mutation_response

  """
  delete single row from the table: "eod"
  """
  delete_eod_by_pk(id: Int!): eod

  """
  delete data from the table: "eod_entry"
  """
  delete_eod_entry(
    """filter the rows which have to be deleted"""
    where: eod_entry_bool_exp!
  ): eod_entry_mutation_response

  """
  delete single row from the table: "eod_entry"
  """
  delete_eod_entry_by_pk(evaluation_date: date!, month: date!, product: uuid!): eod_entry

  """
  delete data from the table: "exchange"
  """
  delete_exchange(
    """filter the rows which have to be deleted"""
    where: exchange_bool_exp!
  ): exchange_mutation_response

  """
  delete single row from the table: "exchange"
  """
  delete_exchange_by_pk(id: Int!): exchange

  """
  delete data from the table: "exchange_event_type"
  """
  delete_exchange_event_type(
    """filter the rows which have to be deleted"""
    where: exchange_event_type_bool_exp!
  ): exchange_event_type_mutation_response

  """
  delete single row from the table: "exchange_event_type"
  """
  delete_exchange_event_type_by_pk(value: String!): exchange_event_type

  """
  delete data from the table: "exchange_usage"
  """
  delete_exchange_usage(
    """filter the rows which have to be deleted"""
    where: exchange_usage_bool_exp!
  ): exchange_usage_mutation_response

  """
  delete single row from the table: "exchange_usage"
  """
  delete_exchange_usage_by_pk(id: Int!): exchange_usage

  """
  delete data from the table: "folio_column_settings"
  """
  delete_folio_column_settings(
    """filter the rows which have to be deleted"""
    where: folio_column_settings_bool_exp!
  ): folio_column_settings_mutation_response

  """
  delete single row from the table: "folio_column_settings"
  """
  delete_folio_column_settings_by_pk(folio_user: String!): folio_column_settings

  """
  delete data from the table: "folio_shadow_curves"
  """
  delete_folio_shadow_curves(
    """filter the rows which have to be deleted"""
    where: folio_shadow_curves_bool_exp!
  ): folio_shadow_curves_mutation_response

  """
  delete single row from the table: "folio_shadow_curves"
  """
  delete_folio_shadow_curves_by_pk(folio_user: String!): folio_shadow_curves

  """
  delete data from the table: "folio_user"
  """
  delete_folio_user(
    """filter the rows which have to be deleted"""
    where: folio_user_bool_exp!
  ): folio_user_mutation_response

  """
  delete data from the table: "folio_user_basic_profile"
  """
  delete_folio_user_basic_profile(
    """filter the rows which have to be deleted"""
    where: folio_user_basic_profile_bool_exp!
  ): folio_user_basic_profile_mutation_response

  """
  delete single row from the table: "folio_user"
  """
  delete_folio_user_by_pk(id: String!): folio_user

  """
  delete data from the table: "geographical_region"
  """
  delete_geographical_region(
    """filter the rows which have to be deleted"""
    where: geographical_region_bool_exp!
  ): geographical_region_mutation_response

  """
  delete single row from the table: "geographical_region"
  """
  delete_geographical_region_by_pk(id: Int!): geographical_region

  """
  delete data from the table: "global_instrument"
  """
  delete_global_instrument(
    """filter the rows which have to be deleted"""
    where: global_instrument_bool_exp!
  ): global_instrument_mutation_response

  """
  delete single row from the table: "global_instrument"
  """
  delete_global_instrument_by_pk(global_product: uuid!, month: date!): global_instrument

  """
  delete data from the table: "global_package"
  """
  delete_global_package(
    """filter the rows which have to be deleted"""
    where: global_package_bool_exp!
  ): global_package_mutation_response

  """
  delete single row from the table: "global_package"
  """
  delete_global_package_by_pk(id: Int!): global_package

  """
  delete data from the table: "global_permission"
  """
  delete_global_permission(
    """filter the rows which have to be deleted"""
    where: global_permission_bool_exp!
  ): global_permission_mutation_response

  """
  delete single row from the table: "global_permission"
  """
  delete_global_permission_by_pk(folio_user: String!, global_package: Int!): global_permission

  """
  delete data from the table: "global_product"
  """
  delete_global_product(
    """filter the rows which have to be deleted"""
    where: global_product_bool_exp!
  ): global_product_mutation_response

  """
  delete single row from the table: "global_product"
  """
  delete_global_product_by_pk(id: uuid!): global_product

  """
  delete data from the table: "global_product_config"
  """
  delete_global_product_config(
    """filter the rows which have to be deleted"""
    where: global_product_config_bool_exp!
  ): global_product_config_mutation_response

  """
  delete single row from the table: "global_product_config"
  """
  delete_global_product_config_by_pk(product: uuid!, relative_month: Int!): global_product_config

  """
  delete data from the table: "hfc_card_settings"
  """
  delete_hfc_card_settings(
    """filter the rows which have to be deleted"""
    where: hfc_card_settings_bool_exp!
  ): hfc_card_settings_mutation_response

  """
  delete single row from the table: "hfc_card_settings"
  """
  delete_hfc_card_settings_by_pk(user: String!): hfc_card_settings

  """
  delete data from the table: "hfc_user_settings"
  """
  delete_hfc_user_settings(
    """filter the rows which have to be deleted"""
    where: hfc_user_settings_bool_exp!
  ): hfc_user_settings_mutation_response

  """
  delete single row from the table: "hfc_user_settings"
  """
  delete_hfc_user_settings_by_pk(user: String!): hfc_user_settings

  """
  delete data from the table: "local_instrument"
  """
  delete_local_instrument(
    """filter the rows which have to be deleted"""
    where: local_instrument_bool_exp!
  ): local_instrument_mutation_response

  """
  delete single row from the table: "local_instrument"
  """
  delete_local_instrument_by_pk(folio_user: String!, month: date!, product: uuid!, storage_type: user_storage_enum!): local_instrument

  """
  delete data from the table: "logout_request"
  """
  delete_logout_request(
    """filter the rows which have to be deleted"""
    where: logout_request_bool_exp!
  ): logout_request_mutation_response

  """
  delete single row from the table: "logout_request"
  """
  delete_logout_request_by_pk(id: Int!): logout_request

  """
  delete data from the table: "organisation"
  """
  delete_organisation(
    """filter the rows which have to be deleted"""
    where: organisation_bool_exp!
  ): organisation_mutation_response

  """
  delete single row from the table: "organisation"
  """
  delete_organisation_by_pk(id: Int!): organisation

  """
  delete data from the table: "package"
  """
  delete_package(
    """filter the rows which have to be deleted"""
    where: package_bool_exp!
  ): package_mutation_response

  """
  delete single row from the table: "package"
  """
  delete_package_by_pk(id: Int!): package

  """
  delete data from the table: "package_type"
  """
  delete_package_type(
    """filter the rows which have to be deleted"""
    where: package_type_bool_exp!
  ): package_type_mutation_response

  """
  delete single row from the table: "package_type"
  """
  delete_package_type_by_pk(value: String!): package_type

  """
  delete data from the table: "page_settings"
  """
  delete_page_settings(
    """filter the rows which have to be deleted"""
    where: page_settings_bool_exp!
  ): page_settings_mutation_response

  """
  delete single row from the table: "page_settings"
  """
  delete_page_settings_by_pk(folio_user: String!): page_settings

  """
  delete data from the table: "permission"
  """
  delete_permission(
    """filter the rows which have to be deleted"""
    where: permission_bool_exp!
  ): permission_mutation_response

  """
  delete single row from the table: "permission"
  """
  delete_permission_by_pk(folio_user: String!, package: Int!): permission

  """
  delete data from the table: "product"
  """
  delete_product(
    """filter the rows which have to be deleted"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  delete data from the table: "product_artis_type"
  """
  delete_product_artis_type(
    """filter the rows which have to be deleted"""
    where: product_artis_type_bool_exp!
  ): product_artis_type_mutation_response

  """
  delete single row from the table: "product_artis_type"
  """
  delete_product_artis_type_by_pk(value: String!): product_artis_type

  """
  delete single row from the table: "product"
  """
  delete_product_by_pk(id: uuid!): product

  """
  delete data from the table: "product_config"
  """
  delete_product_config(
    """filter the rows which have to be deleted"""
    where: product_config_bool_exp!
  ): product_config_mutation_response

  """
  delete single row from the table: "product_config"
  """
  delete_product_config_by_pk(product: uuid!, relative_month: Int!): product_config

  """
  delete data from the table: "product_eod"
  """
  delete_product_eod(
    """filter the rows which have to be deleted"""
    where: product_eod_bool_exp!
  ): product_eod_mutation_response

  """
  delete single row from the table: "product_eod"
  """
  delete_product_eod_by_pk(eod_product: uuid!, product: uuid!): product_eod

  """
  delete data from the table: "product_global_dependencies"
  """
  delete_product_global_dependencies(
    """filter the rows which have to be deleted"""
    where: product_global_dependencies_bool_exp!
  ): product_global_dependencies_mutation_response

  """
  delete single row from the table: "product_global_dependencies"
  """
  delete_product_global_dependencies_by_pk(global_product: uuid!, product: uuid!): product_global_dependencies

  """
  delete data from the table: "product_maturity"
  """
  delete_product_maturity(
    """filter the rows which have to be deleted"""
    where: product_maturity_bool_exp!
  ): product_maturity_mutation_response

  """
  delete single row from the table: "product_maturity"
  """
  delete_product_maturity_by_pk(value: String!): product_maturity

  """
  delete data from the table: "product_overrides"
  """
  delete_product_overrides(
    """filter the rows which have to be deleted"""
    where: product_overrides_bool_exp!
  ): product_overrides_mutation_response

  """
  delete single row from the table: "product_overrides"
  """
  delete_product_overrides_by_pk(organisation: Int!, product: uuid!): product_overrides

  """
  delete data from the table: "product_source"
  """
  delete_product_source(
    """filter the rows which have to be deleted"""
    where: product_source_bool_exp!
  ): product_source_mutation_response

  """
  delete single row from the table: "product_source"
  """
  delete_product_source_by_pk(value: String!): product_source

  """
  delete data from the table: "product_summary_type"
  """
  delete_product_summary_type(
    """filter the rows which have to be deleted"""
    where: product_summary_type_bool_exp!
  ): product_summary_type_mutation_response

  """
  delete single row from the table: "product_summary_type"
  """
  delete_product_summary_type_by_pk(value: String!): product_summary_type

  """
  delete data from the table: "product_type"
  """
  delete_product_type(
    """filter the rows which have to be deleted"""
    where: product_type_bool_exp!
  ): product_type_mutation_response

  """
  delete single row from the table: "product_type"
  """
  delete_product_type_by_pk(value: String!): product_type

  """
  delete data from the table: "product_uom"
  """
  delete_product_uom(
    """filter the rows which have to be deleted"""
    where: product_uom_bool_exp!
  ): product_uom_mutation_response

  """
  delete single row from the table: "product_uom"
  """
  delete_product_uom_by_pk(value: String!): product_uom

  """
  delete data from the table: "session"
  """
  delete_session(
    """filter the rows which have to be deleted"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  delete single row from the table: "session"
  """
  delete_session_by_pk(folio_user: String!, is_mobile: Boolean!): session

  """
  delete data from the table: "session_type"
  """
  delete_session_type(
    """filter the rows which have to be deleted"""
    where: session_type_bool_exp!
  ): session_type_mutation_response

  """
  delete single row from the table: "session_type"
  """
  delete_session_type_by_pk(value: String!): session_type

  """
  delete data from the table: "shared_instrument"
  """
  delete_shared_instrument(
    """filter the rows which have to be deleted"""
    where: shared_instrument_bool_exp!
  ): shared_instrument_mutation_response

  """
  delete single row from the table: "shared_instrument"
  """
  delete_shared_instrument_by_pk(month: date!, product: uuid!): shared_instrument

  """
  delete data from the table: "sharing_agreement"
  """
  delete_sharing_agreement(
    """filter the rows which have to be deleted"""
    where: sharing_agreement_bool_exp!
  ): sharing_agreement_mutation_response

  """
  delete single row from the table: "sharing_agreement"
  """
  delete_sharing_agreement_by_pk(id: Int!): sharing_agreement

  """
  delete data from the table: "source"
  """
  delete_source(
    """filter the rows which have to be deleted"""
    where: source_bool_exp!
  ): source_mutation_response

  """
  delete single row from the table: "source"
  """
  delete_source_by_pk(id: Int!): source

  """
  delete data from the table: "user_right"
  """
  delete_user_right(
    """filter the rows which have to be deleted"""
    where: user_right_bool_exp!
  ): user_right_mutation_response

  """
  delete single row from the table: "user_right"
  """
  delete_user_right_by_pk(value: String!): user_right

  """
  delete data from the table: "user_storage"
  """
  delete_user_storage(
    """filter the rows which have to be deleted"""
    where: user_storage_bool_exp!
  ): user_storage_mutation_response

  """
  delete single row from the table: "user_storage"
  """
  delete_user_storage_by_pk(value: String!): user_storage

  """
  insert data into the table: "audit.logged_actions"
  """
  insert_audit_logged_actions(
    """the rows to be inserted"""
    objects: [audit_logged_actions_insert_input!]!

    """upsert condition"""
    on_conflict: audit_logged_actions_on_conflict
  ): audit_logged_actions_mutation_response

  """
  insert a single row into the table: "audit.logged_actions"
  """
  insert_audit_logged_actions_one(
    """the row to be inserted"""
    object: audit_logged_actions_insert_input!

    """upsert condition"""
    on_conflict: audit_logged_actions_on_conflict
  ): audit_logged_actions

  """
  insert data into the table: "audit.umi_actions"
  """
  insert_audit_umi_actions(
    """the rows to be inserted"""
    objects: [audit_umi_actions_insert_input!]!

    """upsert condition"""
    on_conflict: audit_umi_actions_on_conflict
  ): audit_umi_actions_mutation_response

  """
  insert a single row into the table: "audit.umi_actions"
  """
  insert_audit_umi_actions_one(
    """the row to be inserted"""
    object: audit_umi_actions_insert_input!

    """upsert condition"""
    on_conflict: audit_umi_actions_on_conflict
  ): audit_umi_actions

  """
  insert data into the table: "commodity_group"
  """
  insert_commodity_group(
    """the rows to be inserted"""
    objects: [commodity_group_insert_input!]!

    """upsert condition"""
    on_conflict: commodity_group_on_conflict
  ): commodity_group_mutation_response

  """
  insert a single row into the table: "commodity_group"
  """
  insert_commodity_group_one(
    """the row to be inserted"""
    object: commodity_group_insert_input!

    """upsert condition"""
    on_conflict: commodity_group_on_conflict
  ): commodity_group

  """
  insert data into the table: "commodity_parent_group"
  """
  insert_commodity_parent_group(
    """the rows to be inserted"""
    objects: [commodity_parent_group_insert_input!]!

    """upsert condition"""
    on_conflict: commodity_parent_group_on_conflict
  ): commodity_parent_group_mutation_response

  """
  insert a single row into the table: "commodity_parent_group"
  """
  insert_commodity_parent_group_one(
    """the row to be inserted"""
    object: commodity_parent_group_insert_input!

    """upsert condition"""
    on_conflict: commodity_parent_group_on_conflict
  ): commodity_parent_group

  """
  insert data into the table: "eod"
  """
  insert_eod(
    """the rows to be inserted"""
    objects: [eod_insert_input!]!

    """upsert condition"""
    on_conflict: eod_on_conflict
  ): eod_mutation_response

  """
  insert data into the table: "eod_entry"
  """
  insert_eod_entry(
    """the rows to be inserted"""
    objects: [eod_entry_insert_input!]!

    """upsert condition"""
    on_conflict: eod_entry_on_conflict
  ): eod_entry_mutation_response

  """
  insert a single row into the table: "eod_entry"
  """
  insert_eod_entry_one(
    """the row to be inserted"""
    object: eod_entry_insert_input!

    """upsert condition"""
    on_conflict: eod_entry_on_conflict
  ): eod_entry

  """
  insert a single row into the table: "eod"
  """
  insert_eod_one(
    """the row to be inserted"""
    object: eod_insert_input!

    """upsert condition"""
    on_conflict: eod_on_conflict
  ): eod

  """
  insert data into the table: "exchange"
  """
  insert_exchange(
    """the rows to be inserted"""
    objects: [exchange_insert_input!]!

    """upsert condition"""
    on_conflict: exchange_on_conflict
  ): exchange_mutation_response

  """
  insert data into the table: "exchange_event_type"
  """
  insert_exchange_event_type(
    """the rows to be inserted"""
    objects: [exchange_event_type_insert_input!]!

    """upsert condition"""
    on_conflict: exchange_event_type_on_conflict
  ): exchange_event_type_mutation_response

  """
  insert a single row into the table: "exchange_event_type"
  """
  insert_exchange_event_type_one(
    """the row to be inserted"""
    object: exchange_event_type_insert_input!

    """upsert condition"""
    on_conflict: exchange_event_type_on_conflict
  ): exchange_event_type

  """
  insert a single row into the table: "exchange"
  """
  insert_exchange_one(
    """the row to be inserted"""
    object: exchange_insert_input!

    """upsert condition"""
    on_conflict: exchange_on_conflict
  ): exchange

  """
  insert data into the table: "exchange_usage"
  """
  insert_exchange_usage(
    """the rows to be inserted"""
    objects: [exchange_usage_insert_input!]!

    """upsert condition"""
    on_conflict: exchange_usage_on_conflict
  ): exchange_usage_mutation_response

  """
  insert a single row into the table: "exchange_usage"
  """
  insert_exchange_usage_one(
    """the row to be inserted"""
    object: exchange_usage_insert_input!

    """upsert condition"""
    on_conflict: exchange_usage_on_conflict
  ): exchange_usage

  """
  insert data into the table: "folio_column_settings"
  """
  insert_folio_column_settings(
    """the rows to be inserted"""
    objects: [folio_column_settings_insert_input!]!

    """upsert condition"""
    on_conflict: folio_column_settings_on_conflict
  ): folio_column_settings_mutation_response

  """
  insert a single row into the table: "folio_column_settings"
  """
  insert_folio_column_settings_one(
    """the row to be inserted"""
    object: folio_column_settings_insert_input!

    """upsert condition"""
    on_conflict: folio_column_settings_on_conflict
  ): folio_column_settings

  """
  insert data into the table: "folio_shadow_curves"
  """
  insert_folio_shadow_curves(
    """the rows to be inserted"""
    objects: [folio_shadow_curves_insert_input!]!

    """upsert condition"""
    on_conflict: folio_shadow_curves_on_conflict
  ): folio_shadow_curves_mutation_response

  """
  insert a single row into the table: "folio_shadow_curves"
  """
  insert_folio_shadow_curves_one(
    """the row to be inserted"""
    object: folio_shadow_curves_insert_input!

    """upsert condition"""
    on_conflict: folio_shadow_curves_on_conflict
  ): folio_shadow_curves

  """
  insert data into the table: "folio_user"
  """
  insert_folio_user(
    """the rows to be inserted"""
    objects: [folio_user_insert_input!]!

    """upsert condition"""
    on_conflict: folio_user_on_conflict
  ): folio_user_mutation_response

  """
  insert data into the table: "folio_user_basic_profile"
  """
  insert_folio_user_basic_profile(
    """the rows to be inserted"""
    objects: [folio_user_basic_profile_insert_input!]!
  ): folio_user_basic_profile_mutation_response

  """
  insert a single row into the table: "folio_user_basic_profile"
  """
  insert_folio_user_basic_profile_one(
    """the row to be inserted"""
    object: folio_user_basic_profile_insert_input!
  ): folio_user_basic_profile

  """
  insert a single row into the table: "folio_user"
  """
  insert_folio_user_one(
    """the row to be inserted"""
    object: folio_user_insert_input!

    """upsert condition"""
    on_conflict: folio_user_on_conflict
  ): folio_user

  """
  insert data into the table: "geographical_region"
  """
  insert_geographical_region(
    """the rows to be inserted"""
    objects: [geographical_region_insert_input!]!

    """upsert condition"""
    on_conflict: geographical_region_on_conflict
  ): geographical_region_mutation_response

  """
  insert a single row into the table: "geographical_region"
  """
  insert_geographical_region_one(
    """the row to be inserted"""
    object: geographical_region_insert_input!

    """upsert condition"""
    on_conflict: geographical_region_on_conflict
  ): geographical_region

  """
  insert data into the table: "global_instrument"
  """
  insert_global_instrument(
    """the rows to be inserted"""
    objects: [global_instrument_insert_input!]!

    """upsert condition"""
    on_conflict: global_instrument_on_conflict
  ): global_instrument_mutation_response

  """
  insert a single row into the table: "global_instrument"
  """
  insert_global_instrument_one(
    """the row to be inserted"""
    object: global_instrument_insert_input!

    """upsert condition"""
    on_conflict: global_instrument_on_conflict
  ): global_instrument

  """
  insert data into the table: "global_package"
  """
  insert_global_package(
    """the rows to be inserted"""
    objects: [global_package_insert_input!]!

    """upsert condition"""
    on_conflict: global_package_on_conflict
  ): global_package_mutation_response

  """
  insert a single row into the table: "global_package"
  """
  insert_global_package_one(
    """the row to be inserted"""
    object: global_package_insert_input!

    """upsert condition"""
    on_conflict: global_package_on_conflict
  ): global_package

  """
  insert data into the table: "global_permission"
  """
  insert_global_permission(
    """the rows to be inserted"""
    objects: [global_permission_insert_input!]!

    """upsert condition"""
    on_conflict: global_permission_on_conflict
  ): global_permission_mutation_response

  """
  insert a single row into the table: "global_permission"
  """
  insert_global_permission_one(
    """the row to be inserted"""
    object: global_permission_insert_input!

    """upsert condition"""
    on_conflict: global_permission_on_conflict
  ): global_permission

  """
  insert data into the table: "global_product"
  """
  insert_global_product(
    """the rows to be inserted"""
    objects: [global_product_insert_input!]!

    """upsert condition"""
    on_conflict: global_product_on_conflict
  ): global_product_mutation_response

  """
  insert data into the table: "global_product_config"
  """
  insert_global_product_config(
    """the rows to be inserted"""
    objects: [global_product_config_insert_input!]!

    """upsert condition"""
    on_conflict: global_product_config_on_conflict
  ): global_product_config_mutation_response

  """
  insert a single row into the table: "global_product_config"
  """
  insert_global_product_config_one(
    """the row to be inserted"""
    object: global_product_config_insert_input!

    """upsert condition"""
    on_conflict: global_product_config_on_conflict
  ): global_product_config

  """
  insert a single row into the table: "global_product"
  """
  insert_global_product_one(
    """the row to be inserted"""
    object: global_product_insert_input!

    """upsert condition"""
    on_conflict: global_product_on_conflict
  ): global_product

  """
  insert data into the table: "hfc_card_settings"
  """
  insert_hfc_card_settings(
    """the rows to be inserted"""
    objects: [hfc_card_settings_insert_input!]!

    """upsert condition"""
    on_conflict: hfc_card_settings_on_conflict
  ): hfc_card_settings_mutation_response

  """
  insert a single row into the table: "hfc_card_settings"
  """
  insert_hfc_card_settings_one(
    """the row to be inserted"""
    object: hfc_card_settings_insert_input!

    """upsert condition"""
    on_conflict: hfc_card_settings_on_conflict
  ): hfc_card_settings

  """
  insert data into the table: "hfc_user_settings"
  """
  insert_hfc_user_settings(
    """the rows to be inserted"""
    objects: [hfc_user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: hfc_user_settings_on_conflict
  ): hfc_user_settings_mutation_response

  """
  insert a single row into the table: "hfc_user_settings"
  """
  insert_hfc_user_settings_one(
    """the row to be inserted"""
    object: hfc_user_settings_insert_input!

    """upsert condition"""
    on_conflict: hfc_user_settings_on_conflict
  ): hfc_user_settings

  """
  insert data into the table: "local_instrument"
  """
  insert_local_instrument(
    """the rows to be inserted"""
    objects: [local_instrument_insert_input!]!

    """upsert condition"""
    on_conflict: local_instrument_on_conflict
  ): local_instrument_mutation_response

  """
  insert a single row into the table: "local_instrument"
  """
  insert_local_instrument_one(
    """the row to be inserted"""
    object: local_instrument_insert_input!

    """upsert condition"""
    on_conflict: local_instrument_on_conflict
  ): local_instrument

  """
  insert data into the table: "logout_request"
  """
  insert_logout_request(
    """the rows to be inserted"""
    objects: [logout_request_insert_input!]!

    """upsert condition"""
    on_conflict: logout_request_on_conflict
  ): logout_request_mutation_response

  """
  insert a single row into the table: "logout_request"
  """
  insert_logout_request_one(
    """the row to be inserted"""
    object: logout_request_insert_input!

    """upsert condition"""
    on_conflict: logout_request_on_conflict
  ): logout_request

  """
  insert data into the table: "organisation"
  """
  insert_organisation(
    """the rows to be inserted"""
    objects: [organisation_insert_input!]!

    """upsert condition"""
    on_conflict: organisation_on_conflict
  ): organisation_mutation_response

  """
  insert a single row into the table: "organisation"
  """
  insert_organisation_one(
    """the row to be inserted"""
    object: organisation_insert_input!

    """upsert condition"""
    on_conflict: organisation_on_conflict
  ): organisation

  """
  insert data into the table: "package"
  """
  insert_package(
    """the rows to be inserted"""
    objects: [package_insert_input!]!

    """upsert condition"""
    on_conflict: package_on_conflict
  ): package_mutation_response

  """
  insert a single row into the table: "package"
  """
  insert_package_one(
    """the row to be inserted"""
    object: package_insert_input!

    """upsert condition"""
    on_conflict: package_on_conflict
  ): package

  """
  insert data into the table: "package_type"
  """
  insert_package_type(
    """the rows to be inserted"""
    objects: [package_type_insert_input!]!

    """upsert condition"""
    on_conflict: package_type_on_conflict
  ): package_type_mutation_response

  """
  insert a single row into the table: "package_type"
  """
  insert_package_type_one(
    """the row to be inserted"""
    object: package_type_insert_input!

    """upsert condition"""
    on_conflict: package_type_on_conflict
  ): package_type

  """
  insert data into the table: "page_settings"
  """
  insert_page_settings(
    """the rows to be inserted"""
    objects: [page_settings_insert_input!]!

    """upsert condition"""
    on_conflict: page_settings_on_conflict
  ): page_settings_mutation_response

  """
  insert a single row into the table: "page_settings"
  """
  insert_page_settings_one(
    """the row to be inserted"""
    object: page_settings_insert_input!

    """upsert condition"""
    on_conflict: page_settings_on_conflict
  ): page_settings

  """
  insert data into the table: "permission"
  """
  insert_permission(
    """the rows to be inserted"""
    objects: [permission_insert_input!]!

    """upsert condition"""
    on_conflict: permission_on_conflict
  ): permission_mutation_response

  """
  insert a single row into the table: "permission"
  """
  insert_permission_one(
    """the row to be inserted"""
    object: permission_insert_input!

    """upsert condition"""
    on_conflict: permission_on_conflict
  ): permission

  """
  insert data into the table: "product"
  """
  insert_product(
    """the rows to be inserted"""
    objects: [product_insert_input!]!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product_mutation_response

  """
  insert data into the table: "product_artis_type"
  """
  insert_product_artis_type(
    """the rows to be inserted"""
    objects: [product_artis_type_insert_input!]!

    """upsert condition"""
    on_conflict: product_artis_type_on_conflict
  ): product_artis_type_mutation_response

  """
  insert a single row into the table: "product_artis_type"
  """
  insert_product_artis_type_one(
    """the row to be inserted"""
    object: product_artis_type_insert_input!

    """upsert condition"""
    on_conflict: product_artis_type_on_conflict
  ): product_artis_type

  """
  insert data into the table: "product_config"
  """
  insert_product_config(
    """the rows to be inserted"""
    objects: [product_config_insert_input!]!

    """upsert condition"""
    on_conflict: product_config_on_conflict
  ): product_config_mutation_response

  """
  insert a single row into the table: "product_config"
  """
  insert_product_config_one(
    """the row to be inserted"""
    object: product_config_insert_input!

    """upsert condition"""
    on_conflict: product_config_on_conflict
  ): product_config

  """
  insert data into the table: "product_eod"
  """
  insert_product_eod(
    """the rows to be inserted"""
    objects: [product_eod_insert_input!]!

    """upsert condition"""
    on_conflict: product_eod_on_conflict
  ): product_eod_mutation_response

  """
  insert a single row into the table: "product_eod"
  """
  insert_product_eod_one(
    """the row to be inserted"""
    object: product_eod_insert_input!

    """upsert condition"""
    on_conflict: product_eod_on_conflict
  ): product_eod

  """
  insert data into the table: "product_global_dependencies"
  """
  insert_product_global_dependencies(
    """the rows to be inserted"""
    objects: [product_global_dependencies_insert_input!]!

    """upsert condition"""
    on_conflict: product_global_dependencies_on_conflict
  ): product_global_dependencies_mutation_response

  """
  insert a single row into the table: "product_global_dependencies"
  """
  insert_product_global_dependencies_one(
    """the row to be inserted"""
    object: product_global_dependencies_insert_input!

    """upsert condition"""
    on_conflict: product_global_dependencies_on_conflict
  ): product_global_dependencies

  """
  insert data into the table: "product_maturity"
  """
  insert_product_maturity(
    """the rows to be inserted"""
    objects: [product_maturity_insert_input!]!

    """upsert condition"""
    on_conflict: product_maturity_on_conflict
  ): product_maturity_mutation_response

  """
  insert a single row into the table: "product_maturity"
  """
  insert_product_maturity_one(
    """the row to be inserted"""
    object: product_maturity_insert_input!

    """upsert condition"""
    on_conflict: product_maturity_on_conflict
  ): product_maturity

  """
  insert a single row into the table: "product"
  """
  insert_product_one(
    """the row to be inserted"""
    object: product_insert_input!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product

  """
  insert data into the table: "product_overrides"
  """
  insert_product_overrides(
    """the rows to be inserted"""
    objects: [product_overrides_insert_input!]!

    """upsert condition"""
    on_conflict: product_overrides_on_conflict
  ): product_overrides_mutation_response

  """
  insert a single row into the table: "product_overrides"
  """
  insert_product_overrides_one(
    """the row to be inserted"""
    object: product_overrides_insert_input!

    """upsert condition"""
    on_conflict: product_overrides_on_conflict
  ): product_overrides

  """
  insert data into the table: "product_source"
  """
  insert_product_source(
    """the rows to be inserted"""
    objects: [product_source_insert_input!]!

    """upsert condition"""
    on_conflict: product_source_on_conflict
  ): product_source_mutation_response

  """
  insert a single row into the table: "product_source"
  """
  insert_product_source_one(
    """the row to be inserted"""
    object: product_source_insert_input!

    """upsert condition"""
    on_conflict: product_source_on_conflict
  ): product_source

  """
  insert data into the table: "product_summary_type"
  """
  insert_product_summary_type(
    """the rows to be inserted"""
    objects: [product_summary_type_insert_input!]!

    """upsert condition"""
    on_conflict: product_summary_type_on_conflict
  ): product_summary_type_mutation_response

  """
  insert a single row into the table: "product_summary_type"
  """
  insert_product_summary_type_one(
    """the row to be inserted"""
    object: product_summary_type_insert_input!

    """upsert condition"""
    on_conflict: product_summary_type_on_conflict
  ): product_summary_type

  """
  insert data into the table: "product_type"
  """
  insert_product_type(
    """the rows to be inserted"""
    objects: [product_type_insert_input!]!

    """upsert condition"""
    on_conflict: product_type_on_conflict
  ): product_type_mutation_response

  """
  insert a single row into the table: "product_type"
  """
  insert_product_type_one(
    """the row to be inserted"""
    object: product_type_insert_input!

    """upsert condition"""
    on_conflict: product_type_on_conflict
  ): product_type

  """
  insert data into the table: "product_uom"
  """
  insert_product_uom(
    """the rows to be inserted"""
    objects: [product_uom_insert_input!]!

    """upsert condition"""
    on_conflict: product_uom_on_conflict
  ): product_uom_mutation_response

  """
  insert a single row into the table: "product_uom"
  """
  insert_product_uom_one(
    """the row to be inserted"""
    object: product_uom_insert_input!

    """upsert condition"""
    on_conflict: product_uom_on_conflict
  ): product_uom

  """
  insert data into the table: "session"
  """
  insert_session(
    """the rows to be inserted"""
    objects: [session_insert_input!]!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session_mutation_response

  """
  insert a single row into the table: "session"
  """
  insert_session_one(
    """the row to be inserted"""
    object: session_insert_input!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session

  """
  insert data into the table: "session_type"
  """
  insert_session_type(
    """the rows to be inserted"""
    objects: [session_type_insert_input!]!

    """upsert condition"""
    on_conflict: session_type_on_conflict
  ): session_type_mutation_response

  """
  insert a single row into the table: "session_type"
  """
  insert_session_type_one(
    """the row to be inserted"""
    object: session_type_insert_input!

    """upsert condition"""
    on_conflict: session_type_on_conflict
  ): session_type

  """
  insert data into the table: "shared_instrument"
  """
  insert_shared_instrument(
    """the rows to be inserted"""
    objects: [shared_instrument_insert_input!]!

    """upsert condition"""
    on_conflict: shared_instrument_on_conflict
  ): shared_instrument_mutation_response

  """
  insert a single row into the table: "shared_instrument"
  """
  insert_shared_instrument_one(
    """the row to be inserted"""
    object: shared_instrument_insert_input!

    """upsert condition"""
    on_conflict: shared_instrument_on_conflict
  ): shared_instrument

  """
  insert data into the table: "sharing_agreement"
  """
  insert_sharing_agreement(
    """the rows to be inserted"""
    objects: [sharing_agreement_insert_input!]!

    """upsert condition"""
    on_conflict: sharing_agreement_on_conflict
  ): sharing_agreement_mutation_response

  """
  insert a single row into the table: "sharing_agreement"
  """
  insert_sharing_agreement_one(
    """the row to be inserted"""
    object: sharing_agreement_insert_input!

    """upsert condition"""
    on_conflict: sharing_agreement_on_conflict
  ): sharing_agreement

  """
  insert data into the table: "source"
  """
  insert_source(
    """the rows to be inserted"""
    objects: [source_insert_input!]!

    """upsert condition"""
    on_conflict: source_on_conflict
  ): source_mutation_response

  """
  insert a single row into the table: "source"
  """
  insert_source_one(
    """the row to be inserted"""
    object: source_insert_input!

    """upsert condition"""
    on_conflict: source_on_conflict
  ): source

  """
  insert data into the table: "user_right"
  """
  insert_user_right(
    """the rows to be inserted"""
    objects: [user_right_insert_input!]!

    """upsert condition"""
    on_conflict: user_right_on_conflict
  ): user_right_mutation_response

  """
  insert a single row into the table: "user_right"
  """
  insert_user_right_one(
    """the row to be inserted"""
    object: user_right_insert_input!

    """upsert condition"""
    on_conflict: user_right_on_conflict
  ): user_right

  """
  insert data into the table: "user_storage"
  """
  insert_user_storage(
    """the rows to be inserted"""
    objects: [user_storage_insert_input!]!

    """upsert condition"""
    on_conflict: user_storage_on_conflict
  ): user_storage_mutation_response

  """
  insert a single row into the table: "user_storage"
  """
  insert_user_storage_one(
    """the row to be inserted"""
    object: user_storage_insert_input!

    """upsert condition"""
    on_conflict: user_storage_on_conflict
  ): user_storage

  """
  update data of the table: "audit.logged_actions"
  """
  update_audit_logged_actions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_logged_actions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_logged_actions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_logged_actions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_logged_actions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: audit_logged_actions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_logged_actions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_logged_actions_set_input

    """filter the rows which have to be updated"""
    where: audit_logged_actions_bool_exp!
  ): audit_logged_actions_mutation_response

  """
  update single row of the table: "audit.logged_actions"
  """
  update_audit_logged_actions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_logged_actions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_logged_actions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_logged_actions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_logged_actions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: audit_logged_actions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_logged_actions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_logged_actions_set_input
    pk_columns: audit_logged_actions_pk_columns_input!
  ): audit_logged_actions

  """
  update multiples rows of table: "audit.logged_actions"
  """
  update_audit_logged_actions_many(
    """updates to execute, in order"""
    updates: [audit_logged_actions_updates!]!
  ): [audit_logged_actions_mutation_response]

  """
  update data of the table: "audit.umi_actions"
  """
  update_audit_umi_actions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_umi_actions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_umi_actions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_umi_actions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_umi_actions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: audit_umi_actions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_umi_actions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_umi_actions_set_input

    """filter the rows which have to be updated"""
    where: audit_umi_actions_bool_exp!
  ): audit_umi_actions_mutation_response

  """
  update single row of the table: "audit.umi_actions"
  """
  update_audit_umi_actions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: audit_umi_actions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_umi_actions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_umi_actions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_umi_actions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: audit_umi_actions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: audit_umi_actions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: audit_umi_actions_set_input
    pk_columns: audit_umi_actions_pk_columns_input!
  ): audit_umi_actions

  """
  update multiples rows of table: "audit.umi_actions"
  """
  update_audit_umi_actions_many(
    """updates to execute, in order"""
    updates: [audit_umi_actions_updates!]!
  ): [audit_umi_actions_mutation_response]

  """
  update data of the table: "commodity_group"
  """
  update_commodity_group(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commodity_group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commodity_group_set_input

    """filter the rows which have to be updated"""
    where: commodity_group_bool_exp!
  ): commodity_group_mutation_response

  """
  update single row of the table: "commodity_group"
  """
  update_commodity_group_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commodity_group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commodity_group_set_input
    pk_columns: commodity_group_pk_columns_input!
  ): commodity_group

  """
  update multiples rows of table: "commodity_group"
  """
  update_commodity_group_many(
    """updates to execute, in order"""
    updates: [commodity_group_updates!]!
  ): [commodity_group_mutation_response]

  """
  update data of the table: "commodity_parent_group"
  """
  update_commodity_parent_group(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commodity_parent_group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commodity_parent_group_set_input

    """filter the rows which have to be updated"""
    where: commodity_parent_group_bool_exp!
  ): commodity_parent_group_mutation_response

  """
  update single row of the table: "commodity_parent_group"
  """
  update_commodity_parent_group_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: commodity_parent_group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: commodity_parent_group_set_input
    pk_columns: commodity_parent_group_pk_columns_input!
  ): commodity_parent_group

  """
  update multiples rows of table: "commodity_parent_group"
  """
  update_commodity_parent_group_many(
    """updates to execute, in order"""
    updates: [commodity_parent_group_updates!]!
  ): [commodity_parent_group_mutation_response]

  """
  update data of the table: "eod"
  """
  update_eod(
    """increments the numeric columns with given value of the filtered values"""
    _inc: eod_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: eod_set_input

    """filter the rows which have to be updated"""
    where: eod_bool_exp!
  ): eod_mutation_response

  """
  update single row of the table: "eod"
  """
  update_eod_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: eod_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: eod_set_input
    pk_columns: eod_pk_columns_input!
  ): eod

  """
  update data of the table: "eod_entry"
  """
  update_eod_entry(
    """increments the numeric columns with given value of the filtered values"""
    _inc: eod_entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: eod_entry_set_input

    """filter the rows which have to be updated"""
    where: eod_entry_bool_exp!
  ): eod_entry_mutation_response

  """
  update single row of the table: "eod_entry"
  """
  update_eod_entry_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: eod_entry_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: eod_entry_set_input
    pk_columns: eod_entry_pk_columns_input!
  ): eod_entry

  """
  update multiples rows of table: "eod_entry"
  """
  update_eod_entry_many(
    """updates to execute, in order"""
    updates: [eod_entry_updates!]!
  ): [eod_entry_mutation_response]

  """
  update multiples rows of table: "eod"
  """
  update_eod_many(
    """updates to execute, in order"""
    updates: [eod_updates!]!
  ): [eod_mutation_response]

  """
  update data of the table: "exchange"
  """
  update_exchange(
    """increments the numeric columns with given value of the filtered values"""
    _inc: exchange_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: exchange_set_input

    """filter the rows which have to be updated"""
    where: exchange_bool_exp!
  ): exchange_mutation_response

  """
  update single row of the table: "exchange"
  """
  update_exchange_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: exchange_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: exchange_set_input
    pk_columns: exchange_pk_columns_input!
  ): exchange

  """
  update data of the table: "exchange_event_type"
  """
  update_exchange_event_type(
    """sets the columns of the filtered rows to the given values"""
    _set: exchange_event_type_set_input

    """filter the rows which have to be updated"""
    where: exchange_event_type_bool_exp!
  ): exchange_event_type_mutation_response

  """
  update single row of the table: "exchange_event_type"
  """
  update_exchange_event_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: exchange_event_type_set_input
    pk_columns: exchange_event_type_pk_columns_input!
  ): exchange_event_type

  """
  update multiples rows of table: "exchange_event_type"
  """
  update_exchange_event_type_many(
    """updates to execute, in order"""
    updates: [exchange_event_type_updates!]!
  ): [exchange_event_type_mutation_response]

  """
  update multiples rows of table: "exchange"
  """
  update_exchange_many(
    """updates to execute, in order"""
    updates: [exchange_updates!]!
  ): [exchange_mutation_response]

  """
  update data of the table: "exchange_usage"
  """
  update_exchange_usage(
    """increments the numeric columns with given value of the filtered values"""
    _inc: exchange_usage_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: exchange_usage_set_input

    """filter the rows which have to be updated"""
    where: exchange_usage_bool_exp!
  ): exchange_usage_mutation_response

  """
  update single row of the table: "exchange_usage"
  """
  update_exchange_usage_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: exchange_usage_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: exchange_usage_set_input
    pk_columns: exchange_usage_pk_columns_input!
  ): exchange_usage

  """
  update multiples rows of table: "exchange_usage"
  """
  update_exchange_usage_many(
    """updates to execute, in order"""
    updates: [exchange_usage_updates!]!
  ): [exchange_usage_mutation_response]

  """
  update data of the table: "folio_column_settings"
  """
  update_folio_column_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_column_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_column_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_column_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_column_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_column_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_column_settings_set_input

    """filter the rows which have to be updated"""
    where: folio_column_settings_bool_exp!
  ): folio_column_settings_mutation_response

  """
  update single row of the table: "folio_column_settings"
  """
  update_folio_column_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_column_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_column_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_column_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_column_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_column_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_column_settings_set_input
    pk_columns: folio_column_settings_pk_columns_input!
  ): folio_column_settings

  """
  update multiples rows of table: "folio_column_settings"
  """
  update_folio_column_settings_many(
    """updates to execute, in order"""
    updates: [folio_column_settings_updates!]!
  ): [folio_column_settings_mutation_response]

  """
  update data of the table: "folio_shadow_curves"
  """
  update_folio_shadow_curves(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_shadow_curves_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_shadow_curves_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_shadow_curves_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_shadow_curves_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_shadow_curves_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_shadow_curves_set_input

    """filter the rows which have to be updated"""
    where: folio_shadow_curves_bool_exp!
  ): folio_shadow_curves_mutation_response

  """
  update single row of the table: "folio_shadow_curves"
  """
  update_folio_shadow_curves_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_shadow_curves_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_shadow_curves_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_shadow_curves_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_shadow_curves_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_shadow_curves_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_shadow_curves_set_input
    pk_columns: folio_shadow_curves_pk_columns_input!
  ): folio_shadow_curves

  """
  update multiples rows of table: "folio_shadow_curves"
  """
  update_folio_shadow_curves_many(
    """updates to execute, in order"""
    updates: [folio_shadow_curves_updates!]!
  ): [folio_shadow_curves_mutation_response]

  """
  update data of the table: "folio_user"
  """
  update_folio_user(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_user_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_user_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_user_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_user_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: folio_user_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_user_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_user_set_input

    """filter the rows which have to be updated"""
    where: folio_user_bool_exp!
  ): folio_user_mutation_response

  """
  update data of the table: "folio_user_basic_profile"
  """
  update_folio_user_basic_profile(
    """increments the numeric columns with given value of the filtered values"""
    _inc: folio_user_basic_profile_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_user_basic_profile_set_input

    """filter the rows which have to be updated"""
    where: folio_user_basic_profile_bool_exp!
  ): folio_user_basic_profile_mutation_response

  """
  update multiples rows of table: "folio_user_basic_profile"
  """
  update_folio_user_basic_profile_many(
    """updates to execute, in order"""
    updates: [folio_user_basic_profile_updates!]!
  ): [folio_user_basic_profile_mutation_response]

  """
  update single row of the table: "folio_user"
  """
  update_folio_user_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: folio_user_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: folio_user_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: folio_user_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: folio_user_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: folio_user_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: folio_user_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: folio_user_set_input
    pk_columns: folio_user_pk_columns_input!
  ): folio_user

  """
  update multiples rows of table: "folio_user"
  """
  update_folio_user_many(
    """updates to execute, in order"""
    updates: [folio_user_updates!]!
  ): [folio_user_mutation_response]

  """
  update data of the table: "geographical_region"
  """
  update_geographical_region(
    """increments the numeric columns with given value of the filtered values"""
    _inc: geographical_region_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: geographical_region_set_input

    """filter the rows which have to be updated"""
    where: geographical_region_bool_exp!
  ): geographical_region_mutation_response

  """
  update single row of the table: "geographical_region"
  """
  update_geographical_region_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: geographical_region_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: geographical_region_set_input
    pk_columns: geographical_region_pk_columns_input!
  ): geographical_region

  """
  update multiples rows of table: "geographical_region"
  """
  update_geographical_region_many(
    """updates to execute, in order"""
    updates: [geographical_region_updates!]!
  ): [geographical_region_mutation_response]

  """
  update data of the table: "global_instrument"
  """
  update_global_instrument(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_instrument_set_input

    """filter the rows which have to be updated"""
    where: global_instrument_bool_exp!
  ): global_instrument_mutation_response

  """
  update single row of the table: "global_instrument"
  """
  update_global_instrument_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_instrument_set_input
    pk_columns: global_instrument_pk_columns_input!
  ): global_instrument

  """
  update multiples rows of table: "global_instrument"
  """
  update_global_instrument_many(
    """updates to execute, in order"""
    updates: [global_instrument_updates!]!
  ): [global_instrument_mutation_response]

  """
  update data of the table: "global_package"
  """
  update_global_package(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_package_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_package_set_input

    """filter the rows which have to be updated"""
    where: global_package_bool_exp!
  ): global_package_mutation_response

  """
  update single row of the table: "global_package"
  """
  update_global_package_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_package_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_package_set_input
    pk_columns: global_package_pk_columns_input!
  ): global_package

  """
  update multiples rows of table: "global_package"
  """
  update_global_package_many(
    """updates to execute, in order"""
    updates: [global_package_updates!]!
  ): [global_package_mutation_response]

  """
  update data of the table: "global_permission"
  """
  update_global_permission(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_permission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_permission_set_input

    """filter the rows which have to be updated"""
    where: global_permission_bool_exp!
  ): global_permission_mutation_response

  """
  update single row of the table: "global_permission"
  """
  update_global_permission_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_permission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_permission_set_input
    pk_columns: global_permission_pk_columns_input!
  ): global_permission

  """
  update multiples rows of table: "global_permission"
  """
  update_global_permission_many(
    """updates to execute, in order"""
    updates: [global_permission_updates!]!
  ): [global_permission_mutation_response]

  """
  update data of the table: "global_product"
  """
  update_global_product(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_product_set_input

    """filter the rows which have to be updated"""
    where: global_product_bool_exp!
  ): global_product_mutation_response

  """
  update single row of the table: "global_product"
  """
  update_global_product_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_product_set_input
    pk_columns: global_product_pk_columns_input!
  ): global_product

  """
  update data of the table: "global_product_config"
  """
  update_global_product_config(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_product_config_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_product_config_set_input

    """filter the rows which have to be updated"""
    where: global_product_config_bool_exp!
  ): global_product_config_mutation_response

  """
  update single row of the table: "global_product_config"
  """
  update_global_product_config_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: global_product_config_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: global_product_config_set_input
    pk_columns: global_product_config_pk_columns_input!
  ): global_product_config

  """
  update multiples rows of table: "global_product_config"
  """
  update_global_product_config_many(
    """updates to execute, in order"""
    updates: [global_product_config_updates!]!
  ): [global_product_config_mutation_response]

  """
  update multiples rows of table: "global_product"
  """
  update_global_product_many(
    """updates to execute, in order"""
    updates: [global_product_updates!]!
  ): [global_product_mutation_response]

  """
  update data of the table: "hfc_card_settings"
  """
  update_hfc_card_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: hfc_card_settings_set_input

    """filter the rows which have to be updated"""
    where: hfc_card_settings_bool_exp!
  ): hfc_card_settings_mutation_response

  """
  update single row of the table: "hfc_card_settings"
  """
  update_hfc_card_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: hfc_card_settings_set_input
    pk_columns: hfc_card_settings_pk_columns_input!
  ): hfc_card_settings

  """
  update multiples rows of table: "hfc_card_settings"
  """
  update_hfc_card_settings_many(
    """updates to execute, in order"""
    updates: [hfc_card_settings_updates!]!
  ): [hfc_card_settings_mutation_response]

  """
  update data of the table: "hfc_user_settings"
  """
  update_hfc_user_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: hfc_user_settings_set_input

    """filter the rows which have to be updated"""
    where: hfc_user_settings_bool_exp!
  ): hfc_user_settings_mutation_response

  """
  update single row of the table: "hfc_user_settings"
  """
  update_hfc_user_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: hfc_user_settings_set_input
    pk_columns: hfc_user_settings_pk_columns_input!
  ): hfc_user_settings

  """
  update multiples rows of table: "hfc_user_settings"
  """
  update_hfc_user_settings_many(
    """updates to execute, in order"""
    updates: [hfc_user_settings_updates!]!
  ): [hfc_user_settings_mutation_response]

  """
  update data of the table: "local_instrument"
  """
  update_local_instrument(
    """increments the numeric columns with given value of the filtered values"""
    _inc: local_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: local_instrument_set_input

    """filter the rows which have to be updated"""
    where: local_instrument_bool_exp!
  ): local_instrument_mutation_response

  """
  update single row of the table: "local_instrument"
  """
  update_local_instrument_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: local_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: local_instrument_set_input
    pk_columns: local_instrument_pk_columns_input!
  ): local_instrument

  """
  update multiples rows of table: "local_instrument"
  """
  update_local_instrument_many(
    """updates to execute, in order"""
    updates: [local_instrument_updates!]!
  ): [local_instrument_mutation_response]

  """
  update data of the table: "logout_request"
  """
  update_logout_request(
    """increments the numeric columns with given value of the filtered values"""
    _inc: logout_request_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: logout_request_set_input

    """filter the rows which have to be updated"""
    where: logout_request_bool_exp!
  ): logout_request_mutation_response

  """
  update single row of the table: "logout_request"
  """
  update_logout_request_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: logout_request_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: logout_request_set_input
    pk_columns: logout_request_pk_columns_input!
  ): logout_request

  """
  update multiples rows of table: "logout_request"
  """
  update_logout_request_many(
    """updates to execute, in order"""
    updates: [logout_request_updates!]!
  ): [logout_request_mutation_response]

  """
  update data of the table: "organisation"
  """
  update_organisation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: organisation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: organisation_set_input

    """filter the rows which have to be updated"""
    where: organisation_bool_exp!
  ): organisation_mutation_response

  """
  update single row of the table: "organisation"
  """
  update_organisation_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: organisation_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: organisation_set_input
    pk_columns: organisation_pk_columns_input!
  ): organisation

  """
  update multiples rows of table: "organisation"
  """
  update_organisation_many(
    """updates to execute, in order"""
    updates: [organisation_updates!]!
  ): [organisation_mutation_response]

  """
  update data of the table: "package"
  """
  update_package(
    """increments the numeric columns with given value of the filtered values"""
    _inc: package_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: package_set_input

    """filter the rows which have to be updated"""
    where: package_bool_exp!
  ): package_mutation_response

  """
  update single row of the table: "package"
  """
  update_package_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: package_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: package_set_input
    pk_columns: package_pk_columns_input!
  ): package

  """
  update multiples rows of table: "package"
  """
  update_package_many(
    """updates to execute, in order"""
    updates: [package_updates!]!
  ): [package_mutation_response]

  """
  update data of the table: "package_type"
  """
  update_package_type(
    """sets the columns of the filtered rows to the given values"""
    _set: package_type_set_input

    """filter the rows which have to be updated"""
    where: package_type_bool_exp!
  ): package_type_mutation_response

  """
  update single row of the table: "package_type"
  """
  update_package_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: package_type_set_input
    pk_columns: package_type_pk_columns_input!
  ): package_type

  """
  update multiples rows of table: "package_type"
  """
  update_package_type_many(
    """updates to execute, in order"""
    updates: [package_type_updates!]!
  ): [package_type_mutation_response]

  """
  update data of the table: "page_settings"
  """
  update_page_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: page_settings_set_input

    """filter the rows which have to be updated"""
    where: page_settings_bool_exp!
  ): page_settings_mutation_response

  """
  update single row of the table: "page_settings"
  """
  update_page_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: page_settings_set_input
    pk_columns: page_settings_pk_columns_input!
  ): page_settings

  """
  update multiples rows of table: "page_settings"
  """
  update_page_settings_many(
    """updates to execute, in order"""
    updates: [page_settings_updates!]!
  ): [page_settings_mutation_response]

  """
  update data of the table: "permission"
  """
  update_permission(
    """increments the numeric columns with given value of the filtered values"""
    _inc: permission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_set_input

    """filter the rows which have to be updated"""
    where: permission_bool_exp!
  ): permission_mutation_response

  """
  update single row of the table: "permission"
  """
  update_permission_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: permission_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: permission_set_input
    pk_columns: permission_pk_columns_input!
  ): permission

  """
  update multiples rows of table: "permission"
  """
  update_permission_many(
    """updates to execute, in order"""
    updates: [permission_updates!]!
  ): [permission_mutation_response]

  """
  update data of the table: "product"
  """
  update_product(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input

    """filter the rows which have to be updated"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  update data of the table: "product_artis_type"
  """
  update_product_artis_type(
    """sets the columns of the filtered rows to the given values"""
    _set: product_artis_type_set_input

    """filter the rows which have to be updated"""
    where: product_artis_type_bool_exp!
  ): product_artis_type_mutation_response

  """
  update single row of the table: "product_artis_type"
  """
  update_product_artis_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_artis_type_set_input
    pk_columns: product_artis_type_pk_columns_input!
  ): product_artis_type

  """
  update multiples rows of table: "product_artis_type"
  """
  update_product_artis_type_many(
    """updates to execute, in order"""
    updates: [product_artis_type_updates!]!
  ): [product_artis_type_mutation_response]

  """
  update single row of the table: "product"
  """
  update_product_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input
    pk_columns: product_pk_columns_input!
  ): product

  """
  update data of the table: "product_config"
  """
  update_product_config(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_config_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_config_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_config_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_config_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_config_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_config_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_config_set_input

    """filter the rows which have to be updated"""
    where: product_config_bool_exp!
  ): product_config_mutation_response

  """
  update single row of the table: "product_config"
  """
  update_product_config_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_config_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_config_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_config_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_config_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_config_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_config_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_config_set_input
    pk_columns: product_config_pk_columns_input!
  ): product_config

  """
  update multiples rows of table: "product_config"
  """
  update_product_config_many(
    """updates to execute, in order"""
    updates: [product_config_updates!]!
  ): [product_config_mutation_response]

  """
  update data of the table: "product_eod"
  """
  update_product_eod(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_eod_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_eod_set_input

    """filter the rows which have to be updated"""
    where: product_eod_bool_exp!
  ): product_eod_mutation_response

  """
  update single row of the table: "product_eod"
  """
  update_product_eod_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_eod_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_eod_set_input
    pk_columns: product_eod_pk_columns_input!
  ): product_eod

  """
  update multiples rows of table: "product_eod"
  """
  update_product_eod_many(
    """updates to execute, in order"""
    updates: [product_eod_updates!]!
  ): [product_eod_mutation_response]

  """
  update data of the table: "product_global_dependencies"
  """
  update_product_global_dependencies(
    """sets the columns of the filtered rows to the given values"""
    _set: product_global_dependencies_set_input

    """filter the rows which have to be updated"""
    where: product_global_dependencies_bool_exp!
  ): product_global_dependencies_mutation_response

  """
  update single row of the table: "product_global_dependencies"
  """
  update_product_global_dependencies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_global_dependencies_set_input
    pk_columns: product_global_dependencies_pk_columns_input!
  ): product_global_dependencies

  """
  update multiples rows of table: "product_global_dependencies"
  """
  update_product_global_dependencies_many(
    """updates to execute, in order"""
    updates: [product_global_dependencies_updates!]!
  ): [product_global_dependencies_mutation_response]

  """
  update multiples rows of table: "product"
  """
  update_product_many(
    """updates to execute, in order"""
    updates: [product_updates!]!
  ): [product_mutation_response]

  """
  update data of the table: "product_maturity"
  """
  update_product_maturity(
    """sets the columns of the filtered rows to the given values"""
    _set: product_maturity_set_input

    """filter the rows which have to be updated"""
    where: product_maturity_bool_exp!
  ): product_maturity_mutation_response

  """
  update single row of the table: "product_maturity"
  """
  update_product_maturity_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_maturity_set_input
    pk_columns: product_maturity_pk_columns_input!
  ): product_maturity

  """
  update multiples rows of table: "product_maturity"
  """
  update_product_maturity_many(
    """updates to execute, in order"""
    updates: [product_maturity_updates!]!
  ): [product_maturity_mutation_response]

  """
  update data of the table: "product_overrides"
  """
  update_product_overrides(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_overrides_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_overrides_set_input

    """filter the rows which have to be updated"""
    where: product_overrides_bool_exp!
  ): product_overrides_mutation_response

  """
  update single row of the table: "product_overrides"
  """
  update_product_overrides_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_overrides_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_overrides_set_input
    pk_columns: product_overrides_pk_columns_input!
  ): product_overrides

  """
  update multiples rows of table: "product_overrides"
  """
  update_product_overrides_many(
    """updates to execute, in order"""
    updates: [product_overrides_updates!]!
  ): [product_overrides_mutation_response]

  """
  update data of the table: "product_source"
  """
  update_product_source(
    """sets the columns of the filtered rows to the given values"""
    _set: product_source_set_input

    """filter the rows which have to be updated"""
    where: product_source_bool_exp!
  ): product_source_mutation_response

  """
  update single row of the table: "product_source"
  """
  update_product_source_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_source_set_input
    pk_columns: product_source_pk_columns_input!
  ): product_source

  """
  update multiples rows of table: "product_source"
  """
  update_product_source_many(
    """updates to execute, in order"""
    updates: [product_source_updates!]!
  ): [product_source_mutation_response]

  """
  update data of the table: "product_summary_type"
  """
  update_product_summary_type(
    """sets the columns of the filtered rows to the given values"""
    _set: product_summary_type_set_input

    """filter the rows which have to be updated"""
    where: product_summary_type_bool_exp!
  ): product_summary_type_mutation_response

  """
  update single row of the table: "product_summary_type"
  """
  update_product_summary_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_summary_type_set_input
    pk_columns: product_summary_type_pk_columns_input!
  ): product_summary_type

  """
  update multiples rows of table: "product_summary_type"
  """
  update_product_summary_type_many(
    """updates to execute, in order"""
    updates: [product_summary_type_updates!]!
  ): [product_summary_type_mutation_response]

  """
  update data of the table: "product_type"
  """
  update_product_type(
    """sets the columns of the filtered rows to the given values"""
    _set: product_type_set_input

    """filter the rows which have to be updated"""
    where: product_type_bool_exp!
  ): product_type_mutation_response

  """
  update single row of the table: "product_type"
  """
  update_product_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_type_set_input
    pk_columns: product_type_pk_columns_input!
  ): product_type

  """
  update multiples rows of table: "product_type"
  """
  update_product_type_many(
    """updates to execute, in order"""
    updates: [product_type_updates!]!
  ): [product_type_mutation_response]

  """
  update data of the table: "product_uom"
  """
  update_product_uom(
    """sets the columns of the filtered rows to the given values"""
    _set: product_uom_set_input

    """filter the rows which have to be updated"""
    where: product_uom_bool_exp!
  ): product_uom_mutation_response

  """
  update single row of the table: "product_uom"
  """
  update_product_uom_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: product_uom_set_input
    pk_columns: product_uom_pk_columns_input!
  ): product_uom

  """
  update multiples rows of table: "product_uom"
  """
  update_product_uom_many(
    """updates to execute, in order"""
    updates: [product_uom_updates!]!
  ): [product_uom_mutation_response]

  """
  update data of the table: "session"
  """
  update_session(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input

    """filter the rows which have to be updated"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  update single row of the table: "session"
  """
  update_session_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input
    pk_columns: session_pk_columns_input!
  ): session

  """
  update multiples rows of table: "session"
  """
  update_session_many(
    """updates to execute, in order"""
    updates: [session_updates!]!
  ): [session_mutation_response]

  """
  update data of the table: "session_type"
  """
  update_session_type(
    """sets the columns of the filtered rows to the given values"""
    _set: session_type_set_input

    """filter the rows which have to be updated"""
    where: session_type_bool_exp!
  ): session_type_mutation_response

  """
  update single row of the table: "session_type"
  """
  update_session_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: session_type_set_input
    pk_columns: session_type_pk_columns_input!
  ): session_type

  """
  update multiples rows of table: "session_type"
  """
  update_session_type_many(
    """updates to execute, in order"""
    updates: [session_type_updates!]!
  ): [session_type_mutation_response]

  """
  update data of the table: "shared_instrument"
  """
  update_shared_instrument(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shared_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shared_instrument_set_input

    """filter the rows which have to be updated"""
    where: shared_instrument_bool_exp!
  ): shared_instrument_mutation_response

  """
  update single row of the table: "shared_instrument"
  """
  update_shared_instrument_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: shared_instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: shared_instrument_set_input
    pk_columns: shared_instrument_pk_columns_input!
  ): shared_instrument

  """
  update multiples rows of table: "shared_instrument"
  """
  update_shared_instrument_many(
    """updates to execute, in order"""
    updates: [shared_instrument_updates!]!
  ): [shared_instrument_mutation_response]

  """
  update data of the table: "sharing_agreement"
  """
  update_sharing_agreement(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sharing_agreement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sharing_agreement_set_input

    """filter the rows which have to be updated"""
    where: sharing_agreement_bool_exp!
  ): sharing_agreement_mutation_response

  """
  update single row of the table: "sharing_agreement"
  """
  update_sharing_agreement_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: sharing_agreement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: sharing_agreement_set_input
    pk_columns: sharing_agreement_pk_columns_input!
  ): sharing_agreement

  """
  update multiples rows of table: "sharing_agreement"
  """
  update_sharing_agreement_many(
    """updates to execute, in order"""
    updates: [sharing_agreement_updates!]!
  ): [sharing_agreement_mutation_response]

  """
  update data of the table: "source"
  """
  update_source(
    """increments the numeric columns with given value of the filtered values"""
    _inc: source_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: source_set_input

    """filter the rows which have to be updated"""
    where: source_bool_exp!
  ): source_mutation_response

  """
  update single row of the table: "source"
  """
  update_source_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: source_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: source_set_input
    pk_columns: source_pk_columns_input!
  ): source

  """
  update multiples rows of table: "source"
  """
  update_source_many(
    """updates to execute, in order"""
    updates: [source_updates!]!
  ): [source_mutation_response]

  """
  update data of the table: "user_right"
  """
  update_user_right(
    """sets the columns of the filtered rows to the given values"""
    _set: user_right_set_input

    """filter the rows which have to be updated"""
    where: user_right_bool_exp!
  ): user_right_mutation_response

  """
  update single row of the table: "user_right"
  """
  update_user_right_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_right_set_input
    pk_columns: user_right_pk_columns_input!
  ): user_right

  """
  update multiples rows of table: "user_right"
  """
  update_user_right_many(
    """updates to execute, in order"""
    updates: [user_right_updates!]!
  ): [user_right_mutation_response]

  """
  update data of the table: "user_storage"
  """
  update_user_storage(
    """sets the columns of the filtered rows to the given values"""
    _set: user_storage_set_input

    """filter the rows which have to be updated"""
    where: user_storage_bool_exp!
  ): user_storage_mutation_response

  """
  update single row of the table: "user_storage"
  """
  update_user_storage_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_storage_set_input
    pk_columns: user_storage_pk_columns_input!
  ): user_storage

  """
  update multiples rows of table: "user_storage"
  """
  update_user_storage_many(
    """updates to execute, in order"""
    updates: [user_storage_updates!]!
  ): [user_storage_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

scalar oid

"""
Boolean expression to compare columns of type "oid". All fields are combined with logical 'AND'.
"""
input oid_comparison_exp {
  _eq: oid
  _gt: oid
  _gte: oid
  _in: [oid!]
  _is_null: Boolean
  _lt: oid
  _lte: oid
  _neq: oid
  _nin: [oid!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "organisation"
"""
type organisation {
  """An array relationship"""
  commodity_parent_groups(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): [commodity_parent_group!]!

  """An aggregate relationship"""
  commodity_parent_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): commodity_parent_group_aggregate!

  """An array relationship"""
  folio_users(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): [folio_user!]!

  """An aggregate relationship"""
  folio_users_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): folio_user_aggregate!

  """An array relationship"""
  geographical_regions(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): [geographical_region!]!

  """An aggregate relationship"""
  geographical_regions_aggregate(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): geographical_region_aggregate!
  id: Int!
  is_allowed_global_packages: Boolean

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!
  source: Int!

  """An object relationship"""
  sourceBySource: source!
}

"""
aggregated selection of "organisation"
"""
type organisation_aggregate {
  aggregate: organisation_aggregate_fields
  nodes: [organisation!]!
}

input organisation_aggregate_bool_exp {
  bool_and: organisation_aggregate_bool_exp_bool_and
  bool_or: organisation_aggregate_bool_exp_bool_or
  count: organisation_aggregate_bool_exp_count
}

input organisation_aggregate_bool_exp_bool_and {
  arguments: organisation_select_column_organisation_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: organisation_bool_exp
  predicate: Boolean_comparison_exp!
}

input organisation_aggregate_bool_exp_bool_or {
  arguments: organisation_select_column_organisation_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: organisation_bool_exp
  predicate: Boolean_comparison_exp!
}

input organisation_aggregate_bool_exp_count {
  arguments: [organisation_select_column!]
  distinct: Boolean
  filter: organisation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "organisation"
"""
type organisation_aggregate_fields {
  avg: organisation_avg_fields
  count(columns: [organisation_select_column!], distinct: Boolean): Int!
  max: organisation_max_fields
  min: organisation_min_fields
  stddev: organisation_stddev_fields
  stddev_pop: organisation_stddev_pop_fields
  stddev_samp: organisation_stddev_samp_fields
  sum: organisation_sum_fields
  var_pop: organisation_var_pop_fields
  var_samp: organisation_var_samp_fields
  variance: organisation_variance_fields
}

"""
order by aggregate values of table "organisation"
"""
input organisation_aggregate_order_by {
  avg: organisation_avg_order_by
  count: order_by
  max: organisation_max_order_by
  min: organisation_min_order_by
  stddev: organisation_stddev_order_by
  stddev_pop: organisation_stddev_pop_order_by
  stddev_samp: organisation_stddev_samp_order_by
  sum: organisation_sum_order_by
  var_pop: organisation_var_pop_order_by
  var_samp: organisation_var_samp_order_by
  variance: organisation_variance_order_by
}

"""
input type for inserting array relation for remote table "organisation"
"""
input organisation_arr_rel_insert_input {
  data: [organisation_insert_input!]!

  """upsert condition"""
  on_conflict: organisation_on_conflict
}

"""aggregate avg on columns"""
type organisation_avg_fields {
  id: Float
  source: Float
}

"""
order by avg() on columns of table "organisation"
"""
input organisation_avg_order_by {
  id: order_by
  source: order_by
}

"""
Boolean expression to filter rows from the table "organisation". All fields are combined with a logical 'AND'.
"""
input organisation_bool_exp {
  _and: [organisation_bool_exp!]
  _not: organisation_bool_exp
  _or: [organisation_bool_exp!]
  commodity_parent_groups: commodity_parent_group_bool_exp
  commodity_parent_groups_aggregate: commodity_parent_group_aggregate_bool_exp
  folio_users: folio_user_bool_exp
  folio_users_aggregate: folio_user_aggregate_bool_exp
  geographical_regions: geographical_region_bool_exp
  geographical_regions_aggregate: geographical_region_aggregate_bool_exp
  id: Int_comparison_exp
  is_allowed_global_packages: Boolean_comparison_exp
  product_overrides: product_overrides_bool_exp
  product_overrides_aggregate: product_overrides_aggregate_bool_exp
  source: Int_comparison_exp
  sourceBySource: source_bool_exp
}

"""
unique or primary key constraints on table "organisation"
"""
enum organisation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organisation_pkey

  """
  unique or primary key constraint on columns "source"
  """
  organisation_source_key
}

"""
input type for incrementing numeric columns in table "organisation"
"""
input organisation_inc_input {
  id: Int
  source: Int
}

"""
input type for inserting data into table "organisation"
"""
input organisation_insert_input {
  commodity_parent_groups: commodity_parent_group_arr_rel_insert_input
  folio_users: folio_user_arr_rel_insert_input
  geographical_regions: geographical_region_arr_rel_insert_input
  id: Int
  is_allowed_global_packages: Boolean
  product_overrides: product_overrides_arr_rel_insert_input
  source: Int
  sourceBySource: source_obj_rel_insert_input
}

"""aggregate max on columns"""
type organisation_max_fields {
  id: Int
  source: Int
}

"""
order by max() on columns of table "organisation"
"""
input organisation_max_order_by {
  id: order_by
  source: order_by
}

"""aggregate min on columns"""
type organisation_min_fields {
  id: Int
  source: Int
}

"""
order by min() on columns of table "organisation"
"""
input organisation_min_order_by {
  id: order_by
  source: order_by
}

"""
response of any mutation on the table "organisation"
"""
type organisation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organisation!]!
}

"""
input type for inserting object relation for remote table "organisation"
"""
input organisation_obj_rel_insert_input {
  data: organisation_insert_input!

  """upsert condition"""
  on_conflict: organisation_on_conflict
}

"""
on_conflict condition type for table "organisation"
"""
input organisation_on_conflict {
  constraint: organisation_constraint!
  update_columns: [organisation_update_column!]! = []
  where: organisation_bool_exp
}

"""Ordering options when selecting data from "organisation"."""
input organisation_order_by {
  commodity_parent_groups_aggregate: commodity_parent_group_aggregate_order_by
  folio_users_aggregate: folio_user_aggregate_order_by
  geographical_regions_aggregate: geographical_region_aggregate_order_by
  id: order_by
  is_allowed_global_packages: order_by
  product_overrides_aggregate: product_overrides_aggregate_order_by
  source: order_by
  sourceBySource: source_order_by
}

"""primary key columns input for table: organisation"""
input organisation_pk_columns_input {
  id: Int!
}

"""
select columns of table "organisation"
"""
enum organisation_select_column {
  """column name"""
  id

  """column name"""
  is_allowed_global_packages

  """column name"""
  source
}

"""
select "organisation_aggregate_bool_exp_bool_and_arguments_columns" columns of table "organisation"
"""
enum organisation_select_column_organisation_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_allowed_global_packages
}

"""
select "organisation_aggregate_bool_exp_bool_or_arguments_columns" columns of table "organisation"
"""
enum organisation_select_column_organisation_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_allowed_global_packages
}

"""
input type for updating data in table "organisation"
"""
input organisation_set_input {
  id: Int
  is_allowed_global_packages: Boolean
  source: Int
}

"""aggregate stddev on columns"""
type organisation_stddev_fields {
  id: Float
  source: Float
}

"""
order by stddev() on columns of table "organisation"
"""
input organisation_stddev_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_pop on columns"""
type organisation_stddev_pop_fields {
  id: Float
  source: Float
}

"""
order by stddev_pop() on columns of table "organisation"
"""
input organisation_stddev_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_samp on columns"""
type organisation_stddev_samp_fields {
  id: Float
  source: Float
}

"""
order by stddev_samp() on columns of table "organisation"
"""
input organisation_stddev_samp_order_by {
  id: order_by
  source: order_by
}

"""
Streaming cursor of the table "organisation"
"""
input organisation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: organisation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input organisation_stream_cursor_value_input {
  id: Int
  is_allowed_global_packages: Boolean
  source: Int
}

"""aggregate sum on columns"""
type organisation_sum_fields {
  id: Int
  source: Int
}

"""
order by sum() on columns of table "organisation"
"""
input organisation_sum_order_by {
  id: order_by
  source: order_by
}

"""
update columns of table "organisation"
"""
enum organisation_update_column {
  """column name"""
  id

  """column name"""
  is_allowed_global_packages

  """column name"""
  source
}

input organisation_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: organisation_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: organisation_set_input

  """filter the rows which have to be updated"""
  where: organisation_bool_exp!
}

"""aggregate var_pop on columns"""
type organisation_var_pop_fields {
  id: Float
  source: Float
}

"""
order by var_pop() on columns of table "organisation"
"""
input organisation_var_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate var_samp on columns"""
type organisation_var_samp_fields {
  id: Float
  source: Float
}

"""
order by var_samp() on columns of table "organisation"
"""
input organisation_var_samp_order_by {
  id: order_by
  source: order_by
}

"""aggregate variance on columns"""
type organisation_variance_fields {
  id: Float
  source: Float
}

"""
order by variance() on columns of table "organisation"
"""
input organisation_variance_order_by {
  id: order_by
  source: order_by
}

"""
columns and relationships of "package"
"""
type package {
  description: String

  """An array relationship"""
  folio_users(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): [folio_user!]!

  """An aggregate relationship"""
  folio_users_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): folio_user_aggregate!
  id: Int!
  is_global: Boolean
  name: String!

  """An object relationship"""
  packageTypeByPackageType: package_type
  package_type: package_type_enum

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): permission_aggregate!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  source: Int

  """An object relationship"""
  sourceBySource: source
}

"""
aggregated selection of "package"
"""
type package_aggregate {
  aggregate: package_aggregate_fields
  nodes: [package!]!
}

input package_aggregate_bool_exp {
  bool_and: package_aggregate_bool_exp_bool_and
  bool_or: package_aggregate_bool_exp_bool_or
  count: package_aggregate_bool_exp_count
}

input package_aggregate_bool_exp_bool_and {
  arguments: package_select_column_package_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: package_bool_exp
  predicate: Boolean_comparison_exp!
}

input package_aggregate_bool_exp_bool_or {
  arguments: package_select_column_package_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: package_bool_exp
  predicate: Boolean_comparison_exp!
}

input package_aggregate_bool_exp_count {
  arguments: [package_select_column!]
  distinct: Boolean
  filter: package_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "package"
"""
type package_aggregate_fields {
  avg: package_avg_fields
  count(columns: [package_select_column!], distinct: Boolean): Int!
  max: package_max_fields
  min: package_min_fields
  stddev: package_stddev_fields
  stddev_pop: package_stddev_pop_fields
  stddev_samp: package_stddev_samp_fields
  sum: package_sum_fields
  var_pop: package_var_pop_fields
  var_samp: package_var_samp_fields
  variance: package_variance_fields
}

"""
order by aggregate values of table "package"
"""
input package_aggregate_order_by {
  avg: package_avg_order_by
  count: order_by
  max: package_max_order_by
  min: package_min_order_by
  stddev: package_stddev_order_by
  stddev_pop: package_stddev_pop_order_by
  stddev_samp: package_stddev_samp_order_by
  sum: package_sum_order_by
  var_pop: package_var_pop_order_by
  var_samp: package_var_samp_order_by
  variance: package_variance_order_by
}

"""
input type for inserting array relation for remote table "package"
"""
input package_arr_rel_insert_input {
  data: [package_insert_input!]!

  """upsert condition"""
  on_conflict: package_on_conflict
}

"""aggregate avg on columns"""
type package_avg_fields {
  id: Float
  source: Float
}

"""
order by avg() on columns of table "package"
"""
input package_avg_order_by {
  id: order_by
  source: order_by
}

"""
Boolean expression to filter rows from the table "package". All fields are combined with a logical 'AND'.
"""
input package_bool_exp {
  _and: [package_bool_exp!]
  _not: package_bool_exp
  _or: [package_bool_exp!]
  description: String_comparison_exp
  folio_users: folio_user_bool_exp
  folio_users_aggregate: folio_user_aggregate_bool_exp
  id: Int_comparison_exp
  is_global: Boolean_comparison_exp
  name: String_comparison_exp
  packageTypeByPackageType: package_type_bool_exp
  package_type: package_type_enum_comparison_exp
  permissions: permission_bool_exp
  permissions_aggregate: permission_aggregate_bool_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  source: Int_comparison_exp
  sourceBySource: source_bool_exp
}

"""
unique or primary key constraints on table "package"
"""
enum package_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  package_pkey

  """
  unique or primary key constraint on columns "source", "name"
  """
  package_source_name_key
}

"""
input type for incrementing numeric columns in table "package"
"""
input package_inc_input {
  id: Int
  source: Int
}

"""
input type for inserting data into table "package"
"""
input package_insert_input {
  description: String
  folio_users: folio_user_arr_rel_insert_input
  id: Int
  is_global: Boolean
  name: String
  packageTypeByPackageType: package_type_obj_rel_insert_input
  package_type: package_type_enum
  permissions: permission_arr_rel_insert_input
  products: product_arr_rel_insert_input
  source: Int
  sourceBySource: source_obj_rel_insert_input
}

"""aggregate max on columns"""
type package_max_fields {
  description: String
  id: Int
  name: String
  source: Int
}

"""
order by max() on columns of table "package"
"""
input package_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  source: order_by
}

"""aggregate min on columns"""
type package_min_fields {
  description: String
  id: Int
  name: String
  source: Int
}

"""
order by min() on columns of table "package"
"""
input package_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  source: order_by
}

"""
response of any mutation on the table "package"
"""
type package_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [package!]!
}

"""
input type for inserting object relation for remote table "package"
"""
input package_obj_rel_insert_input {
  data: package_insert_input!

  """upsert condition"""
  on_conflict: package_on_conflict
}

"""
on_conflict condition type for table "package"
"""
input package_on_conflict {
  constraint: package_constraint!
  update_columns: [package_update_column!]! = []
  where: package_bool_exp
}

"""Ordering options when selecting data from "package"."""
input package_order_by {
  description: order_by
  folio_users_aggregate: folio_user_aggregate_order_by
  id: order_by
  is_global: order_by
  name: order_by
  packageTypeByPackageType: package_type_order_by
  package_type: order_by
  permissions_aggregate: permission_aggregate_order_by
  products_aggregate: product_aggregate_order_by
  source: order_by
  sourceBySource: source_order_by
}

"""primary key columns input for table: package"""
input package_pk_columns_input {
  id: Int!
}

"""
select columns of table "package"
"""
enum package_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_global

  """column name"""
  name

  """column name"""
  package_type

  """column name"""
  source
}

"""
select "package_aggregate_bool_exp_bool_and_arguments_columns" columns of table "package"
"""
enum package_select_column_package_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_global
}

"""
select "package_aggregate_bool_exp_bool_or_arguments_columns" columns of table "package"
"""
enum package_select_column_package_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_global
}

"""
input type for updating data in table "package"
"""
input package_set_input {
  description: String
  id: Int
  is_global: Boolean
  name: String
  package_type: package_type_enum
  source: Int
}

"""aggregate stddev on columns"""
type package_stddev_fields {
  id: Float
  source: Float
}

"""
order by stddev() on columns of table "package"
"""
input package_stddev_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_pop on columns"""
type package_stddev_pop_fields {
  id: Float
  source: Float
}

"""
order by stddev_pop() on columns of table "package"
"""
input package_stddev_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate stddev_samp on columns"""
type package_stddev_samp_fields {
  id: Float
  source: Float
}

"""
order by stddev_samp() on columns of table "package"
"""
input package_stddev_samp_order_by {
  id: order_by
  source: order_by
}

"""
Streaming cursor of the table "package"
"""
input package_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: package_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input package_stream_cursor_value_input {
  description: String
  id: Int
  is_global: Boolean
  name: String
  package_type: package_type_enum
  source: Int
}

"""aggregate sum on columns"""
type package_sum_fields {
  id: Int
  source: Int
}

"""
order by sum() on columns of table "package"
"""
input package_sum_order_by {
  id: order_by
  source: order_by
}

"""
columns and relationships of "package_type"
"""
type package_type {
  value: String!
}

"""
aggregated selection of "package_type"
"""
type package_type_aggregate {
  aggregate: package_type_aggregate_fields
  nodes: [package_type!]!
}

"""
aggregate fields of "package_type"
"""
type package_type_aggregate_fields {
  count(columns: [package_type_select_column!], distinct: Boolean): Int!
  max: package_type_max_fields
  min: package_type_min_fields
}

"""
Boolean expression to filter rows from the table "package_type". All fields are combined with a logical 'AND'.
"""
input package_type_bool_exp {
  _and: [package_type_bool_exp!]
  _not: package_type_bool_exp
  _or: [package_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "package_type"
"""
enum package_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  package_type_pkey
}

enum package_type_enum {
  official
  user
}

"""
Boolean expression to compare columns of type "package_type_enum". All fields are combined with logical 'AND'.
"""
input package_type_enum_comparison_exp {
  _eq: package_type_enum
  _in: [package_type_enum!]
  _is_null: Boolean
  _neq: package_type_enum
  _nin: [package_type_enum!]
}

"""
input type for inserting data into table "package_type"
"""
input package_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type package_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type package_type_min_fields {
  value: String
}

"""
response of any mutation on the table "package_type"
"""
type package_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [package_type!]!
}

"""
input type for inserting object relation for remote table "package_type"
"""
input package_type_obj_rel_insert_input {
  data: package_type_insert_input!

  """upsert condition"""
  on_conflict: package_type_on_conflict
}

"""
on_conflict condition type for table "package_type"
"""
input package_type_on_conflict {
  constraint: package_type_constraint!
  update_columns: [package_type_update_column!]! = []
  where: package_type_bool_exp
}

"""Ordering options when selecting data from "package_type"."""
input package_type_order_by {
  value: order_by
}

"""primary key columns input for table: package_type"""
input package_type_pk_columns_input {
  value: String!
}

"""
select columns of table "package_type"
"""
enum package_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "package_type"
"""
input package_type_set_input {
  value: String
}

"""
Streaming cursor of the table "package_type"
"""
input package_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: package_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input package_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "package_type"
"""
enum package_type_update_column {
  """column name"""
  value
}

input package_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: package_type_set_input

  """filter the rows which have to be updated"""
  where: package_type_bool_exp!
}

"""
update columns of table "package"
"""
enum package_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_global

  """column name"""
  name

  """column name"""
  package_type

  """column name"""
  source
}

input package_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: package_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: package_set_input

  """filter the rows which have to be updated"""
  where: package_bool_exp!
}

"""aggregate var_pop on columns"""
type package_var_pop_fields {
  id: Float
  source: Float
}

"""
order by var_pop() on columns of table "package"
"""
input package_var_pop_order_by {
  id: order_by
  source: order_by
}

"""aggregate var_samp on columns"""
type package_var_samp_fields {
  id: Float
  source: Float
}

"""
order by var_samp() on columns of table "package"
"""
input package_var_samp_order_by {
  id: order_by
  source: order_by
}

"""aggregate variance on columns"""
type package_variance_fields {
  id: Float
  source: Float
}

"""
order by variance() on columns of table "package"
"""
input package_variance_order_by {
  id: order_by
  source: order_by
}

"""
columns and relationships of "page_settings"
"""
type page_settings {
  """An object relationship"""
  folioUserByFolioUser: folio_user!
  folio_user: String!
  settings_blob: String!
}

"""
aggregated selection of "page_settings"
"""
type page_settings_aggregate {
  aggregate: page_settings_aggregate_fields
  nodes: [page_settings!]!
}

input page_settings_aggregate_bool_exp {
  count: page_settings_aggregate_bool_exp_count
}

input page_settings_aggregate_bool_exp_count {
  arguments: [page_settings_select_column!]
  distinct: Boolean
  filter: page_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "page_settings"
"""
type page_settings_aggregate_fields {
  count(columns: [page_settings_select_column!], distinct: Boolean): Int!
  max: page_settings_max_fields
  min: page_settings_min_fields
}

"""
order by aggregate values of table "page_settings"
"""
input page_settings_aggregate_order_by {
  count: order_by
  max: page_settings_max_order_by
  min: page_settings_min_order_by
}

"""
input type for inserting array relation for remote table "page_settings"
"""
input page_settings_arr_rel_insert_input {
  data: [page_settings_insert_input!]!

  """upsert condition"""
  on_conflict: page_settings_on_conflict
}

"""
Boolean expression to filter rows from the table "page_settings". All fields are combined with a logical 'AND'.
"""
input page_settings_bool_exp {
  _and: [page_settings_bool_exp!]
  _not: page_settings_bool_exp
  _or: [page_settings_bool_exp!]
  folioUserByFolioUser: folio_user_bool_exp
  folio_user: String_comparison_exp
  settings_blob: String_comparison_exp
}

"""
unique or primary key constraints on table "page_settings"
"""
enum page_settings_constraint {
  """
  unique or primary key constraint on columns "folio_user"
  """
  page_settings_pkey
}

"""
input type for inserting data into table "page_settings"
"""
input page_settings_insert_input {
  folioUserByFolioUser: folio_user_obj_rel_insert_input
  folio_user: String
  settings_blob: String
}

"""aggregate max on columns"""
type page_settings_max_fields {
  folio_user: String
  settings_blob: String
}

"""
order by max() on columns of table "page_settings"
"""
input page_settings_max_order_by {
  folio_user: order_by
  settings_blob: order_by
}

"""aggregate min on columns"""
type page_settings_min_fields {
  folio_user: String
  settings_blob: String
}

"""
order by min() on columns of table "page_settings"
"""
input page_settings_min_order_by {
  folio_user: order_by
  settings_blob: order_by
}

"""
response of any mutation on the table "page_settings"
"""
type page_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [page_settings!]!
}

"""
input type for inserting object relation for remote table "page_settings"
"""
input page_settings_obj_rel_insert_input {
  data: page_settings_insert_input!

  """upsert condition"""
  on_conflict: page_settings_on_conflict
}

"""
on_conflict condition type for table "page_settings"
"""
input page_settings_on_conflict {
  constraint: page_settings_constraint!
  update_columns: [page_settings_update_column!]! = []
  where: page_settings_bool_exp
}

"""Ordering options when selecting data from "page_settings"."""
input page_settings_order_by {
  folioUserByFolioUser: folio_user_order_by
  folio_user: order_by
  settings_blob: order_by
}

"""primary key columns input for table: page_settings"""
input page_settings_pk_columns_input {
  folio_user: String!
}

"""
select columns of table "page_settings"
"""
enum page_settings_select_column {
  """column name"""
  folio_user

  """column name"""
  settings_blob
}

"""
input type for updating data in table "page_settings"
"""
input page_settings_set_input {
  folio_user: String
  settings_blob: String
}

"""
Streaming cursor of the table "page_settings"
"""
input page_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: page_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input page_settings_stream_cursor_value_input {
  folio_user: String
  settings_blob: String
}

"""
update columns of table "page_settings"
"""
enum page_settings_update_column {
  """column name"""
  folio_user

  """column name"""
  settings_blob
}

input page_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: page_settings_set_input

  """filter the rows which have to be updated"""
  where: page_settings_bool_exp!
}

"""
columns and relationships of "permission"
"""
type permission {
  """An object relationship"""
  folioUserByFolioUser: folio_user!
  folio_user: String!
  id: Int!
  package: Int!

  """An object relationship"""
  packageByPackage: package!
  permission: user_right_enum!

  """An object relationship"""
  user_right: user_right!
}

"""
aggregated selection of "permission"
"""
type permission_aggregate {
  aggregate: permission_aggregate_fields
  nodes: [permission!]!
}

input permission_aggregate_bool_exp {
  count: permission_aggregate_bool_exp_count
}

input permission_aggregate_bool_exp_count {
  arguments: [permission_select_column!]
  distinct: Boolean
  filter: permission_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "permission"
"""
type permission_aggregate_fields {
  avg: permission_avg_fields
  count(columns: [permission_select_column!], distinct: Boolean): Int!
  max: permission_max_fields
  min: permission_min_fields
  stddev: permission_stddev_fields
  stddev_pop: permission_stddev_pop_fields
  stddev_samp: permission_stddev_samp_fields
  sum: permission_sum_fields
  var_pop: permission_var_pop_fields
  var_samp: permission_var_samp_fields
  variance: permission_variance_fields
}

"""
order by aggregate values of table "permission"
"""
input permission_aggregate_order_by {
  avg: permission_avg_order_by
  count: order_by
  max: permission_max_order_by
  min: permission_min_order_by
  stddev: permission_stddev_order_by
  stddev_pop: permission_stddev_pop_order_by
  stddev_samp: permission_stddev_samp_order_by
  sum: permission_sum_order_by
  var_pop: permission_var_pop_order_by
  var_samp: permission_var_samp_order_by
  variance: permission_variance_order_by
}

"""
input type for inserting array relation for remote table "permission"
"""
input permission_arr_rel_insert_input {
  data: [permission_insert_input!]!

  """upsert condition"""
  on_conflict: permission_on_conflict
}

"""aggregate avg on columns"""
type permission_avg_fields {
  id: Float
  package: Float
}

"""
order by avg() on columns of table "permission"
"""
input permission_avg_order_by {
  id: order_by
  package: order_by
}

"""
Boolean expression to filter rows from the table "permission". All fields are combined with a logical 'AND'.
"""
input permission_bool_exp {
  _and: [permission_bool_exp!]
  _not: permission_bool_exp
  _or: [permission_bool_exp!]
  folioUserByFolioUser: folio_user_bool_exp
  folio_user: String_comparison_exp
  id: Int_comparison_exp
  package: Int_comparison_exp
  packageByPackage: package_bool_exp
  permission: user_right_enum_comparison_exp
  user_right: user_right_bool_exp
}

"""
unique or primary key constraints on table "permission"
"""
enum permission_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_id_key

  """
  unique or primary key constraint on columns "package", "folio_user"
  """
  permission_pkey
}

"""
input type for incrementing numeric columns in table "permission"
"""
input permission_inc_input {
  id: Int
  package: Int
}

"""
input type for inserting data into table "permission"
"""
input permission_insert_input {
  folioUserByFolioUser: folio_user_obj_rel_insert_input
  folio_user: String
  id: Int
  package: Int
  packageByPackage: package_obj_rel_insert_input
  permission: user_right_enum
  user_right: user_right_obj_rel_insert_input
}

"""aggregate max on columns"""
type permission_max_fields {
  folio_user: String
  id: Int
  package: Int
}

"""
order by max() on columns of table "permission"
"""
input permission_max_order_by {
  folio_user: order_by
  id: order_by
  package: order_by
}

"""aggregate min on columns"""
type permission_min_fields {
  folio_user: String
  id: Int
  package: Int
}

"""
order by min() on columns of table "permission"
"""
input permission_min_order_by {
  folio_user: order_by
  id: order_by
  package: order_by
}

"""
response of any mutation on the table "permission"
"""
type permission_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [permission!]!
}

"""
on_conflict condition type for table "permission"
"""
input permission_on_conflict {
  constraint: permission_constraint!
  update_columns: [permission_update_column!]! = []
  where: permission_bool_exp
}

"""Ordering options when selecting data from "permission"."""
input permission_order_by {
  folioUserByFolioUser: folio_user_order_by
  folio_user: order_by
  id: order_by
  package: order_by
  packageByPackage: package_order_by
  permission: order_by
  user_right: user_right_order_by
}

"""primary key columns input for table: permission"""
input permission_pk_columns_input {
  folio_user: String!
  package: Int!
}

"""
select columns of table "permission"
"""
enum permission_select_column {
  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  package

  """column name"""
  permission
}

"""
input type for updating data in table "permission"
"""
input permission_set_input {
  folio_user: String
  id: Int
  package: Int
  permission: user_right_enum
}

"""aggregate stddev on columns"""
type permission_stddev_fields {
  id: Float
  package: Float
}

"""
order by stddev() on columns of table "permission"
"""
input permission_stddev_order_by {
  id: order_by
  package: order_by
}

"""aggregate stddev_pop on columns"""
type permission_stddev_pop_fields {
  id: Float
  package: Float
}

"""
order by stddev_pop() on columns of table "permission"
"""
input permission_stddev_pop_order_by {
  id: order_by
  package: order_by
}

"""aggregate stddev_samp on columns"""
type permission_stddev_samp_fields {
  id: Float
  package: Float
}

"""
order by stddev_samp() on columns of table "permission"
"""
input permission_stddev_samp_order_by {
  id: order_by
  package: order_by
}

"""
Streaming cursor of the table "permission"
"""
input permission_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: permission_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input permission_stream_cursor_value_input {
  folio_user: String
  id: Int
  package: Int
  permission: user_right_enum
}

"""aggregate sum on columns"""
type permission_sum_fields {
  id: Int
  package: Int
}

"""
order by sum() on columns of table "permission"
"""
input permission_sum_order_by {
  id: order_by
  package: order_by
}

"""
update columns of table "permission"
"""
enum permission_update_column {
  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  package

  """column name"""
  permission
}

input permission_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: permission_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: permission_set_input

  """filter the rows which have to be updated"""
  where: permission_bool_exp!
}

"""aggregate var_pop on columns"""
type permission_var_pop_fields {
  id: Float
  package: Float
}

"""
order by var_pop() on columns of table "permission"
"""
input permission_var_pop_order_by {
  id: order_by
  package: order_by
}

"""aggregate var_samp on columns"""
type permission_var_samp_fields {
  id: Float
  package: Float
}

"""
order by var_samp() on columns of table "permission"
"""
input permission_var_samp_order_by {
  id: order_by
  package: order_by
}

"""aggregate variance on columns"""
type permission_variance_fields {
  id: Float
  package: Float
}

"""
order by variance() on columns of table "permission"
"""
input permission_variance_order_by {
  id: order_by
  package: order_by
}

"""
columns and relationships of "product"
"""
type product {
  artis_type: product_artis_type_enum!
  code: String

  """An object relationship"""
  commodityGroupByCommodityGroup: commodity_group
  commodity_group: Int
  description: String

  """An array relationship"""
  eod_entries(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): [eod_entry!]!

  """An aggregate relationship"""
  eod_entries_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): eod_entry_aggregate!
  eod_product_dep: uuid

  """An object relationship"""
  geographicalRegionByGeographicalRegion: geographical_region
  geographical_region: Int
  has_shared_cell: Boolean
  id: uuid!
  kt_kb_conversion_factor: numeric
  last_shared(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]

  """An array relationship"""
  local_instruments(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): [local_instrument!]!

  """An aggregate relationship"""
  local_instruments_aggregate(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): local_instrument_aggregate!
  logical_code: String
  maturity: product_maturity_enum!
  name: String!
  package: Int!

  """An object relationship"""
  packageByPackage: package!

  """An array relationship"""
  productEodsByEodProduct(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): [product_eod!]!

  """An aggregate relationship"""
  productEodsByEodProduct_aggregate(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): product_eod_aggregate!

  """An object relationship"""
  productTypeByProductType: product_type!

  """An object relationship"""
  product_artis_type: product_artis_type!

  """An array relationship"""
  product_configs(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): [product_config!]!

  """An aggregate relationship"""
  product_configs_aggregate(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): product_config_aggregate!

  """An array relationship"""
  product_eods(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): [product_eod!]!

  """An aggregate relationship"""
  product_eods_aggregate(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): product_eod_aggregate!

  """An array relationship"""
  product_global_dependencies(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): [product_global_dependencies!]!

  """An aggregate relationship"""
  product_global_dependencies_aggregate(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): product_global_dependencies_aggregate!

  """An object relationship"""
  product_maturity: product_maturity!

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!

  """An object relationship"""
  product_summary_type: product_summary_type!
  product_type: product_type_enum!

  """An object relationship"""
  product_uom: product_uom!

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint

  """An array relationship"""
  shared_instruments(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]!

  """An aggregate relationship"""
  shared_instruments_aggregate(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): shared_instrument_aggregate!
  summary_type: product_summary_type_enum!
  uom: product_uom_enum!
}

"""
aggregated selection of "product"
"""
type product_aggregate {
  aggregate: product_aggregate_fields
  nodes: [product!]!
}

input product_aggregate_bool_exp {
  count: product_aggregate_bool_exp_count
}

input product_aggregate_bool_exp_count {
  arguments: [product_select_column!]
  distinct: Boolean
  filter: product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product"
"""
type product_aggregate_fields {
  avg: product_avg_fields
  count(columns: [product_select_column!], distinct: Boolean): Int!
  max: product_max_fields
  min: product_min_fields
  stddev: product_stddev_fields
  stddev_pop: product_stddev_pop_fields
  stddev_samp: product_stddev_samp_fields
  sum: product_sum_fields
  var_pop: product_var_pop_fields
  var_samp: product_var_samp_fields
  variance: product_variance_fields
}

"""
order by aggregate values of table "product"
"""
input product_aggregate_order_by {
  avg: product_avg_order_by
  count: order_by
  max: product_max_order_by
  min: product_min_order_by
  stddev: product_stddev_order_by
  stddev_pop: product_stddev_pop_order_by
  stddev_samp: product_stddev_samp_order_by
  sum: product_sum_order_by
  var_pop: product_var_pop_order_by
  var_samp: product_var_samp_order_by
  variance: product_variance_order_by
}

"""
input type for inserting array relation for remote table "product"
"""
input product_arr_rel_insert_input {
  data: [product_insert_input!]!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""
columns and relationships of "product_artis_type"
"""
type product_artis_type {
  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "product_artis_type"
"""
type product_artis_type_aggregate {
  aggregate: product_artis_type_aggregate_fields
  nodes: [product_artis_type!]!
}

"""
aggregate fields of "product_artis_type"
"""
type product_artis_type_aggregate_fields {
  count(columns: [product_artis_type_select_column!], distinct: Boolean): Int!
  max: product_artis_type_max_fields
  min: product_artis_type_min_fields
}

"""
Boolean expression to filter rows from the table "product_artis_type". All fields are combined with a logical 'AND'.
"""
input product_artis_type_bool_exp {
  _and: [product_artis_type_bool_exp!]
  _not: product_artis_type_bool_exp
  _or: [product_artis_type_bool_exp!]
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_artis_type"
"""
enum product_artis_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_artis_type_pkey
}

enum product_artis_type_enum {
  canned
  customer_curve
  eod
  sourced
}

"""
Boolean expression to compare columns of type "product_artis_type_enum". All fields are combined with logical 'AND'.
"""
input product_artis_type_enum_comparison_exp {
  _eq: product_artis_type_enum
  _in: [product_artis_type_enum!]
  _is_null: Boolean
  _neq: product_artis_type_enum
  _nin: [product_artis_type_enum!]
}

"""
input type for inserting data into table "product_artis_type"
"""
input product_artis_type_insert_input {
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_artis_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_artis_type_min_fields {
  value: String
}

"""
response of any mutation on the table "product_artis_type"
"""
type product_artis_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_artis_type!]!
}

"""
input type for inserting object relation for remote table "product_artis_type"
"""
input product_artis_type_obj_rel_insert_input {
  data: product_artis_type_insert_input!

  """upsert condition"""
  on_conflict: product_artis_type_on_conflict
}

"""
on_conflict condition type for table "product_artis_type"
"""
input product_artis_type_on_conflict {
  constraint: product_artis_type_constraint!
  update_columns: [product_artis_type_update_column!]! = []
  where: product_artis_type_bool_exp
}

"""Ordering options when selecting data from "product_artis_type"."""
input product_artis_type_order_by {
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_artis_type"""
input product_artis_type_pk_columns_input {
  value: String!
}

"""
select columns of table "product_artis_type"
"""
enum product_artis_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_artis_type"
"""
input product_artis_type_set_input {
  value: String
}

"""
Streaming cursor of the table "product_artis_type"
"""
input product_artis_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_artis_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_artis_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_artis_type"
"""
enum product_artis_type_update_column {
  """column name"""
  value
}

input product_artis_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_artis_type_set_input

  """filter the rows which have to be updated"""
  where: product_artis_type_bool_exp!
}

"""aggregate avg on columns"""
type product_avg_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by avg() on columns of table "product"
"""
input product_avg_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""
Boolean expression to filter rows from the table "product". All fields are combined with a logical 'AND'.
"""
input product_bool_exp {
  _and: [product_bool_exp!]
  _not: product_bool_exp
  _or: [product_bool_exp!]
  artis_type: product_artis_type_enum_comparison_exp
  code: String_comparison_exp
  commodityGroupByCommodityGroup: commodity_group_bool_exp
  commodity_group: Int_comparison_exp
  description: String_comparison_exp
  eod_entries: eod_entry_bool_exp
  eod_entries_aggregate: eod_entry_aggregate_bool_exp
  eod_product_dep: uuid_comparison_exp
  geographicalRegionByGeographicalRegion: geographical_region_bool_exp
  geographical_region: Int_comparison_exp
  has_shared_cell: Boolean_comparison_exp
  id: uuid_comparison_exp
  kt_kb_conversion_factor: numeric_comparison_exp
  last_shared: shared_instrument_bool_exp
  local_instruments: local_instrument_bool_exp
  local_instruments_aggregate: local_instrument_aggregate_bool_exp
  logical_code: String_comparison_exp
  maturity: product_maturity_enum_comparison_exp
  name: String_comparison_exp
  package: Int_comparison_exp
  packageByPackage: package_bool_exp
  productEodsByEodProduct: product_eod_bool_exp
  productEodsByEodProduct_aggregate: product_eod_aggregate_bool_exp
  productTypeByProductType: product_type_bool_exp
  product_artis_type: product_artis_type_bool_exp
  product_configs: product_config_bool_exp
  product_configs_aggregate: product_config_aggregate_bool_exp
  product_eods: product_eod_bool_exp
  product_eods_aggregate: product_eod_aggregate_bool_exp
  product_global_dependencies: product_global_dependencies_bool_exp
  product_global_dependencies_aggregate: product_global_dependencies_aggregate_bool_exp
  product_maturity: product_maturity_bool_exp
  product_overrides: product_overrides_bool_exp
  product_overrides_aggregate: product_overrides_aggregate_bool_exp
  product_summary_type: product_summary_type_bool_exp
  product_type: product_type_enum_comparison_exp
  product_uom: product_uom_bool_exp
  shared_instrument_count: bigint_comparison_exp
  shared_instruments: shared_instrument_bool_exp
  shared_instruments_aggregate: shared_instrument_aggregate_bool_exp
  summary_type: product_summary_type_enum_comparison_exp
  uom: product_uom_enum_comparison_exp
}

"""
columns and relationships of "product_config"
"""
type product_config {
  formula: String
  id: Int!
  package_deps(
    """JSON select path"""
    path: String
  ): jsonb
  product: uuid!

  """An object relationship"""
  productByProduct: product!
  relative_month: Int!
}

"""
aggregated selection of "product_config"
"""
type product_config_aggregate {
  aggregate: product_config_aggregate_fields
  nodes: [product_config!]!
}

input product_config_aggregate_bool_exp {
  count: product_config_aggregate_bool_exp_count
}

input product_config_aggregate_bool_exp_count {
  arguments: [product_config_select_column!]
  distinct: Boolean
  filter: product_config_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_config"
"""
type product_config_aggregate_fields {
  avg: product_config_avg_fields
  count(columns: [product_config_select_column!], distinct: Boolean): Int!
  max: product_config_max_fields
  min: product_config_min_fields
  stddev: product_config_stddev_fields
  stddev_pop: product_config_stddev_pop_fields
  stddev_samp: product_config_stddev_samp_fields
  sum: product_config_sum_fields
  var_pop: product_config_var_pop_fields
  var_samp: product_config_var_samp_fields
  variance: product_config_variance_fields
}

"""
order by aggregate values of table "product_config"
"""
input product_config_aggregate_order_by {
  avg: product_config_avg_order_by
  count: order_by
  max: product_config_max_order_by
  min: product_config_min_order_by
  stddev: product_config_stddev_order_by
  stddev_pop: product_config_stddev_pop_order_by
  stddev_samp: product_config_stddev_samp_order_by
  sum: product_config_sum_order_by
  var_pop: product_config_var_pop_order_by
  var_samp: product_config_var_samp_order_by
  variance: product_config_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input product_config_append_input {
  package_deps: jsonb
}

"""
input type for inserting array relation for remote table "product_config"
"""
input product_config_arr_rel_insert_input {
  data: [product_config_insert_input!]!

  """upsert condition"""
  on_conflict: product_config_on_conflict
}

"""aggregate avg on columns"""
type product_config_avg_fields {
  id: Float
  relative_month: Float
}

"""
order by avg() on columns of table "product_config"
"""
input product_config_avg_order_by {
  id: order_by
  relative_month: order_by
}

"""
Boolean expression to filter rows from the table "product_config". All fields are combined with a logical 'AND'.
"""
input product_config_bool_exp {
  _and: [product_config_bool_exp!]
  _not: product_config_bool_exp
  _or: [product_config_bool_exp!]
  formula: String_comparison_exp
  id: Int_comparison_exp
  package_deps: jsonb_comparison_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
  relative_month: Int_comparison_exp
}

"""
unique or primary key constraints on table "product_config"
"""
enum product_config_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_config_id_key

  """
  unique or primary key constraint on columns "product", "relative_month"
  """
  product_config_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input product_config_delete_at_path_input {
  package_deps: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input product_config_delete_elem_input {
  package_deps: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input product_config_delete_key_input {
  package_deps: String
}

"""
input type for incrementing numeric columns in table "product_config"
"""
input product_config_inc_input {
  id: Int
  relative_month: Int
}

"""
input type for inserting data into table "product_config"
"""
input product_config_insert_input {
  formula: String
  id: Int
  package_deps: jsonb
  product: uuid
  productByProduct: product_obj_rel_insert_input
  relative_month: Int
}

"""aggregate max on columns"""
type product_config_max_fields {
  formula: String
  id: Int
  product: uuid
  relative_month: Int
}

"""
order by max() on columns of table "product_config"
"""
input product_config_max_order_by {
  formula: order_by
  id: order_by
  product: order_by
  relative_month: order_by
}

"""aggregate min on columns"""
type product_config_min_fields {
  formula: String
  id: Int
  product: uuid
  relative_month: Int
}

"""
order by min() on columns of table "product_config"
"""
input product_config_min_order_by {
  formula: order_by
  id: order_by
  product: order_by
  relative_month: order_by
}

"""
response of any mutation on the table "product_config"
"""
type product_config_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_config!]!
}

"""
on_conflict condition type for table "product_config"
"""
input product_config_on_conflict {
  constraint: product_config_constraint!
  update_columns: [product_config_update_column!]! = []
  where: product_config_bool_exp
}

"""Ordering options when selecting data from "product_config"."""
input product_config_order_by {
  formula: order_by
  id: order_by
  package_deps: order_by
  product: order_by
  productByProduct: product_order_by
  relative_month: order_by
}

"""primary key columns input for table: product_config"""
input product_config_pk_columns_input {
  product: uuid!
  relative_month: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input product_config_prepend_input {
  package_deps: jsonb
}

"""
select columns of table "product_config"
"""
enum product_config_select_column {
  """column name"""
  formula

  """column name"""
  id

  """column name"""
  package_deps

  """column name"""
  product

  """column name"""
  relative_month
}

"""
input type for updating data in table "product_config"
"""
input product_config_set_input {
  formula: String
  id: Int
  package_deps: jsonb
  product: uuid
  relative_month: Int
}

"""aggregate stddev on columns"""
type product_config_stddev_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev() on columns of table "product_config"
"""
input product_config_stddev_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate stddev_pop on columns"""
type product_config_stddev_pop_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev_pop() on columns of table "product_config"
"""
input product_config_stddev_pop_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate stddev_samp on columns"""
type product_config_stddev_samp_fields {
  id: Float
  relative_month: Float
}

"""
order by stddev_samp() on columns of table "product_config"
"""
input product_config_stddev_samp_order_by {
  id: order_by
  relative_month: order_by
}

"""
Streaming cursor of the table "product_config"
"""
input product_config_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_config_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_config_stream_cursor_value_input {
  formula: String
  id: Int
  package_deps: jsonb
  product: uuid
  relative_month: Int
}

"""aggregate sum on columns"""
type product_config_sum_fields {
  id: Int
  relative_month: Int
}

"""
order by sum() on columns of table "product_config"
"""
input product_config_sum_order_by {
  id: order_by
  relative_month: order_by
}

"""
update columns of table "product_config"
"""
enum product_config_update_column {
  """column name"""
  formula

  """column name"""
  id

  """column name"""
  package_deps

  """column name"""
  product

  """column name"""
  relative_month
}

input product_config_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: product_config_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: product_config_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: product_config_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: product_config_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: product_config_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: product_config_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_config_set_input

  """filter the rows which have to be updated"""
  where: product_config_bool_exp!
}

"""aggregate var_pop on columns"""
type product_config_var_pop_fields {
  id: Float
  relative_month: Float
}

"""
order by var_pop() on columns of table "product_config"
"""
input product_config_var_pop_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate var_samp on columns"""
type product_config_var_samp_fields {
  id: Float
  relative_month: Float
}

"""
order by var_samp() on columns of table "product_config"
"""
input product_config_var_samp_order_by {
  id: order_by
  relative_month: order_by
}

"""aggregate variance on columns"""
type product_config_variance_fields {
  id: Float
  relative_month: Float
}

"""
order by variance() on columns of table "product_config"
"""
input product_config_variance_order_by {
  id: order_by
  relative_month: order_by
}

"""
unique or primary key constraints on table "product"
"""
enum product_constraint {
  """
  unique or primary key constraint on columns "package", "description"
  """
  product_description_package_key

  """
  unique or primary key constraint on columns "id"
  """
  product_pkey
}

"""
columns and relationships of "product_eod"
"""
type product_eod {
  eod_product: uuid!
  id: Int!
  product: uuid!

  """An object relationship"""
  productByEodProduct: product!

  """An object relationship"""
  productByProduct: product!
}

"""
aggregated selection of "product_eod"
"""
type product_eod_aggregate {
  aggregate: product_eod_aggregate_fields
  nodes: [product_eod!]!
}

input product_eod_aggregate_bool_exp {
  count: product_eod_aggregate_bool_exp_count
}

input product_eod_aggregate_bool_exp_count {
  arguments: [product_eod_select_column!]
  distinct: Boolean
  filter: product_eod_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_eod"
"""
type product_eod_aggregate_fields {
  avg: product_eod_avg_fields
  count(columns: [product_eod_select_column!], distinct: Boolean): Int!
  max: product_eod_max_fields
  min: product_eod_min_fields
  stddev: product_eod_stddev_fields
  stddev_pop: product_eod_stddev_pop_fields
  stddev_samp: product_eod_stddev_samp_fields
  sum: product_eod_sum_fields
  var_pop: product_eod_var_pop_fields
  var_samp: product_eod_var_samp_fields
  variance: product_eod_variance_fields
}

"""
order by aggregate values of table "product_eod"
"""
input product_eod_aggregate_order_by {
  avg: product_eod_avg_order_by
  count: order_by
  max: product_eod_max_order_by
  min: product_eod_min_order_by
  stddev: product_eod_stddev_order_by
  stddev_pop: product_eod_stddev_pop_order_by
  stddev_samp: product_eod_stddev_samp_order_by
  sum: product_eod_sum_order_by
  var_pop: product_eod_var_pop_order_by
  var_samp: product_eod_var_samp_order_by
  variance: product_eod_variance_order_by
}

"""
input type for inserting array relation for remote table "product_eod"
"""
input product_eod_arr_rel_insert_input {
  data: [product_eod_insert_input!]!

  """upsert condition"""
  on_conflict: product_eod_on_conflict
}

"""aggregate avg on columns"""
type product_eod_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "product_eod"
"""
input product_eod_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "product_eod". All fields are combined with a logical 'AND'.
"""
input product_eod_bool_exp {
  _and: [product_eod_bool_exp!]
  _not: product_eod_bool_exp
  _or: [product_eod_bool_exp!]
  eod_product: uuid_comparison_exp
  id: Int_comparison_exp
  product: uuid_comparison_exp
  productByEodProduct: product_bool_exp
  productByProduct: product_bool_exp
}

"""
unique or primary key constraints on table "product_eod"
"""
enum product_eod_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_eod_id_key

  """
  unique or primary key constraint on columns "product", "eod_product"
  """
  product_eod_pkey
}

"""
input type for incrementing numeric columns in table "product_eod"
"""
input product_eod_inc_input {
  id: Int
}

"""
input type for inserting data into table "product_eod"
"""
input product_eod_insert_input {
  eod_product: uuid
  id: Int
  product: uuid
  productByEodProduct: product_obj_rel_insert_input
  productByProduct: product_obj_rel_insert_input
}

"""aggregate max on columns"""
type product_eod_max_fields {
  eod_product: uuid
  id: Int
  product: uuid
}

"""
order by max() on columns of table "product_eod"
"""
input product_eod_max_order_by {
  eod_product: order_by
  id: order_by
  product: order_by
}

"""aggregate min on columns"""
type product_eod_min_fields {
  eod_product: uuid
  id: Int
  product: uuid
}

"""
order by min() on columns of table "product_eod"
"""
input product_eod_min_order_by {
  eod_product: order_by
  id: order_by
  product: order_by
}

"""
response of any mutation on the table "product_eod"
"""
type product_eod_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_eod!]!
}

"""
on_conflict condition type for table "product_eod"
"""
input product_eod_on_conflict {
  constraint: product_eod_constraint!
  update_columns: [product_eod_update_column!]! = []
  where: product_eod_bool_exp
}

"""Ordering options when selecting data from "product_eod"."""
input product_eod_order_by {
  eod_product: order_by
  id: order_by
  product: order_by
  productByEodProduct: product_order_by
  productByProduct: product_order_by
}

"""primary key columns input for table: product_eod"""
input product_eod_pk_columns_input {
  eod_product: uuid!
  product: uuid!
}

"""
select columns of table "product_eod"
"""
enum product_eod_select_column {
  """column name"""
  eod_product

  """column name"""
  id

  """column name"""
  product
}

"""
input type for updating data in table "product_eod"
"""
input product_eod_set_input {
  eod_product: uuid
  id: Int
  product: uuid
}

"""aggregate stddev on columns"""
type product_eod_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "product_eod"
"""
input product_eod_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type product_eod_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "product_eod"
"""
input product_eod_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type product_eod_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "product_eod"
"""
input product_eod_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "product_eod"
"""
input product_eod_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_eod_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_eod_stream_cursor_value_input {
  eod_product: uuid
  id: Int
  product: uuid
}

"""aggregate sum on columns"""
type product_eod_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "product_eod"
"""
input product_eod_sum_order_by {
  id: order_by
}

"""
update columns of table "product_eod"
"""
enum product_eod_update_column {
  """column name"""
  eod_product

  """column name"""
  id

  """column name"""
  product
}

input product_eod_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_eod_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_eod_set_input

  """filter the rows which have to be updated"""
  where: product_eod_bool_exp!
}

"""aggregate var_pop on columns"""
type product_eod_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "product_eod"
"""
input product_eod_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type product_eod_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "product_eod"
"""
input product_eod_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type product_eod_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "product_eod"
"""
input product_eod_variance_order_by {
  id: order_by
}

"""Maps dependency between products and the global dependencies selected."""
type product_global_dependencies {
  created_at: timestamptz!
  global_product: uuid!
  product: uuid!

  """An object relationship"""
  productByProduct: product!
  updated_at: timestamptz!
}

"""
aggregated selection of "product_global_dependencies"
"""
type product_global_dependencies_aggregate {
  aggregate: product_global_dependencies_aggregate_fields
  nodes: [product_global_dependencies!]!
}

input product_global_dependencies_aggregate_bool_exp {
  count: product_global_dependencies_aggregate_bool_exp_count
}

input product_global_dependencies_aggregate_bool_exp_count {
  arguments: [product_global_dependencies_select_column!]
  distinct: Boolean
  filter: product_global_dependencies_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_global_dependencies"
"""
type product_global_dependencies_aggregate_fields {
  count(columns: [product_global_dependencies_select_column!], distinct: Boolean): Int!
  max: product_global_dependencies_max_fields
  min: product_global_dependencies_min_fields
}

"""
order by aggregate values of table "product_global_dependencies"
"""
input product_global_dependencies_aggregate_order_by {
  count: order_by
  max: product_global_dependencies_max_order_by
  min: product_global_dependencies_min_order_by
}

"""
input type for inserting array relation for remote table "product_global_dependencies"
"""
input product_global_dependencies_arr_rel_insert_input {
  data: [product_global_dependencies_insert_input!]!

  """upsert condition"""
  on_conflict: product_global_dependencies_on_conflict
}

"""
Boolean expression to filter rows from the table "product_global_dependencies". All fields are combined with a logical 'AND'.
"""
input product_global_dependencies_bool_exp {
  _and: [product_global_dependencies_bool_exp!]
  _not: product_global_dependencies_bool_exp
  _or: [product_global_dependencies_bool_exp!]
  created_at: timestamptz_comparison_exp
  global_product: uuid_comparison_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "product_global_dependencies"
"""
enum product_global_dependencies_constraint {
  """
  unique or primary key constraint on columns "global_product", "product"
  """
  product_global_dependencies_pkey
}

"""
input type for inserting data into table "product_global_dependencies"
"""
input product_global_dependencies_insert_input {
  created_at: timestamptz
  global_product: uuid
  product: uuid
  productByProduct: product_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type product_global_dependencies_max_fields {
  created_at: timestamptz
  global_product: uuid
  product: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "product_global_dependencies"
"""
input product_global_dependencies_max_order_by {
  created_at: order_by
  global_product: order_by
  product: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type product_global_dependencies_min_fields {
  created_at: timestamptz
  global_product: uuid
  product: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "product_global_dependencies"
"""
input product_global_dependencies_min_order_by {
  created_at: order_by
  global_product: order_by
  product: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "product_global_dependencies"
"""
type product_global_dependencies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_global_dependencies!]!
}

"""
on_conflict condition type for table "product_global_dependencies"
"""
input product_global_dependencies_on_conflict {
  constraint: product_global_dependencies_constraint!
  update_columns: [product_global_dependencies_update_column!]! = []
  where: product_global_dependencies_bool_exp
}

"""
Ordering options when selecting data from "product_global_dependencies".
"""
input product_global_dependencies_order_by {
  created_at: order_by
  global_product: order_by
  product: order_by
  productByProduct: product_order_by
  updated_at: order_by
}

"""primary key columns input for table: product_global_dependencies"""
input product_global_dependencies_pk_columns_input {
  global_product: uuid!
  product: uuid!
}

"""
select columns of table "product_global_dependencies"
"""
enum product_global_dependencies_select_column {
  """column name"""
  created_at

  """column name"""
  global_product

  """column name"""
  product

  """column name"""
  updated_at
}

"""
input type for updating data in table "product_global_dependencies"
"""
input product_global_dependencies_set_input {
  created_at: timestamptz
  global_product: uuid
  product: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "product_global_dependencies"
"""
input product_global_dependencies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_global_dependencies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_global_dependencies_stream_cursor_value_input {
  created_at: timestamptz
  global_product: uuid
  product: uuid
  updated_at: timestamptz
}

"""
update columns of table "product_global_dependencies"
"""
enum product_global_dependencies_update_column {
  """column name"""
  created_at

  """column name"""
  global_product

  """column name"""
  product

  """column name"""
  updated_at
}

input product_global_dependencies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_global_dependencies_set_input

  """filter the rows which have to be updated"""
  where: product_global_dependencies_bool_exp!
}

"""
input type for incrementing numeric columns in table "product"
"""
input product_inc_input {
  commodity_group: Int
  geographical_region: Int
  kt_kb_conversion_factor: numeric
  package: Int
}

"""
input type for inserting data into table "product"
"""
input product_insert_input {
  artis_type: product_artis_type_enum
  code: String
  commodityGroupByCommodityGroup: commodity_group_obj_rel_insert_input
  commodity_group: Int
  description: String
  eod_entries: eod_entry_arr_rel_insert_input
  eod_product_dep: uuid
  geographicalRegionByGeographicalRegion: geographical_region_obj_rel_insert_input
  geographical_region: Int
  id: uuid
  kt_kb_conversion_factor: numeric
  local_instruments: local_instrument_arr_rel_insert_input
  logical_code: String
  maturity: product_maturity_enum
  name: String
  package: Int
  packageByPackage: package_obj_rel_insert_input
  productEodsByEodProduct: product_eod_arr_rel_insert_input
  productTypeByProductType: product_type_obj_rel_insert_input
  product_artis_type: product_artis_type_obj_rel_insert_input
  product_configs: product_config_arr_rel_insert_input
  product_eods: product_eod_arr_rel_insert_input
  product_global_dependencies: product_global_dependencies_arr_rel_insert_input
  product_maturity: product_maturity_obj_rel_insert_input
  product_overrides: product_overrides_arr_rel_insert_input
  product_summary_type: product_summary_type_obj_rel_insert_input
  product_type: product_type_enum
  product_uom: product_uom_obj_rel_insert_input
  shared_instruments: shared_instrument_arr_rel_insert_input
  summary_type: product_summary_type_enum
  uom: product_uom_enum
}

"""
columns and relationships of "product_maturity"
"""
type product_maturity {
  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "product_maturity"
"""
type product_maturity_aggregate {
  aggregate: product_maturity_aggregate_fields
  nodes: [product_maturity!]!
}

"""
aggregate fields of "product_maturity"
"""
type product_maturity_aggregate_fields {
  count(columns: [product_maturity_select_column!], distinct: Boolean): Int!
  max: product_maturity_max_fields
  min: product_maturity_min_fields
}

"""
Boolean expression to filter rows from the table "product_maturity". All fields are combined with a logical 'AND'.
"""
input product_maturity_bool_exp {
  _and: [product_maturity_bool_exp!]
  _not: product_maturity_bool_exp
  _or: [product_maturity_bool_exp!]
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_maturity"
"""
enum product_maturity_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_maturity_pkey
}

enum product_maturity_enum {
  future
  inter_month_spreads
  monthly
}

"""
Boolean expression to compare columns of type "product_maturity_enum". All fields are combined with logical 'AND'.
"""
input product_maturity_enum_comparison_exp {
  _eq: product_maturity_enum
  _in: [product_maturity_enum!]
  _is_null: Boolean
  _neq: product_maturity_enum
  _nin: [product_maturity_enum!]
}

"""
input type for inserting data into table "product_maturity"
"""
input product_maturity_insert_input {
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_maturity_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_maturity_min_fields {
  value: String
}

"""
response of any mutation on the table "product_maturity"
"""
type product_maturity_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_maturity!]!
}

"""
input type for inserting object relation for remote table "product_maturity"
"""
input product_maturity_obj_rel_insert_input {
  data: product_maturity_insert_input!

  """upsert condition"""
  on_conflict: product_maturity_on_conflict
}

"""
on_conflict condition type for table "product_maturity"
"""
input product_maturity_on_conflict {
  constraint: product_maturity_constraint!
  update_columns: [product_maturity_update_column!]! = []
  where: product_maturity_bool_exp
}

"""Ordering options when selecting data from "product_maturity"."""
input product_maturity_order_by {
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_maturity"""
input product_maturity_pk_columns_input {
  value: String!
}

"""
select columns of table "product_maturity"
"""
enum product_maturity_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_maturity"
"""
input product_maturity_set_input {
  value: String
}

"""
Streaming cursor of the table "product_maturity"
"""
input product_maturity_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_maturity_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_maturity_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_maturity"
"""
enum product_maturity_update_column {
  """column name"""
  value
}

input product_maturity_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_maturity_set_input

  """filter the rows which have to be updated"""
  where: product_maturity_bool_exp!
}

"""aggregate max on columns"""
type product_max_fields {
  code: String
  commodity_group: Int
  description: String
  eod_product_dep: uuid
  geographical_region: Int
  id: uuid
  kt_kb_conversion_factor: numeric
  logical_code: String
  name: String
  package: Int

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by max() on columns of table "product"
"""
input product_max_order_by {
  code: order_by
  commodity_group: order_by
  description: order_by
  eod_product_dep: order_by
  geographical_region: order_by
  id: order_by
  kt_kb_conversion_factor: order_by
  logical_code: order_by
  name: order_by
  package: order_by
}

"""aggregate min on columns"""
type product_min_fields {
  code: String
  commodity_group: Int
  description: String
  eod_product_dep: uuid
  geographical_region: Int
  id: uuid
  kt_kb_conversion_factor: numeric
  logical_code: String
  name: String
  package: Int

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by min() on columns of table "product"
"""
input product_min_order_by {
  code: order_by
  commodity_group: order_by
  description: order_by
  eod_product_dep: order_by
  geographical_region: order_by
  id: order_by
  kt_kb_conversion_factor: order_by
  logical_code: order_by
  name: order_by
  package: order_by
}

"""
response of any mutation on the table "product"
"""
type product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product!]!
}

"""
input type for inserting object relation for remote table "product"
"""
input product_obj_rel_insert_input {
  data: product_insert_input!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""
on_conflict condition type for table "product"
"""
input product_on_conflict {
  constraint: product_constraint!
  update_columns: [product_update_column!]! = []
  where: product_bool_exp
}

"""Ordering options when selecting data from "product"."""
input product_order_by {
  artis_type: order_by
  code: order_by
  commodityGroupByCommodityGroup: commodity_group_order_by
  commodity_group: order_by
  description: order_by
  eod_entries_aggregate: eod_entry_aggregate_order_by
  eod_product_dep: order_by
  geographicalRegionByGeographicalRegion: geographical_region_order_by
  geographical_region: order_by
  has_shared_cell: order_by
  id: order_by
  kt_kb_conversion_factor: order_by
  last_shared_aggregate: shared_instrument_aggregate_order_by
  local_instruments_aggregate: local_instrument_aggregate_order_by
  logical_code: order_by
  maturity: order_by
  name: order_by
  package: order_by
  packageByPackage: package_order_by
  productEodsByEodProduct_aggregate: product_eod_aggregate_order_by
  productTypeByProductType: product_type_order_by
  product_artis_type: product_artis_type_order_by
  product_configs_aggregate: product_config_aggregate_order_by
  product_eods_aggregate: product_eod_aggregate_order_by
  product_global_dependencies_aggregate: product_global_dependencies_aggregate_order_by
  product_maturity: product_maturity_order_by
  product_overrides_aggregate: product_overrides_aggregate_order_by
  product_summary_type: product_summary_type_order_by
  product_type: order_by
  product_uom: product_uom_order_by
  shared_instrument_count: order_by
  shared_instruments_aggregate: shared_instrument_aggregate_order_by
  summary_type: order_by
  uom: order_by
}

"""
columns and relationships of "product_overrides"
"""
type product_overrides {
  """An object relationship"""
  commodityGroupByCommodityGroup: commodity_group
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String

  """An object relationship"""
  geographicalRegionByGeographicalRegion: geographical_region
  geographical_region: Int
  id: Int!
  name: String!
  organisation: Int!

  """An object relationship"""
  organisationByOrganisation: organisation!
  product: uuid!

  """An object relationship"""
  productByProduct: product!
}

"""
aggregated selection of "product_overrides"
"""
type product_overrides_aggregate {
  aggregate: product_overrides_aggregate_fields
  nodes: [product_overrides!]!
}

input product_overrides_aggregate_bool_exp {
  count: product_overrides_aggregate_bool_exp_count
}

input product_overrides_aggregate_bool_exp_count {
  arguments: [product_overrides_select_column!]
  distinct: Boolean
  filter: product_overrides_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_overrides"
"""
type product_overrides_aggregate_fields {
  avg: product_overrides_avg_fields
  count(columns: [product_overrides_select_column!], distinct: Boolean): Int!
  max: product_overrides_max_fields
  min: product_overrides_min_fields
  stddev: product_overrides_stddev_fields
  stddev_pop: product_overrides_stddev_pop_fields
  stddev_samp: product_overrides_stddev_samp_fields
  sum: product_overrides_sum_fields
  var_pop: product_overrides_var_pop_fields
  var_samp: product_overrides_var_samp_fields
  variance: product_overrides_variance_fields
}

"""
order by aggregate values of table "product_overrides"
"""
input product_overrides_aggregate_order_by {
  avg: product_overrides_avg_order_by
  count: order_by
  max: product_overrides_max_order_by
  min: product_overrides_min_order_by
  stddev: product_overrides_stddev_order_by
  stddev_pop: product_overrides_stddev_pop_order_by
  stddev_samp: product_overrides_stddev_samp_order_by
  sum: product_overrides_sum_order_by
  var_pop: product_overrides_var_pop_order_by
  var_samp: product_overrides_var_samp_order_by
  variance: product_overrides_variance_order_by
}

"""
input type for inserting array relation for remote table "product_overrides"
"""
input product_overrides_arr_rel_insert_input {
  data: [product_overrides_insert_input!]!

  """upsert condition"""
  on_conflict: product_overrides_on_conflict
}

"""aggregate avg on columns"""
type product_overrides_avg_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by avg() on columns of table "product_overrides"
"""
input product_overrides_avg_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""
Boolean expression to filter rows from the table "product_overrides". All fields are combined with a logical 'AND'.
"""
input product_overrides_bool_exp {
  _and: [product_overrides_bool_exp!]
  _not: product_overrides_bool_exp
  _or: [product_overrides_bool_exp!]
  commodityGroupByCommodityGroup: commodity_group_bool_exp
  commodity_group: Int_comparison_exp
  custom_group1: String_comparison_exp
  custom_group2: String_comparison_exp
  custom_group3: String_comparison_exp
  description: String_comparison_exp
  geographicalRegionByGeographicalRegion: geographical_region_bool_exp
  geographical_region: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  organisation: Int_comparison_exp
  organisationByOrganisation: organisation_bool_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
}

"""
unique or primary key constraints on table "product_overrides"
"""
enum product_overrides_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_overrides_id_key

  """
  unique or primary key constraint on columns "organisation", "name"
  """
  product_overrides_name_organisation_key

  """
  unique or primary key constraint on columns "product", "organisation"
  """
  product_overrides_pkey
}

"""
input type for incrementing numeric columns in table "product_overrides"
"""
input product_overrides_inc_input {
  commodity_group: Int
  geographical_region: Int
  id: Int
  organisation: Int
}

"""
input type for inserting data into table "product_overrides"
"""
input product_overrides_insert_input {
  commodityGroupByCommodityGroup: commodity_group_obj_rel_insert_input
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String
  geographicalRegionByGeographicalRegion: geographical_region_obj_rel_insert_input
  geographical_region: Int
  id: Int
  name: String
  organisation: Int
  organisationByOrganisation: organisation_obj_rel_insert_input
  product: uuid
  productByProduct: product_obj_rel_insert_input
}

"""aggregate max on columns"""
type product_overrides_max_fields {
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String
  geographical_region: Int
  id: Int
  name: String
  organisation: Int
  product: uuid
}

"""
order by max() on columns of table "product_overrides"
"""
input product_overrides_max_order_by {
  commodity_group: order_by
  custom_group1: order_by
  custom_group2: order_by
  custom_group3: order_by
  description: order_by
  geographical_region: order_by
  id: order_by
  name: order_by
  organisation: order_by
  product: order_by
}

"""aggregate min on columns"""
type product_overrides_min_fields {
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String
  geographical_region: Int
  id: Int
  name: String
  organisation: Int
  product: uuid
}

"""
order by min() on columns of table "product_overrides"
"""
input product_overrides_min_order_by {
  commodity_group: order_by
  custom_group1: order_by
  custom_group2: order_by
  custom_group3: order_by
  description: order_by
  geographical_region: order_by
  id: order_by
  name: order_by
  organisation: order_by
  product: order_by
}

"""
response of any mutation on the table "product_overrides"
"""
type product_overrides_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_overrides!]!
}

"""
on_conflict condition type for table "product_overrides"
"""
input product_overrides_on_conflict {
  constraint: product_overrides_constraint!
  update_columns: [product_overrides_update_column!]! = []
  where: product_overrides_bool_exp
}

"""Ordering options when selecting data from "product_overrides"."""
input product_overrides_order_by {
  commodityGroupByCommodityGroup: commodity_group_order_by
  commodity_group: order_by
  custom_group1: order_by
  custom_group2: order_by
  custom_group3: order_by
  description: order_by
  geographicalRegionByGeographicalRegion: geographical_region_order_by
  geographical_region: order_by
  id: order_by
  name: order_by
  organisation: order_by
  organisationByOrganisation: organisation_order_by
  product: order_by
  productByProduct: product_order_by
}

"""primary key columns input for table: product_overrides"""
input product_overrides_pk_columns_input {
  organisation: Int!
  product: uuid!
}

"""
select columns of table "product_overrides"
"""
enum product_overrides_select_column {
  """column name"""
  commodity_group

  """column name"""
  custom_group1

  """column name"""
  custom_group2

  """column name"""
  custom_group3

  """column name"""
  description

  """column name"""
  geographical_region

  """column name"""
  id

  """column name"""
  name

  """column name"""
  organisation

  """column name"""
  product
}

"""
input type for updating data in table "product_overrides"
"""
input product_overrides_set_input {
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String
  geographical_region: Int
  id: Int
  name: String
  organisation: Int
  product: uuid
}

"""aggregate stddev on columns"""
type product_overrides_stddev_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by stddev() on columns of table "product_overrides"
"""
input product_overrides_stddev_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""aggregate stddev_pop on columns"""
type product_overrides_stddev_pop_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by stddev_pop() on columns of table "product_overrides"
"""
input product_overrides_stddev_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""aggregate stddev_samp on columns"""
type product_overrides_stddev_samp_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by stddev_samp() on columns of table "product_overrides"
"""
input product_overrides_stddev_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""
Streaming cursor of the table "product_overrides"
"""
input product_overrides_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_overrides_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_overrides_stream_cursor_value_input {
  commodity_group: Int
  custom_group1: String
  custom_group2: String
  custom_group3: String
  description: String
  geographical_region: Int
  id: Int
  name: String
  organisation: Int
  product: uuid
}

"""aggregate sum on columns"""
type product_overrides_sum_fields {
  commodity_group: Int
  geographical_region: Int
  id: Int
  organisation: Int
}

"""
order by sum() on columns of table "product_overrides"
"""
input product_overrides_sum_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""
update columns of table "product_overrides"
"""
enum product_overrides_update_column {
  """column name"""
  commodity_group

  """column name"""
  custom_group1

  """column name"""
  custom_group2

  """column name"""
  custom_group3

  """column name"""
  description

  """column name"""
  geographical_region

  """column name"""
  id

  """column name"""
  name

  """column name"""
  organisation

  """column name"""
  product
}

input product_overrides_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_overrides_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_overrides_set_input

  """filter the rows which have to be updated"""
  where: product_overrides_bool_exp!
}

"""aggregate var_pop on columns"""
type product_overrides_var_pop_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by var_pop() on columns of table "product_overrides"
"""
input product_overrides_var_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""aggregate var_samp on columns"""
type product_overrides_var_samp_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by var_samp() on columns of table "product_overrides"
"""
input product_overrides_var_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""aggregate variance on columns"""
type product_overrides_variance_fields {
  commodity_group: Float
  geographical_region: Float
  id: Float
  organisation: Float
}

"""
order by variance() on columns of table "product_overrides"
"""
input product_overrides_variance_order_by {
  commodity_group: order_by
  geographical_region: order_by
  id: order_by
  organisation: order_by
}

"""primary key columns input for table: product"""
input product_pk_columns_input {
  id: uuid!
}

"""
select columns of table "product"
"""
enum product_select_column {
  """column name"""
  artis_type

  """column name"""
  code

  """column name"""
  commodity_group

  """column name"""
  description

  """column name"""
  eod_product_dep

  """column name"""
  geographical_region

  """column name"""
  id

  """column name"""
  kt_kb_conversion_factor

  """column name"""
  logical_code

  """column name"""
  maturity

  """column name"""
  name

  """column name"""
  package

  """column name"""
  product_type

  """column name"""
  summary_type

  """column name"""
  uom
}

"""
input type for updating data in table "product"
"""
input product_set_input {
  artis_type: product_artis_type_enum
  code: String
  commodity_group: Int
  description: String
  eod_product_dep: uuid
  geographical_region: Int
  id: uuid
  kt_kb_conversion_factor: numeric
  logical_code: String
  maturity: product_maturity_enum
  name: String
  package: Int
  product_type: product_type_enum
  summary_type: product_summary_type_enum
  uom: product_uom_enum
}

"""
columns and relationships of "product_source"
"""
type product_source {
  """An array relationship"""
  sources(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): [source!]!

  """An aggregate relationship"""
  sources_aggregate(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): source_aggregate!
  value: String!
}

"""
aggregated selection of "product_source"
"""
type product_source_aggregate {
  aggregate: product_source_aggregate_fields
  nodes: [product_source!]!
}

"""
aggregate fields of "product_source"
"""
type product_source_aggregate_fields {
  count(columns: [product_source_select_column!], distinct: Boolean): Int!
  max: product_source_max_fields
  min: product_source_min_fields
}

"""
Boolean expression to filter rows from the table "product_source". All fields are combined with a logical 'AND'.
"""
input product_source_bool_exp {
  _and: [product_source_bool_exp!]
  _not: product_source_bool_exp
  _or: [product_source_bool_exp!]
  sources: source_bool_exp
  sources_aggregate: source_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_source"
"""
enum product_source_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_source_pkey
}

enum product_source_enum {
  eod
  exchange
  global
  organisation
}

"""
Boolean expression to compare columns of type "product_source_enum". All fields are combined with logical 'AND'.
"""
input product_source_enum_comparison_exp {
  _eq: product_source_enum
  _in: [product_source_enum!]
  _is_null: Boolean
  _neq: product_source_enum
  _nin: [product_source_enum!]
}

"""
input type for inserting data into table "product_source"
"""
input product_source_insert_input {
  sources: source_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_source_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_source_min_fields {
  value: String
}

"""
response of any mutation on the table "product_source"
"""
type product_source_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_source!]!
}

"""
input type for inserting object relation for remote table "product_source"
"""
input product_source_obj_rel_insert_input {
  data: product_source_insert_input!

  """upsert condition"""
  on_conflict: product_source_on_conflict
}

"""
on_conflict condition type for table "product_source"
"""
input product_source_on_conflict {
  constraint: product_source_constraint!
  update_columns: [product_source_update_column!]! = []
  where: product_source_bool_exp
}

"""Ordering options when selecting data from "product_source"."""
input product_source_order_by {
  sources_aggregate: source_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_source"""
input product_source_pk_columns_input {
  value: String!
}

"""
select columns of table "product_source"
"""
enum product_source_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_source"
"""
input product_source_set_input {
  value: String
}

"""
Streaming cursor of the table "product_source"
"""
input product_source_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_source_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_source_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_source"
"""
enum product_source_update_column {
  """column name"""
  value
}

input product_source_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_source_set_input

  """filter the rows which have to be updated"""
  where: product_source_bool_exp!
}

"""aggregate stddev on columns"""
type product_stddev_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by stddev() on columns of table "product"
"""
input product_stddev_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""aggregate stddev_pop on columns"""
type product_stddev_pop_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by stddev_pop() on columns of table "product"
"""
input product_stddev_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""aggregate stddev_samp on columns"""
type product_stddev_samp_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by stddev_samp() on columns of table "product"
"""
input product_stddev_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""
Streaming cursor of the table "product"
"""
input product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_stream_cursor_value_input {
  artis_type: product_artis_type_enum
  code: String
  commodity_group: Int
  description: String
  eod_product_dep: uuid
  geographical_region: Int
  id: uuid
  kt_kb_conversion_factor: numeric
  logical_code: String
  maturity: product_maturity_enum
  name: String
  package: Int
  product_type: product_type_enum
  summary_type: product_summary_type_enum
  uom: product_uom_enum
}

"""aggregate sum on columns"""
type product_sum_fields {
  commodity_group: Int
  geographical_region: Int
  kt_kb_conversion_factor: numeric
  package: Int

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by sum() on columns of table "product"
"""
input product_sum_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""
columns and relationships of "product_summary_type"
"""
type product_summary_type {
  """An array relationship"""
  summary_types(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  summary_types_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "product_summary_type"
"""
type product_summary_type_aggregate {
  aggregate: product_summary_type_aggregate_fields
  nodes: [product_summary_type!]!
}

"""
aggregate fields of "product_summary_type"
"""
type product_summary_type_aggregate_fields {
  count(columns: [product_summary_type_select_column!], distinct: Boolean): Int!
  max: product_summary_type_max_fields
  min: product_summary_type_min_fields
}

"""
Boolean expression to filter rows from the table "product_summary_type". All fields are combined with a logical 'AND'.
"""
input product_summary_type_bool_exp {
  _and: [product_summary_type_bool_exp!]
  _not: product_summary_type_bool_exp
  _or: [product_summary_type_bool_exp!]
  summary_types: product_bool_exp
  summary_types_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_summary_type"
"""
enum product_summary_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_summary_type_pkey
}

enum product_summary_type_enum {
  average
  none
  sum
  timespread
}

"""
Boolean expression to compare columns of type "product_summary_type_enum". All fields are combined with logical 'AND'.
"""
input product_summary_type_enum_comparison_exp {
  _eq: product_summary_type_enum
  _in: [product_summary_type_enum!]
  _is_null: Boolean
  _neq: product_summary_type_enum
  _nin: [product_summary_type_enum!]
}

"""
input type for inserting data into table "product_summary_type"
"""
input product_summary_type_insert_input {
  summary_types: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_summary_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_summary_type_min_fields {
  value: String
}

"""
response of any mutation on the table "product_summary_type"
"""
type product_summary_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_summary_type!]!
}

"""
input type for inserting object relation for remote table "product_summary_type"
"""
input product_summary_type_obj_rel_insert_input {
  data: product_summary_type_insert_input!

  """upsert condition"""
  on_conflict: product_summary_type_on_conflict
}

"""
on_conflict condition type for table "product_summary_type"
"""
input product_summary_type_on_conflict {
  constraint: product_summary_type_constraint!
  update_columns: [product_summary_type_update_column!]! = []
  where: product_summary_type_bool_exp
}

"""Ordering options when selecting data from "product_summary_type"."""
input product_summary_type_order_by {
  summary_types_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_summary_type"""
input product_summary_type_pk_columns_input {
  value: String!
}

"""
select columns of table "product_summary_type"
"""
enum product_summary_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_summary_type"
"""
input product_summary_type_set_input {
  value: String
}

"""
Streaming cursor of the table "product_summary_type"
"""
input product_summary_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_summary_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_summary_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_summary_type"
"""
enum product_summary_type_update_column {
  """column name"""
  value
}

input product_summary_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_summary_type_set_input

  """filter the rows which have to be updated"""
  where: product_summary_type_bool_exp!
}

"""
columns and relationships of "product_type"
"""
type product_type {
  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "product_type"
"""
type product_type_aggregate {
  aggregate: product_type_aggregate_fields
  nodes: [product_type!]!
}

"""
aggregate fields of "product_type"
"""
type product_type_aggregate_fields {
  count(columns: [product_type_select_column!], distinct: Boolean): Int!
  max: product_type_max_fields
  min: product_type_min_fields
}

"""
Boolean expression to filter rows from the table "product_type". All fields are combined with a logical 'AND'.
"""
input product_type_bool_exp {
  _and: [product_type_bool_exp!]
  _not: product_type_bool_exp
  _or: [product_type_bool_exp!]
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_type"
"""
enum product_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_type_pkey
}

enum product_type_enum {
  box
  change
  diff
  outright
  timespread
}

"""
Boolean expression to compare columns of type "product_type_enum". All fields are combined with logical 'AND'.
"""
input product_type_enum_comparison_exp {
  _eq: product_type_enum
  _in: [product_type_enum!]
  _is_null: Boolean
  _neq: product_type_enum
  _nin: [product_type_enum!]
}

"""
input type for inserting data into table "product_type"
"""
input product_type_insert_input {
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_type_min_fields {
  value: String
}

"""
response of any mutation on the table "product_type"
"""
type product_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_type!]!
}

"""
input type for inserting object relation for remote table "product_type"
"""
input product_type_obj_rel_insert_input {
  data: product_type_insert_input!

  """upsert condition"""
  on_conflict: product_type_on_conflict
}

"""
on_conflict condition type for table "product_type"
"""
input product_type_on_conflict {
  constraint: product_type_constraint!
  update_columns: [product_type_update_column!]! = []
  where: product_type_bool_exp
}

"""Ordering options when selecting data from "product_type"."""
input product_type_order_by {
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_type"""
input product_type_pk_columns_input {
  value: String!
}

"""
select columns of table "product_type"
"""
enum product_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_type"
"""
input product_type_set_input {
  value: String
}

"""
Streaming cursor of the table "product_type"
"""
input product_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_type"
"""
enum product_type_update_column {
  """column name"""
  value
}

input product_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_type_set_input

  """filter the rows which have to be updated"""
  where: product_type_bool_exp!
}

"""
columns and relationships of "product_uom"
"""
type product_uom {
  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "product_uom"
"""
type product_uom_aggregate {
  aggregate: product_uom_aggregate_fields
  nodes: [product_uom!]!
}

"""
aggregate fields of "product_uom"
"""
type product_uom_aggregate_fields {
  count(columns: [product_uom_select_column!], distinct: Boolean): Int!
  max: product_uom_max_fields
  min: product_uom_min_fields
}

"""
Boolean expression to filter rows from the table "product_uom". All fields are combined with a logical 'AND'.
"""
input product_uom_bool_exp {
  _and: [product_uom_bool_exp!]
  _not: product_uom_bool_exp
  _or: [product_uom_bool_exp!]
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "product_uom"
"""
enum product_uom_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  product_uom_pkey
}

enum product_uom_enum {
  days
  eur
  eur_mt
  eur_mwh
  flatr
  gbp
  gbp_mt
  kb
  kbd
  kcbm
  kg_m3
  kgal
  kt
  lots
  none
  p_thm
  percent
  usc_bbl
  usc_gal
  usd
  usd_bbl
  usd_day
  usd_gal
  usd_mmbtu
  usd_thousands
  usd_ton
  usdmm
  ws
}

"""
Boolean expression to compare columns of type "product_uom_enum". All fields are combined with logical 'AND'.
"""
input product_uom_enum_comparison_exp {
  _eq: product_uom_enum
  _in: [product_uom_enum!]
  _is_null: Boolean
  _neq: product_uom_enum
  _nin: [product_uom_enum!]
}

"""
input type for inserting data into table "product_uom"
"""
input product_uom_insert_input {
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type product_uom_max_fields {
  value: String
}

"""aggregate min on columns"""
type product_uom_min_fields {
  value: String
}

"""
response of any mutation on the table "product_uom"
"""
type product_uom_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_uom!]!
}

"""
input type for inserting object relation for remote table "product_uom"
"""
input product_uom_obj_rel_insert_input {
  data: product_uom_insert_input!

  """upsert condition"""
  on_conflict: product_uom_on_conflict
}

"""
on_conflict condition type for table "product_uom"
"""
input product_uom_on_conflict {
  constraint: product_uom_constraint!
  update_columns: [product_uom_update_column!]! = []
  where: product_uom_bool_exp
}

"""Ordering options when selecting data from "product_uom"."""
input product_uom_order_by {
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: product_uom"""
input product_uom_pk_columns_input {
  value: String!
}

"""
select columns of table "product_uom"
"""
enum product_uom_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "product_uom"
"""
input product_uom_set_input {
  value: String
}

"""
Streaming cursor of the table "product_uom"
"""
input product_uom_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_uom_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_uom_stream_cursor_value_input {
  value: String
}

"""
update columns of table "product_uom"
"""
enum product_uom_update_column {
  """column name"""
  value
}

input product_uom_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: product_uom_set_input

  """filter the rows which have to be updated"""
  where: product_uom_bool_exp!
}

"""
update columns of table "product"
"""
enum product_update_column {
  """column name"""
  artis_type

  """column name"""
  code

  """column name"""
  commodity_group

  """column name"""
  description

  """column name"""
  eod_product_dep

  """column name"""
  geographical_region

  """column name"""
  id

  """column name"""
  kt_kb_conversion_factor

  """column name"""
  logical_code

  """column name"""
  maturity

  """column name"""
  name

  """column name"""
  package

  """column name"""
  product_type

  """column name"""
  summary_type

  """column name"""
  uom
}

input product_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_set_input

  """filter the rows which have to be updated"""
  where: product_bool_exp!
}

"""aggregate var_pop on columns"""
type product_var_pop_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by var_pop() on columns of table "product"
"""
input product_var_pop_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""aggregate var_samp on columns"""
type product_var_samp_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by var_samp() on columns of table "product"
"""
input product_var_samp_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

"""aggregate variance on columns"""
type product_variance_fields {
  commodity_group: Float
  geographical_region: Float
  kt_kb_conversion_factor: Float
  package: Float

  """Gets number of shared_instruments"""
  shared_instrument_count: bigint
}

"""
order by variance() on columns of table "product"
"""
input product_variance_order_by {
  commodity_group: order_by
  geographical_region: order_by
  kt_kb_conversion_factor: order_by
  package: order_by
}

type query_root {
  """
  fetch data from the table: "audit.logged_actions"
  """
  audit_logged_actions(
    """distinct select on columns"""
    distinct_on: [audit_logged_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logged_actions_order_by!]

    """filter the rows returned"""
    where: audit_logged_actions_bool_exp
  ): [audit_logged_actions!]!

  """
  fetch aggregated fields from the table: "audit.logged_actions"
  """
  audit_logged_actions_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logged_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logged_actions_order_by!]

    """filter the rows returned"""
    where: audit_logged_actions_bool_exp
  ): audit_logged_actions_aggregate!

  """
  fetch data from the table: "audit.logged_actions" using primary key columns
  """
  audit_logged_actions_by_pk(
    """Unique identifier for each auditable event"""
    event_id: bigint!
  ): audit_logged_actions

  """
  fetch data from the table: "audit.umi_actions"
  """
  audit_umi_actions(
    """distinct select on columns"""
    distinct_on: [audit_umi_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_umi_actions_order_by!]

    """filter the rows returned"""
    where: audit_umi_actions_bool_exp
  ): [audit_umi_actions!]!

  """
  fetch aggregated fields from the table: "audit.umi_actions"
  """
  audit_umi_actions_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_umi_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_umi_actions_order_by!]

    """filter the rows returned"""
    where: audit_umi_actions_bool_exp
  ): audit_umi_actions_aggregate!

  """
  fetch data from the table: "audit.umi_actions" using primary key columns
  """
  audit_umi_actions_by_pk(id: Int!): audit_umi_actions

  """
  fetch data from the table: "commodity_group"
  """
  commodity_group(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): [commodity_group!]!

  """
  fetch aggregated fields from the table: "commodity_group"
  """
  commodity_group_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): commodity_group_aggregate!

  """fetch data from the table: "commodity_group" using primary key columns"""
  commodity_group_by_pk(id: Int!): commodity_group

  """
  fetch data from the table: "commodity_parent_group"
  """
  commodity_parent_group(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): [commodity_parent_group!]!

  """
  fetch aggregated fields from the table: "commodity_parent_group"
  """
  commodity_parent_group_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): commodity_parent_group_aggregate!

  """
  fetch data from the table: "commodity_parent_group" using primary key columns
  """
  commodity_parent_group_by_pk(id: Int!): commodity_parent_group

  """
  fetch data from the table: "eod"
  """
  eod(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): [eod!]!

  """
  fetch aggregated fields from the table: "eod"
  """
  eod_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): eod_aggregate!

  """fetch data from the table: "eod" using primary key columns"""
  eod_by_pk(id: Int!): eod

  """
  fetch data from the table: "eod_entry"
  """
  eod_entry(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): [eod_entry!]!

  """
  fetch aggregated fields from the table: "eod_entry"
  """
  eod_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): eod_entry_aggregate!

  """fetch data from the table: "eod_entry" using primary key columns"""
  eod_entry_by_pk(evaluation_date: date!, month: date!, product: uuid!): eod_entry

  """
  fetch data from the table: "eod_entry_per_eval_date_mview"
  """
  eod_entry_per_eval_date_mview(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_mview_bool_exp
  ): [eod_entry_per_eval_date_mview!]!

  """
  fetch aggregated fields from the table: "eod_entry_per_eval_date_mview"
  """
  eod_entry_per_eval_date_mview_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_mview_bool_exp
  ): eod_entry_per_eval_date_mview_aggregate!

  """
  fetch data from the table: "eod_entry_per_eval_date_package_mview"
  """
  eod_entry_per_eval_date_package_mview(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_package_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_package_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_package_mview_bool_exp
  ): [eod_entry_per_eval_date_package_mview!]!

  """
  fetch aggregated fields from the table: "eod_entry_per_eval_date_package_mview"
  """
  eod_entry_per_eval_date_package_mview_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_package_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_package_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_package_mview_bool_exp
  ): eod_entry_per_eval_date_package_mview_aggregate!

  """
  fetch data from the table: "exchange"
  """
  exchange(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): [exchange!]!

  """
  fetch aggregated fields from the table: "exchange"
  """
  exchange_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): exchange_aggregate!

  """fetch data from the table: "exchange" using primary key columns"""
  exchange_by_pk(id: Int!): exchange

  """
  fetch data from the table: "exchange_event_type"
  """
  exchange_event_type(
    """distinct select on columns"""
    distinct_on: [exchange_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_event_type_order_by!]

    """filter the rows returned"""
    where: exchange_event_type_bool_exp
  ): [exchange_event_type!]!

  """
  fetch aggregated fields from the table: "exchange_event_type"
  """
  exchange_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_event_type_order_by!]

    """filter the rows returned"""
    where: exchange_event_type_bool_exp
  ): exchange_event_type_aggregate!

  """
  fetch data from the table: "exchange_event_type" using primary key columns
  """
  exchange_event_type_by_pk(value: String!): exchange_event_type

  """
  fetch data from the table: "exchange_usage"
  """
  exchange_usage(
    """distinct select on columns"""
    distinct_on: [exchange_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_order_by!]

    """filter the rows returned"""
    where: exchange_usage_bool_exp
  ): [exchange_usage!]!

  """
  fetch aggregated fields from the table: "exchange_usage"
  """
  exchange_usage_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_order_by!]

    """filter the rows returned"""
    where: exchange_usage_bool_exp
  ): exchange_usage_aggregate!

  """fetch data from the table: "exchange_usage" using primary key columns"""
  exchange_usage_by_pk(id: Int!): exchange_usage

  """
  fetch data from the table: "exchange_usage_last"
  """
  exchange_usage_last(
    """distinct select on columns"""
    distinct_on: [exchange_usage_last_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_last_order_by!]

    """filter the rows returned"""
    where: exchange_usage_last_bool_exp
  ): [exchange_usage_last!]!

  """
  fetch aggregated fields from the table: "exchange_usage_last"
  """
  exchange_usage_last_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_last_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_last_order_by!]

    """filter the rows returned"""
    where: exchange_usage_last_bool_exp
  ): exchange_usage_last_aggregate!

  """
  fetch data from the table: "exchange_usage_start"
  """
  exchange_usage_start(
    """distinct select on columns"""
    distinct_on: [exchange_usage_start_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_start_order_by!]

    """filter the rows returned"""
    where: exchange_usage_start_bool_exp
  ): [exchange_usage_start!]!

  """
  fetch aggregated fields from the table: "exchange_usage_start"
  """
  exchange_usage_start_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_start_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_start_order_by!]

    """filter the rows returned"""
    where: exchange_usage_start_bool_exp
  ): exchange_usage_start_aggregate!

  """
  fetch data from the table: "folio_column_settings"
  """
  folio_column_settings(
    """distinct select on columns"""
    distinct_on: [folio_column_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_column_settings_order_by!]

    """filter the rows returned"""
    where: folio_column_settings_bool_exp
  ): [folio_column_settings!]!

  """
  fetch aggregated fields from the table: "folio_column_settings"
  """
  folio_column_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_column_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_column_settings_order_by!]

    """filter the rows returned"""
    where: folio_column_settings_bool_exp
  ): folio_column_settings_aggregate!

  """
  fetch data from the table: "folio_column_settings" using primary key columns
  """
  folio_column_settings_by_pk(folio_user: String!): folio_column_settings

  """
  fetch data from the table: "folio_shadow_curves"
  """
  folio_shadow_curves(
    """distinct select on columns"""
    distinct_on: [folio_shadow_curves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_shadow_curves_order_by!]

    """filter the rows returned"""
    where: folio_shadow_curves_bool_exp
  ): [folio_shadow_curves!]!

  """
  fetch aggregated fields from the table: "folio_shadow_curves"
  """
  folio_shadow_curves_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_shadow_curves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_shadow_curves_order_by!]

    """filter the rows returned"""
    where: folio_shadow_curves_bool_exp
  ): folio_shadow_curves_aggregate!

  """
  fetch data from the table: "folio_shadow_curves" using primary key columns
  """
  folio_shadow_curves_by_pk(folio_user: String!): folio_shadow_curves

  """
  fetch data from the table: "folio_user"
  """
  folio_user(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): [folio_user!]!

  """
  fetch aggregated fields from the table: "folio_user"
  """
  folio_user_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): folio_user_aggregate!

  """
  fetch data from the table: "folio_user_basic_profile"
  """
  folio_user_basic_profile(
    """distinct select on columns"""
    distinct_on: [folio_user_basic_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_basic_profile_order_by!]

    """filter the rows returned"""
    where: folio_user_basic_profile_bool_exp
  ): [folio_user_basic_profile!]!

  """
  fetch aggregated fields from the table: "folio_user_basic_profile"
  """
  folio_user_basic_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_basic_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_basic_profile_order_by!]

    """filter the rows returned"""
    where: folio_user_basic_profile_bool_exp
  ): folio_user_basic_profile_aggregate!

  """fetch data from the table: "folio_user" using primary key columns"""
  folio_user_by_pk(id: String!): folio_user

  """
  fetch data from the table: "geographical_region"
  """
  geographical_region(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): [geographical_region!]!

  """
  fetch aggregated fields from the table: "geographical_region"
  """
  geographical_region_aggregate(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): geographical_region_aggregate!

  """
  fetch data from the table: "geographical_region" using primary key columns
  """
  geographical_region_by_pk(id: Int!): geographical_region

  """
  fetch data from the table: "global_instrument"
  """
  global_instrument(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): [global_instrument!]!

  """
  fetch aggregated fields from the table: "global_instrument"
  """
  global_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): global_instrument_aggregate!

  """
  fetch data from the table: "global_instrument" using primary key columns
  """
  global_instrument_by_pk(global_product: uuid!, month: date!): global_instrument

  """
  fetch data from the table: "global_package"
  """
  global_package(
    """distinct select on columns"""
    distinct_on: [global_package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_package_order_by!]

    """filter the rows returned"""
    where: global_package_bool_exp
  ): [global_package!]!

  """
  fetch aggregated fields from the table: "global_package"
  """
  global_package_aggregate(
    """distinct select on columns"""
    distinct_on: [global_package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_package_order_by!]

    """filter the rows returned"""
    where: global_package_bool_exp
  ): global_package_aggregate!

  """fetch data from the table: "global_package" using primary key columns"""
  global_package_by_pk(id: Int!): global_package

  """
  fetch data from the table: "global_permission"
  """
  global_permission(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): [global_permission!]!

  """
  fetch aggregated fields from the table: "global_permission"
  """
  global_permission_aggregate(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): global_permission_aggregate!

  """
  fetch data from the table: "global_permission" using primary key columns
  """
  global_permission_by_pk(folio_user: String!, global_package: Int!): global_permission

  """
  fetch data from the table: "global_product"
  """
  global_product(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): [global_product!]!

  """
  fetch aggregated fields from the table: "global_product"
  """
  global_product_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): global_product_aggregate!

  """fetch data from the table: "global_product" using primary key columns"""
  global_product_by_pk(id: uuid!): global_product

  """
  fetch data from the table: "global_product_config"
  """
  global_product_config(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): [global_product_config!]!

  """
  fetch aggregated fields from the table: "global_product_config"
  """
  global_product_config_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): global_product_config_aggregate!

  """
  fetch data from the table: "global_product_config" using primary key columns
  """
  global_product_config_by_pk(product: uuid!, relative_month: Int!): global_product_config

  """
  fetch data from the table: "hfc_card_settings"
  """
  hfc_card_settings(
    """distinct select on columns"""
    distinct_on: [hfc_card_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_card_settings_order_by!]

    """filter the rows returned"""
    where: hfc_card_settings_bool_exp
  ): [hfc_card_settings!]!

  """
  fetch aggregated fields from the table: "hfc_card_settings"
  """
  hfc_card_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [hfc_card_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_card_settings_order_by!]

    """filter the rows returned"""
    where: hfc_card_settings_bool_exp
  ): hfc_card_settings_aggregate!

  """
  fetch data from the table: "hfc_card_settings" using primary key columns
  """
  hfc_card_settings_by_pk(user: String!): hfc_card_settings

  """
  fetch data from the table: "hfc_user_settings"
  """
  hfc_user_settings(
    """distinct select on columns"""
    distinct_on: [hfc_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_user_settings_order_by!]

    """filter the rows returned"""
    where: hfc_user_settings_bool_exp
  ): [hfc_user_settings!]!

  """
  fetch aggregated fields from the table: "hfc_user_settings"
  """
  hfc_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [hfc_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_user_settings_order_by!]

    """filter the rows returned"""
    where: hfc_user_settings_bool_exp
  ): hfc_user_settings_aggregate!

  """
  fetch data from the table: "hfc_user_settings" using primary key columns
  """
  hfc_user_settings_by_pk(user: String!): hfc_user_settings

  """
  fetch data from the table: "live_users_new"
  """
  live_users_new(
    """distinct select on columns"""
    distinct_on: [live_users_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [live_users_new_order_by!]

    """filter the rows returned"""
    where: live_users_new_bool_exp
  ): [live_users_new!]!

  """
  fetch aggregated fields from the table: "live_users_new"
  """
  live_users_new_aggregate(
    """distinct select on columns"""
    distinct_on: [live_users_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [live_users_new_order_by!]

    """filter the rows returned"""
    where: live_users_new_bool_exp
  ): live_users_new_aggregate!

  """
  fetch data from the table: "local_instrument"
  """
  local_instrument(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): [local_instrument!]!

  """
  fetch aggregated fields from the table: "local_instrument"
  """
  local_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): local_instrument_aggregate!

  """
  fetch data from the table: "local_instrument" using primary key columns
  """
  local_instrument_by_pk(folio_user: String!, month: date!, product: uuid!, storage_type: user_storage_enum!): local_instrument

  """
  fetch data from the table: "logout_request"
  """
  logout_request(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): [logout_request!]!

  """
  fetch aggregated fields from the table: "logout_request"
  """
  logout_request_aggregate(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): logout_request_aggregate!

  """fetch data from the table: "logout_request" using primary key columns"""
  logout_request_by_pk(id: Int!): logout_request

  """
  fetch data from the table: "organisation"
  """
  organisation(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): [organisation!]!

  """
  fetch aggregated fields from the table: "organisation"
  """
  organisation_aggregate(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): organisation_aggregate!

  """fetch data from the table: "organisation" using primary key columns"""
  organisation_by_pk(id: Int!): organisation

  """
  fetch data from the table: "package"
  """
  package(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): [package!]!

  """
  fetch aggregated fields from the table: "package"
  """
  package_aggregate(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): package_aggregate!

  """fetch data from the table: "package" using primary key columns"""
  package_by_pk(id: Int!): package

  """
  fetch data from the table: "package_type"
  """
  package_type(
    """distinct select on columns"""
    distinct_on: [package_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_type_order_by!]

    """filter the rows returned"""
    where: package_type_bool_exp
  ): [package_type!]!

  """
  fetch aggregated fields from the table: "package_type"
  """
  package_type_aggregate(
    """distinct select on columns"""
    distinct_on: [package_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_type_order_by!]

    """filter the rows returned"""
    where: package_type_bool_exp
  ): package_type_aggregate!

  """fetch data from the table: "package_type" using primary key columns"""
  package_type_by_pk(value: String!): package_type

  """An array relationship"""
  page_settings(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): [page_settings!]!

  """An aggregate relationship"""
  page_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): page_settings_aggregate!

  """fetch data from the table: "page_settings" using primary key columns"""
  page_settings_by_pk(folio_user: String!): page_settings

  """
  fetch data from the table: "permission"
  """
  permission(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """
  fetch aggregated fields from the table: "permission"
  """
  permission_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): permission_aggregate!

  """fetch data from the table: "permission" using primary key columns"""
  permission_by_pk(folio_user: String!, package: Int!): permission

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "product_artis_type"
  """
  product_artis_type(
    """distinct select on columns"""
    distinct_on: [product_artis_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_artis_type_order_by!]

    """filter the rows returned"""
    where: product_artis_type_bool_exp
  ): [product_artis_type!]!

  """
  fetch aggregated fields from the table: "product_artis_type"
  """
  product_artis_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_artis_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_artis_type_order_by!]

    """filter the rows returned"""
    where: product_artis_type_bool_exp
  ): product_artis_type_aggregate!

  """
  fetch data from the table: "product_artis_type" using primary key columns
  """
  product_artis_type_by_pk(value: String!): product_artis_type

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: uuid!): product

  """
  fetch data from the table: "product_config"
  """
  product_config(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): [product_config!]!

  """
  fetch aggregated fields from the table: "product_config"
  """
  product_config_aggregate(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): product_config_aggregate!

  """fetch data from the table: "product_config" using primary key columns"""
  product_config_by_pk(product: uuid!, relative_month: Int!): product_config

  """
  fetch data from the table: "product_eod"
  """
  product_eod(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): [product_eod!]!

  """
  fetch aggregated fields from the table: "product_eod"
  """
  product_eod_aggregate(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): product_eod_aggregate!

  """fetch data from the table: "product_eod" using primary key columns"""
  product_eod_by_pk(eod_product: uuid!, product: uuid!): product_eod

  """An array relationship"""
  product_global_dependencies(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): [product_global_dependencies!]!

  """An aggregate relationship"""
  product_global_dependencies_aggregate(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): product_global_dependencies_aggregate!

  """
  fetch data from the table: "product_global_dependencies" using primary key columns
  """
  product_global_dependencies_by_pk(global_product: uuid!, product: uuid!): product_global_dependencies

  """
  fetch data from the table: "product_maturity"
  """
  product_maturity(
    """distinct select on columns"""
    distinct_on: [product_maturity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_maturity_order_by!]

    """filter the rows returned"""
    where: product_maturity_bool_exp
  ): [product_maturity!]!

  """
  fetch aggregated fields from the table: "product_maturity"
  """
  product_maturity_aggregate(
    """distinct select on columns"""
    distinct_on: [product_maturity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_maturity_order_by!]

    """filter the rows returned"""
    where: product_maturity_bool_exp
  ): product_maturity_aggregate!

  """
  fetch data from the table: "product_maturity" using primary key columns
  """
  product_maturity_by_pk(value: String!): product_maturity

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!

  """
  fetch data from the table: "product_overrides" using primary key columns
  """
  product_overrides_by_pk(organisation: Int!, product: uuid!): product_overrides

  """
  fetch data from the table: "product_source"
  """
  product_source(
    """distinct select on columns"""
    distinct_on: [product_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_source_order_by!]

    """filter the rows returned"""
    where: product_source_bool_exp
  ): [product_source!]!

  """
  fetch aggregated fields from the table: "product_source"
  """
  product_source_aggregate(
    """distinct select on columns"""
    distinct_on: [product_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_source_order_by!]

    """filter the rows returned"""
    where: product_source_bool_exp
  ): product_source_aggregate!

  """fetch data from the table: "product_source" using primary key columns"""
  product_source_by_pk(value: String!): product_source

  """
  fetch data from the table: "product_summary_type"
  """
  product_summary_type(
    """distinct select on columns"""
    distinct_on: [product_summary_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_summary_type_order_by!]

    """filter the rows returned"""
    where: product_summary_type_bool_exp
  ): [product_summary_type!]!

  """
  fetch aggregated fields from the table: "product_summary_type"
  """
  product_summary_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_summary_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_summary_type_order_by!]

    """filter the rows returned"""
    where: product_summary_type_bool_exp
  ): product_summary_type_aggregate!

  """
  fetch data from the table: "product_summary_type" using primary key columns
  """
  product_summary_type_by_pk(value: String!): product_summary_type

  """
  fetch data from the table: "product_type"
  """
  product_type(
    """distinct select on columns"""
    distinct_on: [product_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_type_order_by!]

    """filter the rows returned"""
    where: product_type_bool_exp
  ): [product_type!]!

  """
  fetch aggregated fields from the table: "product_type"
  """
  product_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_type_order_by!]

    """filter the rows returned"""
    where: product_type_bool_exp
  ): product_type_aggregate!

  """fetch data from the table: "product_type" using primary key columns"""
  product_type_by_pk(value: String!): product_type

  """
  fetch data from the table: "product_uom"
  """
  product_uom(
    """distinct select on columns"""
    distinct_on: [product_uom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_uom_order_by!]

    """filter the rows returned"""
    where: product_uom_bool_exp
  ): [product_uom!]!

  """
  fetch aggregated fields from the table: "product_uom"
  """
  product_uom_aggregate(
    """distinct select on columns"""
    distinct_on: [product_uom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_uom_order_by!]

    """filter the rows returned"""
    where: product_uom_bool_exp
  ): product_uom_aggregate!

  """fetch data from the table: "product_uom" using primary key columns"""
  product_uom_by_pk(value: String!): product_uom

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(folio_user: String!, is_mobile: Boolean!): session

  """
  fetch data from the table: "session_type"
  """
  session_type(
    """distinct select on columns"""
    distinct_on: [session_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_type_order_by!]

    """filter the rows returned"""
    where: session_type_bool_exp
  ): [session_type!]!

  """
  fetch aggregated fields from the table: "session_type"
  """
  session_type_aggregate(
    """distinct select on columns"""
    distinct_on: [session_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_type_order_by!]

    """filter the rows returned"""
    where: session_type_bool_exp
  ): session_type_aggregate!

  """fetch data from the table: "session_type" using primary key columns"""
  session_type_by_pk(value: String!): session_type

  """
  fetch data from the table: "shared_instrument"
  """
  shared_instrument(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]!

  """
  fetch aggregated fields from the table: "shared_instrument"
  """
  shared_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): shared_instrument_aggregate!

  """
  fetch data from the table: "shared_instrument" using primary key columns
  """
  shared_instrument_by_pk(month: date!, product: uuid!): shared_instrument

  """
  fetch data from the table: "sharing_agreement"
  """
  sharing_agreement(
    """distinct select on columns"""
    distinct_on: [sharing_agreement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sharing_agreement_order_by!]

    """filter the rows returned"""
    where: sharing_agreement_bool_exp
  ): [sharing_agreement!]!

  """
  fetch aggregated fields from the table: "sharing_agreement"
  """
  sharing_agreement_aggregate(
    """distinct select on columns"""
    distinct_on: [sharing_agreement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sharing_agreement_order_by!]

    """filter the rows returned"""
    where: sharing_agreement_bool_exp
  ): sharing_agreement_aggregate!

  """
  fetch data from the table: "sharing_agreement" using primary key columns
  """
  sharing_agreement_by_pk(id: Int!): sharing_agreement

  """
  fetch data from the table: "source"
  """
  source(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): [source!]!

  """
  fetch aggregated fields from the table: "source"
  """
  source_aggregate(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): source_aggregate!

  """fetch data from the table: "source" using primary key columns"""
  source_by_pk(id: Int!): source

  """
  fetch data from the table: "user_right"
  """
  user_right(
    """distinct select on columns"""
    distinct_on: [user_right_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_right_order_by!]

    """filter the rows returned"""
    where: user_right_bool_exp
  ): [user_right!]!

  """
  fetch aggregated fields from the table: "user_right"
  """
  user_right_aggregate(
    """distinct select on columns"""
    distinct_on: [user_right_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_right_order_by!]

    """filter the rows returned"""
    where: user_right_bool_exp
  ): user_right_aggregate!

  """fetch data from the table: "user_right" using primary key columns"""
  user_right_by_pk(value: String!): user_right

  """
  fetch data from the table: "user_storage"
  """
  user_storage(
    """distinct select on columns"""
    distinct_on: [user_storage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_storage_order_by!]

    """filter the rows returned"""
    where: user_storage_bool_exp
  ): [user_storage!]!

  """
  fetch aggregated fields from the table: "user_storage"
  """
  user_storage_aggregate(
    """distinct select on columns"""
    distinct_on: [user_storage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_storage_order_by!]

    """filter the rows returned"""
    where: user_storage_bool_exp
  ): user_storage_aggregate!

  """fetch data from the table: "user_storage" using primary key columns"""
  user_storage_by_pk(value: String!): user_storage

  """
  fetch data from the table: "users_active_last_day"
  """
  users_active_last_day(
    """distinct select on columns"""
    distinct_on: [users_active_last_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_active_last_day_order_by!]

    """filter the rows returned"""
    where: users_active_last_day_bool_exp
  ): [users_active_last_day!]!

  """
  fetch aggregated fields from the table: "users_active_last_day"
  """
  users_active_last_day_aggregate(
    """distinct select on columns"""
    distinct_on: [users_active_last_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_active_last_day_order_by!]

    """filter the rows returned"""
    where: users_active_last_day_bool_exp
  ): users_active_last_day_aggregate!
}

"""
Stores data about user sessions and when they were last seen - we only allow one mobile and one desktop/non-mobile session per user.
"""
type session {
  folio_user: String!
  id: String!
  is_mobile: Boolean!
  last_seen: timestamptz
}

"""
aggregated selection of "session"
"""
type session_aggregate {
  aggregate: session_aggregate_fields
  nodes: [session!]!
}

input session_aggregate_bool_exp {
  bool_and: session_aggregate_bool_exp_bool_and
  bool_or: session_aggregate_bool_exp_bool_or
  count: session_aggregate_bool_exp_count
}

input session_aggregate_bool_exp_bool_and {
  arguments: session_select_column_session_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: session_bool_exp
  predicate: Boolean_comparison_exp!
}

input session_aggregate_bool_exp_bool_or {
  arguments: session_select_column_session_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: session_bool_exp
  predicate: Boolean_comparison_exp!
}

input session_aggregate_bool_exp_count {
  arguments: [session_select_column!]
  distinct: Boolean
  filter: session_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "session"
"""
type session_aggregate_fields {
  count(columns: [session_select_column!], distinct: Boolean): Int!
  max: session_max_fields
  min: session_min_fields
}

"""
order by aggregate values of table "session"
"""
input session_aggregate_order_by {
  count: order_by
  max: session_max_order_by
  min: session_min_order_by
}

"""
input type for inserting array relation for remote table "session"
"""
input session_arr_rel_insert_input {
  data: [session_insert_input!]!

  """upsert condition"""
  on_conflict: session_on_conflict
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input session_bool_exp {
  _and: [session_bool_exp!]
  _not: session_bool_exp
  _or: [session_bool_exp!]
  folio_user: String_comparison_exp
  id: String_comparison_exp
  is_mobile: Boolean_comparison_exp
  last_seen: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "session"
"""
enum session_constraint {
  """
  unique or primary key constraint on columns "folio_user", "is_mobile"
  """
  session_pkey
}

"""
input type for inserting data into table "session"
"""
input session_insert_input {
  folio_user: String
  id: String
  is_mobile: Boolean
  last_seen: timestamptz
}

"""aggregate max on columns"""
type session_max_fields {
  folio_user: String
  id: String
  last_seen: timestamptz
}

"""
order by max() on columns of table "session"
"""
input session_max_order_by {
  folio_user: order_by
  id: order_by
  last_seen: order_by
}

"""aggregate min on columns"""
type session_min_fields {
  folio_user: String
  id: String
  last_seen: timestamptz
}

"""
order by min() on columns of table "session"
"""
input session_min_order_by {
  folio_user: order_by
  id: order_by
  last_seen: order_by
}

"""
response of any mutation on the table "session"
"""
type session_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session!]!
}

"""
on_conflict condition type for table "session"
"""
input session_on_conflict {
  constraint: session_constraint!
  update_columns: [session_update_column!]! = []
  where: session_bool_exp
}

"""Ordering options when selecting data from "session"."""
input session_order_by {
  folio_user: order_by
  id: order_by
  is_mobile: order_by
  last_seen: order_by
}

"""primary key columns input for table: session"""
input session_pk_columns_input {
  folio_user: String!
  is_mobile: Boolean!
}

"""
select columns of table "session"
"""
enum session_select_column {
  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  is_mobile

  """column name"""
  last_seen
}

"""
select "session_aggregate_bool_exp_bool_and_arguments_columns" columns of table "session"
"""
enum session_select_column_session_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_mobile
}

"""
select "session_aggregate_bool_exp_bool_or_arguments_columns" columns of table "session"
"""
enum session_select_column_session_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_mobile
}

"""
input type for updating data in table "session"
"""
input session_set_input {
  folio_user: String
  id: String
  is_mobile: Boolean
  last_seen: timestamptz
}

"""
Streaming cursor of the table "session"
"""
input session_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_stream_cursor_value_input {
  folio_user: String
  id: String
  is_mobile: Boolean
  last_seen: timestamptz
}

"""
columns and relationships of "session_type"
"""
type session_type {
  value: String!
}

"""
aggregated selection of "session_type"
"""
type session_type_aggregate {
  aggregate: session_type_aggregate_fields
  nodes: [session_type!]!
}

"""
aggregate fields of "session_type"
"""
type session_type_aggregate_fields {
  count(columns: [session_type_select_column!], distinct: Boolean): Int!
  max: session_type_max_fields
  min: session_type_min_fields
}

"""
Boolean expression to filter rows from the table "session_type". All fields are combined with a logical 'AND'.
"""
input session_type_bool_exp {
  _and: [session_type_bool_exp!]
  _not: session_type_bool_exp
  _or: [session_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "session_type"
"""
enum session_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  session_type_pkey
}

"""
input type for inserting data into table "session_type"
"""
input session_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type session_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type session_type_min_fields {
  value: String
}

"""
response of any mutation on the table "session_type"
"""
type session_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session_type!]!
}

"""
on_conflict condition type for table "session_type"
"""
input session_type_on_conflict {
  constraint: session_type_constraint!
  update_columns: [session_type_update_column!]! = []
  where: session_type_bool_exp
}

"""Ordering options when selecting data from "session_type"."""
input session_type_order_by {
  value: order_by
}

"""primary key columns input for table: session_type"""
input session_type_pk_columns_input {
  value: String!
}

"""
select columns of table "session_type"
"""
enum session_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "session_type"
"""
input session_type_set_input {
  value: String
}

"""
Streaming cursor of the table "session_type"
"""
input session_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "session_type"
"""
enum session_type_update_column {
  """column name"""
  value
}

input session_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: session_type_set_input

  """filter the rows which have to be updated"""
  where: session_type_bool_exp!
}

"""
update columns of table "session"
"""
enum session_update_column {
  """column name"""
  folio_user

  """column name"""
  id

  """column name"""
  is_mobile

  """column name"""
  last_seen
}

input session_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: session_set_input

  """filter the rows which have to be updated"""
  where: session_bool_exp!
}

"""
columns and relationships of "shared_instrument"
"""
type shared_instrument {
  edited_at: timestamptz!
  edited_by: String!

  """An object relationship"""
  folio_user: folio_user_basic_profile
  id: bigint!
  month: date!
  product: uuid!

  """An object relationship"""
  productByProduct: product!
  value: numeric
}

"""
aggregated selection of "shared_instrument"
"""
type shared_instrument_aggregate {
  aggregate: shared_instrument_aggregate_fields
  nodes: [shared_instrument!]!
}

input shared_instrument_aggregate_bool_exp {
  count: shared_instrument_aggregate_bool_exp_count
}

input shared_instrument_aggregate_bool_exp_count {
  arguments: [shared_instrument_select_column!]
  distinct: Boolean
  filter: shared_instrument_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "shared_instrument"
"""
type shared_instrument_aggregate_fields {
  avg: shared_instrument_avg_fields
  count(columns: [shared_instrument_select_column!], distinct: Boolean): Int!
  max: shared_instrument_max_fields
  min: shared_instrument_min_fields
  stddev: shared_instrument_stddev_fields
  stddev_pop: shared_instrument_stddev_pop_fields
  stddev_samp: shared_instrument_stddev_samp_fields
  sum: shared_instrument_sum_fields
  var_pop: shared_instrument_var_pop_fields
  var_samp: shared_instrument_var_samp_fields
  variance: shared_instrument_variance_fields
}

"""
order by aggregate values of table "shared_instrument"
"""
input shared_instrument_aggregate_order_by {
  avg: shared_instrument_avg_order_by
  count: order_by
  max: shared_instrument_max_order_by
  min: shared_instrument_min_order_by
  stddev: shared_instrument_stddev_order_by
  stddev_pop: shared_instrument_stddev_pop_order_by
  stddev_samp: shared_instrument_stddev_samp_order_by
  sum: shared_instrument_sum_order_by
  var_pop: shared_instrument_var_pop_order_by
  var_samp: shared_instrument_var_samp_order_by
  variance: shared_instrument_variance_order_by
}

"""
input type for inserting array relation for remote table "shared_instrument"
"""
input shared_instrument_arr_rel_insert_input {
  data: [shared_instrument_insert_input!]!

  """upsert condition"""
  on_conflict: shared_instrument_on_conflict
}

"""aggregate avg on columns"""
type shared_instrument_avg_fields {
  id: Float
  value: Float
}

"""
order by avg() on columns of table "shared_instrument"
"""
input shared_instrument_avg_order_by {
  id: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "shared_instrument". All fields are combined with a logical 'AND'.
"""
input shared_instrument_bool_exp {
  _and: [shared_instrument_bool_exp!]
  _not: shared_instrument_bool_exp
  _or: [shared_instrument_bool_exp!]
  edited_at: timestamptz_comparison_exp
  edited_by: String_comparison_exp
  folio_user: folio_user_basic_profile_bool_exp
  id: bigint_comparison_exp
  month: date_comparison_exp
  product: uuid_comparison_exp
  productByProduct: product_bool_exp
  value: numeric_comparison_exp
}

"""
unique or primary key constraints on table "shared_instrument"
"""
enum shared_instrument_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  shared_instrument_id_key

  """
  unique or primary key constraint on columns "product", "month"
  """
  shared_instrument_pkey
}

"""
input type for incrementing numeric columns in table "shared_instrument"
"""
input shared_instrument_inc_input {
  id: bigint
  value: numeric
}

"""
input type for inserting data into table "shared_instrument"
"""
input shared_instrument_insert_input {
  edited_at: timestamptz
  edited_by: String
  folio_user: folio_user_basic_profile_obj_rel_insert_input
  id: bigint
  month: date
  product: uuid
  productByProduct: product_obj_rel_insert_input
  value: numeric
}

"""aggregate max on columns"""
type shared_instrument_max_fields {
  edited_at: timestamptz
  edited_by: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""
order by max() on columns of table "shared_instrument"
"""
input shared_instrument_max_order_by {
  edited_at: order_by
  edited_by: order_by
  id: order_by
  month: order_by
  product: order_by
  value: order_by
}

"""aggregate min on columns"""
type shared_instrument_min_fields {
  edited_at: timestamptz
  edited_by: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""
order by min() on columns of table "shared_instrument"
"""
input shared_instrument_min_order_by {
  edited_at: order_by
  edited_by: order_by
  id: order_by
  month: order_by
  product: order_by
  value: order_by
}

"""
response of any mutation on the table "shared_instrument"
"""
type shared_instrument_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [shared_instrument!]!
}

"""
on_conflict condition type for table "shared_instrument"
"""
input shared_instrument_on_conflict {
  constraint: shared_instrument_constraint!
  update_columns: [shared_instrument_update_column!]! = []
  where: shared_instrument_bool_exp
}

"""Ordering options when selecting data from "shared_instrument"."""
input shared_instrument_order_by {
  edited_at: order_by
  edited_by: order_by
  folio_user: folio_user_basic_profile_order_by
  id: order_by
  month: order_by
  product: order_by
  productByProduct: product_order_by
  value: order_by
}

"""primary key columns input for table: shared_instrument"""
input shared_instrument_pk_columns_input {
  month: date!
  product: uuid!
}

"""
select columns of table "shared_instrument"
"""
enum shared_instrument_select_column {
  """column name"""
  edited_at

  """column name"""
  edited_by

  """column name"""
  id

  """column name"""
  month

  """column name"""
  product

  """column name"""
  value
}

"""
input type for updating data in table "shared_instrument"
"""
input shared_instrument_set_input {
  edited_at: timestamptz
  edited_by: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""aggregate stddev on columns"""
type shared_instrument_stddev_fields {
  id: Float
  value: Float
}

"""
order by stddev() on columns of table "shared_instrument"
"""
input shared_instrument_stddev_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type shared_instrument_stddev_pop_fields {
  id: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "shared_instrument"
"""
input shared_instrument_stddev_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type shared_instrument_stddev_samp_fields {
  id: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "shared_instrument"
"""
input shared_instrument_stddev_samp_order_by {
  id: order_by
  value: order_by
}

"""
Streaming cursor of the table "shared_instrument"
"""
input shared_instrument_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: shared_instrument_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input shared_instrument_stream_cursor_value_input {
  edited_at: timestamptz
  edited_by: String
  id: bigint
  month: date
  product: uuid
  value: numeric
}

"""aggregate sum on columns"""
type shared_instrument_sum_fields {
  id: bigint
  value: numeric
}

"""
order by sum() on columns of table "shared_instrument"
"""
input shared_instrument_sum_order_by {
  id: order_by
  value: order_by
}

"""
update columns of table "shared_instrument"
"""
enum shared_instrument_update_column {
  """column name"""
  edited_at

  """column name"""
  edited_by

  """column name"""
  id

  """column name"""
  month

  """column name"""
  product

  """column name"""
  value
}

input shared_instrument_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: shared_instrument_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: shared_instrument_set_input

  """filter the rows which have to be updated"""
  where: shared_instrument_bool_exp!
}

"""aggregate var_pop on columns"""
type shared_instrument_var_pop_fields {
  id: Float
  value: Float
}

"""
order by var_pop() on columns of table "shared_instrument"
"""
input shared_instrument_var_pop_order_by {
  id: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type shared_instrument_var_samp_fields {
  id: Float
  value: Float
}

"""
order by var_samp() on columns of table "shared_instrument"
"""
input shared_instrument_var_samp_order_by {
  id: order_by
  value: order_by
}

"""aggregate variance on columns"""
type shared_instrument_variance_fields {
  id: Float
  value: Float
}

"""
order by variance() on columns of table "shared_instrument"
"""
input shared_instrument_variance_order_by {
  id: order_by
  value: order_by
}

"""
columns and relationships of "sharing_agreement"
"""
type sharing_agreement {
  """An object relationship"""
  broadcasterSourceBySource: source!
  broadcaster_source: Int!

  """An object relationship"""
  consumerSourceBySource: source!
  consumer_source: Int!
  id: Int!
}

"""
aggregated selection of "sharing_agreement"
"""
type sharing_agreement_aggregate {
  aggregate: sharing_agreement_aggregate_fields
  nodes: [sharing_agreement!]!
}

"""
aggregate fields of "sharing_agreement"
"""
type sharing_agreement_aggregate_fields {
  avg: sharing_agreement_avg_fields
  count(columns: [sharing_agreement_select_column!], distinct: Boolean): Int!
  max: sharing_agreement_max_fields
  min: sharing_agreement_min_fields
  stddev: sharing_agreement_stddev_fields
  stddev_pop: sharing_agreement_stddev_pop_fields
  stddev_samp: sharing_agreement_stddev_samp_fields
  sum: sharing_agreement_sum_fields
  var_pop: sharing_agreement_var_pop_fields
  var_samp: sharing_agreement_var_samp_fields
  variance: sharing_agreement_variance_fields
}

"""aggregate avg on columns"""
type sharing_agreement_avg_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "sharing_agreement". All fields are combined with a logical 'AND'.
"""
input sharing_agreement_bool_exp {
  _and: [sharing_agreement_bool_exp!]
  _not: sharing_agreement_bool_exp
  _or: [sharing_agreement_bool_exp!]
  broadcasterSourceBySource: source_bool_exp
  broadcaster_source: Int_comparison_exp
  consumerSourceBySource: source_bool_exp
  consumer_source: Int_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "sharing_agreement"
"""
enum sharing_agreement_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sharing_agreement_pk

  """
  unique or primary key constraint on columns "consumer_source", "broadcaster_source"
  """
  sharing_agreement_unique_bcast_cons
}

"""
input type for incrementing numeric columns in table "sharing_agreement"
"""
input sharing_agreement_inc_input {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""
input type for inserting data into table "sharing_agreement"
"""
input sharing_agreement_insert_input {
  broadcasterSourceBySource: source_obj_rel_insert_input
  broadcaster_source: Int
  consumerSourceBySource: source_obj_rel_insert_input
  consumer_source: Int
  id: Int
}

"""aggregate max on columns"""
type sharing_agreement_max_fields {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""aggregate min on columns"""
type sharing_agreement_min_fields {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""
response of any mutation on the table "sharing_agreement"
"""
type sharing_agreement_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sharing_agreement!]!
}

"""
on_conflict condition type for table "sharing_agreement"
"""
input sharing_agreement_on_conflict {
  constraint: sharing_agreement_constraint!
  update_columns: [sharing_agreement_update_column!]! = []
  where: sharing_agreement_bool_exp
}

"""Ordering options when selecting data from "sharing_agreement"."""
input sharing_agreement_order_by {
  broadcasterSourceBySource: source_order_by
  broadcaster_source: order_by
  consumerSourceBySource: source_order_by
  consumer_source: order_by
  id: order_by
}

"""primary key columns input for table: sharing_agreement"""
input sharing_agreement_pk_columns_input {
  id: Int!
}

"""
select columns of table "sharing_agreement"
"""
enum sharing_agreement_select_column {
  """column name"""
  broadcaster_source

  """column name"""
  consumer_source

  """column name"""
  id
}

"""
input type for updating data in table "sharing_agreement"
"""
input sharing_agreement_set_input {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""aggregate stddev on columns"""
type sharing_agreement_stddev_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type sharing_agreement_stddev_pop_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type sharing_agreement_stddev_samp_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""
Streaming cursor of the table "sharing_agreement"
"""
input sharing_agreement_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sharing_agreement_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sharing_agreement_stream_cursor_value_input {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""aggregate sum on columns"""
type sharing_agreement_sum_fields {
  broadcaster_source: Int
  consumer_source: Int
  id: Int
}

"""
update columns of table "sharing_agreement"
"""
enum sharing_agreement_update_column {
  """column name"""
  broadcaster_source

  """column name"""
  consumer_source

  """column name"""
  id
}

input sharing_agreement_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: sharing_agreement_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: sharing_agreement_set_input

  """filter the rows which have to be updated"""
  where: sharing_agreement_bool_exp!
}

"""aggregate var_pop on columns"""
type sharing_agreement_var_pop_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""aggregate var_samp on columns"""
type sharing_agreement_var_samp_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""aggregate variance on columns"""
type sharing_agreement_variance_fields {
  broadcaster_source: Float
  consumer_source: Float
  id: Float
}

"""
columns and relationships of "source"
"""
type source {
  description: String

  """An object relationship"""
  eod: eod

  """An array relationship"""
  eods(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): [eod!]!

  """An aggregate relationship"""
  eods_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): eod_aggregate!

  """An object relationship"""
  exchange: exchange

  """An array relationship"""
  exchanges(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): [exchange!]!

  """An aggregate relationship"""
  exchanges_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): exchange_aggregate!
  id: Int!
  name: String!

  """An object relationship"""
  organisation: organisation

  """An array relationship"""
  organisations(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): [organisation!]!

  """An aggregate relationship"""
  organisations_aggregate(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): organisation_aggregate!

  """An array relationship"""
  packages(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): [package!]!

  """An aggregate relationship"""
  packages_aggregate(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): package_aggregate!

  """An object relationship"""
  product_source: product_source
  source_type: product_source_enum
}

"""
aggregated selection of "source"
"""
type source_aggregate {
  aggregate: source_aggregate_fields
  nodes: [source!]!
}

input source_aggregate_bool_exp {
  count: source_aggregate_bool_exp_count
}

input source_aggregate_bool_exp_count {
  arguments: [source_select_column!]
  distinct: Boolean
  filter: source_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "source"
"""
type source_aggregate_fields {
  avg: source_avg_fields
  count(columns: [source_select_column!], distinct: Boolean): Int!
  max: source_max_fields
  min: source_min_fields
  stddev: source_stddev_fields
  stddev_pop: source_stddev_pop_fields
  stddev_samp: source_stddev_samp_fields
  sum: source_sum_fields
  var_pop: source_var_pop_fields
  var_samp: source_var_samp_fields
  variance: source_variance_fields
}

"""
order by aggregate values of table "source"
"""
input source_aggregate_order_by {
  avg: source_avg_order_by
  count: order_by
  max: source_max_order_by
  min: source_min_order_by
  stddev: source_stddev_order_by
  stddev_pop: source_stddev_pop_order_by
  stddev_samp: source_stddev_samp_order_by
  sum: source_sum_order_by
  var_pop: source_var_pop_order_by
  var_samp: source_var_samp_order_by
  variance: source_variance_order_by
}

"""
input type for inserting array relation for remote table "source"
"""
input source_arr_rel_insert_input {
  data: [source_insert_input!]!

  """upsert condition"""
  on_conflict: source_on_conflict
}

"""aggregate avg on columns"""
type source_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "source"
"""
input source_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "source". All fields are combined with a logical 'AND'.
"""
input source_bool_exp {
  _and: [source_bool_exp!]
  _not: source_bool_exp
  _or: [source_bool_exp!]
  description: String_comparison_exp
  eod: eod_bool_exp
  eods: eod_bool_exp
  eods_aggregate: eod_aggregate_bool_exp
  exchange: exchange_bool_exp
  exchanges: exchange_bool_exp
  exchanges_aggregate: exchange_aggregate_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  organisation: organisation_bool_exp
  organisations: organisation_bool_exp
  organisations_aggregate: organisation_aggregate_bool_exp
  packages: package_bool_exp
  packages_aggregate: package_aggregate_bool_exp
  product_source: product_source_bool_exp
  source_type: product_source_enum_comparison_exp
}

"""
unique or primary key constraints on table "source"
"""
enum source_constraint {
  """
  unique or primary key constraint on columns "source_type", "name"
  """
  source_name_source_type_key

  """
  unique or primary key constraint on columns "id"
  """
  source_pkey
}

"""
input type for incrementing numeric columns in table "source"
"""
input source_inc_input {
  id: Int
}

"""
input type for inserting data into table "source"
"""
input source_insert_input {
  description: String
  eod: eod_obj_rel_insert_input
  eods: eod_arr_rel_insert_input
  exchange: exchange_obj_rel_insert_input
  exchanges: exchange_arr_rel_insert_input
  id: Int
  name: String
  organisation: organisation_obj_rel_insert_input
  organisations: organisation_arr_rel_insert_input
  packages: package_arr_rel_insert_input
  product_source: product_source_obj_rel_insert_input
  source_type: product_source_enum
}

"""aggregate max on columns"""
type source_max_fields {
  description: String
  id: Int
  name: String
}

"""
order by max() on columns of table "source"
"""
input source_max_order_by {
  description: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type source_min_fields {
  description: String
  id: Int
  name: String
}

"""
order by min() on columns of table "source"
"""
input source_min_order_by {
  description: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "source"
"""
type source_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [source!]!
}

"""
input type for inserting object relation for remote table "source"
"""
input source_obj_rel_insert_input {
  data: source_insert_input!

  """upsert condition"""
  on_conflict: source_on_conflict
}

"""
on_conflict condition type for table "source"
"""
input source_on_conflict {
  constraint: source_constraint!
  update_columns: [source_update_column!]! = []
  where: source_bool_exp
}

"""Ordering options when selecting data from "source"."""
input source_order_by {
  description: order_by
  eod: eod_order_by
  eods_aggregate: eod_aggregate_order_by
  exchange: exchange_order_by
  exchanges_aggregate: exchange_aggregate_order_by
  id: order_by
  name: order_by
  organisation: organisation_order_by
  organisations_aggregate: organisation_aggregate_order_by
  packages_aggregate: package_aggregate_order_by
  product_source: product_source_order_by
  source_type: order_by
}

"""primary key columns input for table: source"""
input source_pk_columns_input {
  id: Int!
}

"""
select columns of table "source"
"""
enum source_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  source_type
}

"""
input type for updating data in table "source"
"""
input source_set_input {
  description: String
  id: Int
  name: String
  source_type: product_source_enum
}

"""aggregate stddev on columns"""
type source_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "source"
"""
input source_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type source_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "source"
"""
input source_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type source_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "source"
"""
input source_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "source"
"""
input source_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: source_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input source_stream_cursor_value_input {
  description: String
  id: Int
  name: String
  source_type: product_source_enum
}

"""aggregate sum on columns"""
type source_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "source"
"""
input source_sum_order_by {
  id: order_by
}

"""
update columns of table "source"
"""
enum source_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  source_type
}

input source_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: source_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: source_set_input

  """filter the rows which have to be updated"""
  where: source_bool_exp!
}

"""aggregate var_pop on columns"""
type source_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "source"
"""
input source_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type source_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "source"
"""
input source_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type source_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "source"
"""
input source_variance_order_by {
  id: order_by
}

type subscription_root {
  """
  fetch data from the table: "audit.logged_actions"
  """
  audit_logged_actions(
    """distinct select on columns"""
    distinct_on: [audit_logged_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logged_actions_order_by!]

    """filter the rows returned"""
    where: audit_logged_actions_bool_exp
  ): [audit_logged_actions!]!

  """
  fetch aggregated fields from the table: "audit.logged_actions"
  """
  audit_logged_actions_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_logged_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_logged_actions_order_by!]

    """filter the rows returned"""
    where: audit_logged_actions_bool_exp
  ): audit_logged_actions_aggregate!

  """
  fetch data from the table: "audit.logged_actions" using primary key columns
  """
  audit_logged_actions_by_pk(
    """Unique identifier for each auditable event"""
    event_id: bigint!
  ): audit_logged_actions

  """
  fetch data from the table in a streaming manner: "audit.logged_actions"
  """
  audit_logged_actions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [audit_logged_actions_stream_cursor_input]!

    """filter the rows returned"""
    where: audit_logged_actions_bool_exp
  ): [audit_logged_actions!]!

  """
  fetch data from the table: "audit.umi_actions"
  """
  audit_umi_actions(
    """distinct select on columns"""
    distinct_on: [audit_umi_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_umi_actions_order_by!]

    """filter the rows returned"""
    where: audit_umi_actions_bool_exp
  ): [audit_umi_actions!]!

  """
  fetch aggregated fields from the table: "audit.umi_actions"
  """
  audit_umi_actions_aggregate(
    """distinct select on columns"""
    distinct_on: [audit_umi_actions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [audit_umi_actions_order_by!]

    """filter the rows returned"""
    where: audit_umi_actions_bool_exp
  ): audit_umi_actions_aggregate!

  """
  fetch data from the table: "audit.umi_actions" using primary key columns
  """
  audit_umi_actions_by_pk(id: Int!): audit_umi_actions

  """
  fetch data from the table in a streaming manner: "audit.umi_actions"
  """
  audit_umi_actions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [audit_umi_actions_stream_cursor_input]!

    """filter the rows returned"""
    where: audit_umi_actions_bool_exp
  ): [audit_umi_actions!]!

  """
  fetch data from the table: "commodity_group"
  """
  commodity_group(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): [commodity_group!]!

  """
  fetch aggregated fields from the table: "commodity_group"
  """
  commodity_group_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_group_order_by!]

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): commodity_group_aggregate!

  """fetch data from the table: "commodity_group" using primary key columns"""
  commodity_group_by_pk(id: Int!): commodity_group

  """
  fetch data from the table in a streaming manner: "commodity_group"
  """
  commodity_group_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [commodity_group_stream_cursor_input]!

    """filter the rows returned"""
    where: commodity_group_bool_exp
  ): [commodity_group!]!

  """
  fetch data from the table: "commodity_parent_group"
  """
  commodity_parent_group(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): [commodity_parent_group!]!

  """
  fetch aggregated fields from the table: "commodity_parent_group"
  """
  commodity_parent_group_aggregate(
    """distinct select on columns"""
    distinct_on: [commodity_parent_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [commodity_parent_group_order_by!]

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): commodity_parent_group_aggregate!

  """
  fetch data from the table: "commodity_parent_group" using primary key columns
  """
  commodity_parent_group_by_pk(id: Int!): commodity_parent_group

  """
  fetch data from the table in a streaming manner: "commodity_parent_group"
  """
  commodity_parent_group_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [commodity_parent_group_stream_cursor_input]!

    """filter the rows returned"""
    where: commodity_parent_group_bool_exp
  ): [commodity_parent_group!]!

  """
  fetch data from the table: "eod"
  """
  eod(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): [eod!]!

  """
  fetch aggregated fields from the table: "eod"
  """
  eod_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_order_by!]

    """filter the rows returned"""
    where: eod_bool_exp
  ): eod_aggregate!

  """fetch data from the table: "eod" using primary key columns"""
  eod_by_pk(id: Int!): eod

  """
  fetch data from the table: "eod_entry"
  """
  eod_entry(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): [eod_entry!]!

  """
  fetch aggregated fields from the table: "eod_entry"
  """
  eod_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_order_by!]

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): eod_entry_aggregate!

  """fetch data from the table: "eod_entry" using primary key columns"""
  eod_entry_by_pk(evaluation_date: date!, month: date!, product: uuid!): eod_entry

  """
  fetch data from the table: "eod_entry_per_eval_date_mview"
  """
  eod_entry_per_eval_date_mview(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_mview_bool_exp
  ): [eod_entry_per_eval_date_mview!]!

  """
  fetch aggregated fields from the table: "eod_entry_per_eval_date_mview"
  """
  eod_entry_per_eval_date_mview_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_mview_bool_exp
  ): eod_entry_per_eval_date_mview_aggregate!

  """
  fetch data from the table in a streaming manner: "eod_entry_per_eval_date_mview"
  """
  eod_entry_per_eval_date_mview_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [eod_entry_per_eval_date_mview_stream_cursor_input]!

    """filter the rows returned"""
    where: eod_entry_per_eval_date_mview_bool_exp
  ): [eod_entry_per_eval_date_mview!]!

  """
  fetch data from the table: "eod_entry_per_eval_date_package_mview"
  """
  eod_entry_per_eval_date_package_mview(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_package_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_package_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_package_mview_bool_exp
  ): [eod_entry_per_eval_date_package_mview!]!

  """
  fetch aggregated fields from the table: "eod_entry_per_eval_date_package_mview"
  """
  eod_entry_per_eval_date_package_mview_aggregate(
    """distinct select on columns"""
    distinct_on: [eod_entry_per_eval_date_package_mview_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [eod_entry_per_eval_date_package_mview_order_by!]

    """filter the rows returned"""
    where: eod_entry_per_eval_date_package_mview_bool_exp
  ): eod_entry_per_eval_date_package_mview_aggregate!

  """
  fetch data from the table in a streaming manner: "eod_entry_per_eval_date_package_mview"
  """
  eod_entry_per_eval_date_package_mview_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [eod_entry_per_eval_date_package_mview_stream_cursor_input]!

    """filter the rows returned"""
    where: eod_entry_per_eval_date_package_mview_bool_exp
  ): [eod_entry_per_eval_date_package_mview!]!

  """
  fetch data from the table in a streaming manner: "eod_entry"
  """
  eod_entry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [eod_entry_stream_cursor_input]!

    """filter the rows returned"""
    where: eod_entry_bool_exp
  ): [eod_entry!]!

  """
  fetch data from the table in a streaming manner: "eod"
  """
  eod_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [eod_stream_cursor_input]!

    """filter the rows returned"""
    where: eod_bool_exp
  ): [eod!]!

  """
  fetch data from the table: "exchange"
  """
  exchange(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): [exchange!]!

  """
  fetch aggregated fields from the table: "exchange"
  """
  exchange_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_order_by!]

    """filter the rows returned"""
    where: exchange_bool_exp
  ): exchange_aggregate!

  """fetch data from the table: "exchange" using primary key columns"""
  exchange_by_pk(id: Int!): exchange

  """
  fetch data from the table: "exchange_event_type"
  """
  exchange_event_type(
    """distinct select on columns"""
    distinct_on: [exchange_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_event_type_order_by!]

    """filter the rows returned"""
    where: exchange_event_type_bool_exp
  ): [exchange_event_type!]!

  """
  fetch aggregated fields from the table: "exchange_event_type"
  """
  exchange_event_type_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_event_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_event_type_order_by!]

    """filter the rows returned"""
    where: exchange_event_type_bool_exp
  ): exchange_event_type_aggregate!

  """
  fetch data from the table: "exchange_event_type" using primary key columns
  """
  exchange_event_type_by_pk(value: String!): exchange_event_type

  """
  fetch data from the table in a streaming manner: "exchange_event_type"
  """
  exchange_event_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [exchange_event_type_stream_cursor_input]!

    """filter the rows returned"""
    where: exchange_event_type_bool_exp
  ): [exchange_event_type!]!

  """
  fetch data from the table in a streaming manner: "exchange"
  """
  exchange_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [exchange_stream_cursor_input]!

    """filter the rows returned"""
    where: exchange_bool_exp
  ): [exchange!]!

  """
  fetch data from the table: "exchange_usage"
  """
  exchange_usage(
    """distinct select on columns"""
    distinct_on: [exchange_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_order_by!]

    """filter the rows returned"""
    where: exchange_usage_bool_exp
  ): [exchange_usage!]!

  """
  fetch aggregated fields from the table: "exchange_usage"
  """
  exchange_usage_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_order_by!]

    """filter the rows returned"""
    where: exchange_usage_bool_exp
  ): exchange_usage_aggregate!

  """fetch data from the table: "exchange_usage" using primary key columns"""
  exchange_usage_by_pk(id: Int!): exchange_usage

  """
  fetch data from the table: "exchange_usage_last"
  """
  exchange_usage_last(
    """distinct select on columns"""
    distinct_on: [exchange_usage_last_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_last_order_by!]

    """filter the rows returned"""
    where: exchange_usage_last_bool_exp
  ): [exchange_usage_last!]!

  """
  fetch aggregated fields from the table: "exchange_usage_last"
  """
  exchange_usage_last_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_last_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_last_order_by!]

    """filter the rows returned"""
    where: exchange_usage_last_bool_exp
  ): exchange_usage_last_aggregate!

  """
  fetch data from the table in a streaming manner: "exchange_usage_last"
  """
  exchange_usage_last_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [exchange_usage_last_stream_cursor_input]!

    """filter the rows returned"""
    where: exchange_usage_last_bool_exp
  ): [exchange_usage_last!]!

  """
  fetch data from the table: "exchange_usage_start"
  """
  exchange_usage_start(
    """distinct select on columns"""
    distinct_on: [exchange_usage_start_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_start_order_by!]

    """filter the rows returned"""
    where: exchange_usage_start_bool_exp
  ): [exchange_usage_start!]!

  """
  fetch aggregated fields from the table: "exchange_usage_start"
  """
  exchange_usage_start_aggregate(
    """distinct select on columns"""
    distinct_on: [exchange_usage_start_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [exchange_usage_start_order_by!]

    """filter the rows returned"""
    where: exchange_usage_start_bool_exp
  ): exchange_usage_start_aggregate!

  """
  fetch data from the table in a streaming manner: "exchange_usage_start"
  """
  exchange_usage_start_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [exchange_usage_start_stream_cursor_input]!

    """filter the rows returned"""
    where: exchange_usage_start_bool_exp
  ): [exchange_usage_start!]!

  """
  fetch data from the table in a streaming manner: "exchange_usage"
  """
  exchange_usage_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [exchange_usage_stream_cursor_input]!

    """filter the rows returned"""
    where: exchange_usage_bool_exp
  ): [exchange_usage!]!

  """
  fetch data from the table: "folio_column_settings"
  """
  folio_column_settings(
    """distinct select on columns"""
    distinct_on: [folio_column_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_column_settings_order_by!]

    """filter the rows returned"""
    where: folio_column_settings_bool_exp
  ): [folio_column_settings!]!

  """
  fetch aggregated fields from the table: "folio_column_settings"
  """
  folio_column_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_column_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_column_settings_order_by!]

    """filter the rows returned"""
    where: folio_column_settings_bool_exp
  ): folio_column_settings_aggregate!

  """
  fetch data from the table: "folio_column_settings" using primary key columns
  """
  folio_column_settings_by_pk(folio_user: String!): folio_column_settings

  """
  fetch data from the table in a streaming manner: "folio_column_settings"
  """
  folio_column_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [folio_column_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: folio_column_settings_bool_exp
  ): [folio_column_settings!]!

  """
  fetch data from the table: "folio_shadow_curves"
  """
  folio_shadow_curves(
    """distinct select on columns"""
    distinct_on: [folio_shadow_curves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_shadow_curves_order_by!]

    """filter the rows returned"""
    where: folio_shadow_curves_bool_exp
  ): [folio_shadow_curves!]!

  """
  fetch aggregated fields from the table: "folio_shadow_curves"
  """
  folio_shadow_curves_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_shadow_curves_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_shadow_curves_order_by!]

    """filter the rows returned"""
    where: folio_shadow_curves_bool_exp
  ): folio_shadow_curves_aggregate!

  """
  fetch data from the table: "folio_shadow_curves" using primary key columns
  """
  folio_shadow_curves_by_pk(folio_user: String!): folio_shadow_curves

  """
  fetch data from the table in a streaming manner: "folio_shadow_curves"
  """
  folio_shadow_curves_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [folio_shadow_curves_stream_cursor_input]!

    """filter the rows returned"""
    where: folio_shadow_curves_bool_exp
  ): [folio_shadow_curves!]!

  """
  fetch data from the table: "folio_user"
  """
  folio_user(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): [folio_user!]!

  """
  fetch aggregated fields from the table: "folio_user"
  """
  folio_user_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_order_by!]

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): folio_user_aggregate!

  """
  fetch data from the table: "folio_user_basic_profile"
  """
  folio_user_basic_profile(
    """distinct select on columns"""
    distinct_on: [folio_user_basic_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_basic_profile_order_by!]

    """filter the rows returned"""
    where: folio_user_basic_profile_bool_exp
  ): [folio_user_basic_profile!]!

  """
  fetch aggregated fields from the table: "folio_user_basic_profile"
  """
  folio_user_basic_profile_aggregate(
    """distinct select on columns"""
    distinct_on: [folio_user_basic_profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [folio_user_basic_profile_order_by!]

    """filter the rows returned"""
    where: folio_user_basic_profile_bool_exp
  ): folio_user_basic_profile_aggregate!

  """
  fetch data from the table in a streaming manner: "folio_user_basic_profile"
  """
  folio_user_basic_profile_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [folio_user_basic_profile_stream_cursor_input]!

    """filter the rows returned"""
    where: folio_user_basic_profile_bool_exp
  ): [folio_user_basic_profile!]!

  """fetch data from the table: "folio_user" using primary key columns"""
  folio_user_by_pk(id: String!): folio_user

  """
  fetch data from the table in a streaming manner: "folio_user"
  """
  folio_user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [folio_user_stream_cursor_input]!

    """filter the rows returned"""
    where: folio_user_bool_exp
  ): [folio_user!]!

  """
  fetch data from the table: "geographical_region"
  """
  geographical_region(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): [geographical_region!]!

  """
  fetch aggregated fields from the table: "geographical_region"
  """
  geographical_region_aggregate(
    """distinct select on columns"""
    distinct_on: [geographical_region_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [geographical_region_order_by!]

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): geographical_region_aggregate!

  """
  fetch data from the table: "geographical_region" using primary key columns
  """
  geographical_region_by_pk(id: Int!): geographical_region

  """
  fetch data from the table in a streaming manner: "geographical_region"
  """
  geographical_region_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [geographical_region_stream_cursor_input]!

    """filter the rows returned"""
    where: geographical_region_bool_exp
  ): [geographical_region!]!

  """
  fetch data from the table: "global_instrument"
  """
  global_instrument(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): [global_instrument!]!

  """
  fetch aggregated fields from the table: "global_instrument"
  """
  global_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [global_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_instrument_order_by!]

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): global_instrument_aggregate!

  """
  fetch data from the table: "global_instrument" using primary key columns
  """
  global_instrument_by_pk(global_product: uuid!, month: date!): global_instrument

  """
  fetch data from the table in a streaming manner: "global_instrument"
  """
  global_instrument_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [global_instrument_stream_cursor_input]!

    """filter the rows returned"""
    where: global_instrument_bool_exp
  ): [global_instrument!]!

  """
  fetch data from the table: "global_package"
  """
  global_package(
    """distinct select on columns"""
    distinct_on: [global_package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_package_order_by!]

    """filter the rows returned"""
    where: global_package_bool_exp
  ): [global_package!]!

  """
  fetch aggregated fields from the table: "global_package"
  """
  global_package_aggregate(
    """distinct select on columns"""
    distinct_on: [global_package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_package_order_by!]

    """filter the rows returned"""
    where: global_package_bool_exp
  ): global_package_aggregate!

  """fetch data from the table: "global_package" using primary key columns"""
  global_package_by_pk(id: Int!): global_package

  """
  fetch data from the table in a streaming manner: "global_package"
  """
  global_package_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [global_package_stream_cursor_input]!

    """filter the rows returned"""
    where: global_package_bool_exp
  ): [global_package!]!

  """
  fetch data from the table: "global_permission"
  """
  global_permission(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): [global_permission!]!

  """
  fetch aggregated fields from the table: "global_permission"
  """
  global_permission_aggregate(
    """distinct select on columns"""
    distinct_on: [global_permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_permission_order_by!]

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): global_permission_aggregate!

  """
  fetch data from the table: "global_permission" using primary key columns
  """
  global_permission_by_pk(folio_user: String!, global_package: Int!): global_permission

  """
  fetch data from the table in a streaming manner: "global_permission"
  """
  global_permission_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [global_permission_stream_cursor_input]!

    """filter the rows returned"""
    where: global_permission_bool_exp
  ): [global_permission!]!

  """
  fetch data from the table: "global_product"
  """
  global_product(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): [global_product!]!

  """
  fetch aggregated fields from the table: "global_product"
  """
  global_product_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_order_by!]

    """filter the rows returned"""
    where: global_product_bool_exp
  ): global_product_aggregate!

  """fetch data from the table: "global_product" using primary key columns"""
  global_product_by_pk(id: uuid!): global_product

  """
  fetch data from the table: "global_product_config"
  """
  global_product_config(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): [global_product_config!]!

  """
  fetch aggregated fields from the table: "global_product_config"
  """
  global_product_config_aggregate(
    """distinct select on columns"""
    distinct_on: [global_product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [global_product_config_order_by!]

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): global_product_config_aggregate!

  """
  fetch data from the table: "global_product_config" using primary key columns
  """
  global_product_config_by_pk(product: uuid!, relative_month: Int!): global_product_config

  """
  fetch data from the table in a streaming manner: "global_product_config"
  """
  global_product_config_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [global_product_config_stream_cursor_input]!

    """filter the rows returned"""
    where: global_product_config_bool_exp
  ): [global_product_config!]!

  """
  fetch data from the table in a streaming manner: "global_product"
  """
  global_product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [global_product_stream_cursor_input]!

    """filter the rows returned"""
    where: global_product_bool_exp
  ): [global_product!]!

  """
  fetch data from the table: "hfc_card_settings"
  """
  hfc_card_settings(
    """distinct select on columns"""
    distinct_on: [hfc_card_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_card_settings_order_by!]

    """filter the rows returned"""
    where: hfc_card_settings_bool_exp
  ): [hfc_card_settings!]!

  """
  fetch aggregated fields from the table: "hfc_card_settings"
  """
  hfc_card_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [hfc_card_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_card_settings_order_by!]

    """filter the rows returned"""
    where: hfc_card_settings_bool_exp
  ): hfc_card_settings_aggregate!

  """
  fetch data from the table: "hfc_card_settings" using primary key columns
  """
  hfc_card_settings_by_pk(user: String!): hfc_card_settings

  """
  fetch data from the table in a streaming manner: "hfc_card_settings"
  """
  hfc_card_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [hfc_card_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: hfc_card_settings_bool_exp
  ): [hfc_card_settings!]!

  """
  fetch data from the table: "hfc_user_settings"
  """
  hfc_user_settings(
    """distinct select on columns"""
    distinct_on: [hfc_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_user_settings_order_by!]

    """filter the rows returned"""
    where: hfc_user_settings_bool_exp
  ): [hfc_user_settings!]!

  """
  fetch aggregated fields from the table: "hfc_user_settings"
  """
  hfc_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [hfc_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [hfc_user_settings_order_by!]

    """filter the rows returned"""
    where: hfc_user_settings_bool_exp
  ): hfc_user_settings_aggregate!

  """
  fetch data from the table: "hfc_user_settings" using primary key columns
  """
  hfc_user_settings_by_pk(user: String!): hfc_user_settings

  """
  fetch data from the table in a streaming manner: "hfc_user_settings"
  """
  hfc_user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [hfc_user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: hfc_user_settings_bool_exp
  ): [hfc_user_settings!]!

  """
  fetch data from the table: "live_users_new"
  """
  live_users_new(
    """distinct select on columns"""
    distinct_on: [live_users_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [live_users_new_order_by!]

    """filter the rows returned"""
    where: live_users_new_bool_exp
  ): [live_users_new!]!

  """
  fetch aggregated fields from the table: "live_users_new"
  """
  live_users_new_aggregate(
    """distinct select on columns"""
    distinct_on: [live_users_new_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [live_users_new_order_by!]

    """filter the rows returned"""
    where: live_users_new_bool_exp
  ): live_users_new_aggregate!

  """
  fetch data from the table in a streaming manner: "live_users_new"
  """
  live_users_new_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [live_users_new_stream_cursor_input]!

    """filter the rows returned"""
    where: live_users_new_bool_exp
  ): [live_users_new!]!

  """
  fetch data from the table: "local_instrument"
  """
  local_instrument(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): [local_instrument!]!

  """
  fetch aggregated fields from the table: "local_instrument"
  """
  local_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [local_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_instrument_order_by!]

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): local_instrument_aggregate!

  """
  fetch data from the table: "local_instrument" using primary key columns
  """
  local_instrument_by_pk(folio_user: String!, month: date!, product: uuid!, storage_type: user_storage_enum!): local_instrument

  """
  fetch data from the table in a streaming manner: "local_instrument"
  """
  local_instrument_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [local_instrument_stream_cursor_input]!

    """filter the rows returned"""
    where: local_instrument_bool_exp
  ): [local_instrument!]!

  """
  fetch data from the table: "logout_request"
  """
  logout_request(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): [logout_request!]!

  """
  fetch aggregated fields from the table: "logout_request"
  """
  logout_request_aggregate(
    """distinct select on columns"""
    distinct_on: [logout_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logout_request_order_by!]

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): logout_request_aggregate!

  """fetch data from the table: "logout_request" using primary key columns"""
  logout_request_by_pk(id: Int!): logout_request

  """
  fetch data from the table in a streaming manner: "logout_request"
  """
  logout_request_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [logout_request_stream_cursor_input]!

    """filter the rows returned"""
    where: logout_request_bool_exp
  ): [logout_request!]!

  """
  fetch data from the table: "organisation"
  """
  organisation(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): [organisation!]!

  """
  fetch aggregated fields from the table: "organisation"
  """
  organisation_aggregate(
    """distinct select on columns"""
    distinct_on: [organisation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organisation_order_by!]

    """filter the rows returned"""
    where: organisation_bool_exp
  ): organisation_aggregate!

  """fetch data from the table: "organisation" using primary key columns"""
  organisation_by_pk(id: Int!): organisation

  """
  fetch data from the table in a streaming manner: "organisation"
  """
  organisation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [organisation_stream_cursor_input]!

    """filter the rows returned"""
    where: organisation_bool_exp
  ): [organisation!]!

  """
  fetch data from the table: "package"
  """
  package(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): [package!]!

  """
  fetch aggregated fields from the table: "package"
  """
  package_aggregate(
    """distinct select on columns"""
    distinct_on: [package_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_order_by!]

    """filter the rows returned"""
    where: package_bool_exp
  ): package_aggregate!

  """fetch data from the table: "package" using primary key columns"""
  package_by_pk(id: Int!): package

  """
  fetch data from the table in a streaming manner: "package"
  """
  package_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [package_stream_cursor_input]!

    """filter the rows returned"""
    where: package_bool_exp
  ): [package!]!

  """
  fetch data from the table: "package_type"
  """
  package_type(
    """distinct select on columns"""
    distinct_on: [package_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_type_order_by!]

    """filter the rows returned"""
    where: package_type_bool_exp
  ): [package_type!]!

  """
  fetch aggregated fields from the table: "package_type"
  """
  package_type_aggregate(
    """distinct select on columns"""
    distinct_on: [package_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [package_type_order_by!]

    """filter the rows returned"""
    where: package_type_bool_exp
  ): package_type_aggregate!

  """fetch data from the table: "package_type" using primary key columns"""
  package_type_by_pk(value: String!): package_type

  """
  fetch data from the table in a streaming manner: "package_type"
  """
  package_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [package_type_stream_cursor_input]!

    """filter the rows returned"""
    where: package_type_bool_exp
  ): [package_type!]!

  """An array relationship"""
  page_settings(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): [page_settings!]!

  """An aggregate relationship"""
  page_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [page_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [page_settings_order_by!]

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): page_settings_aggregate!

  """fetch data from the table: "page_settings" using primary key columns"""
  page_settings_by_pk(folio_user: String!): page_settings

  """
  fetch data from the table in a streaming manner: "page_settings"
  """
  page_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [page_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: page_settings_bool_exp
  ): [page_settings!]!

  """
  fetch data from the table: "permission"
  """
  permission(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """
  fetch aggregated fields from the table: "permission"
  """
  permission_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): permission_aggregate!

  """fetch data from the table: "permission" using primary key columns"""
  permission_by_pk(folio_user: String!, package: Int!): permission

  """
  fetch data from the table in a streaming manner: "permission"
  """
  permission_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [permission_stream_cursor_input]!

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "product_artis_type"
  """
  product_artis_type(
    """distinct select on columns"""
    distinct_on: [product_artis_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_artis_type_order_by!]

    """filter the rows returned"""
    where: product_artis_type_bool_exp
  ): [product_artis_type!]!

  """
  fetch aggregated fields from the table: "product_artis_type"
  """
  product_artis_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_artis_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_artis_type_order_by!]

    """filter the rows returned"""
    where: product_artis_type_bool_exp
  ): product_artis_type_aggregate!

  """
  fetch data from the table: "product_artis_type" using primary key columns
  """
  product_artis_type_by_pk(value: String!): product_artis_type

  """
  fetch data from the table in a streaming manner: "product_artis_type"
  """
  product_artis_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_artis_type_stream_cursor_input]!

    """filter the rows returned"""
    where: product_artis_type_bool_exp
  ): [product_artis_type!]!

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: uuid!): product

  """
  fetch data from the table: "product_config"
  """
  product_config(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): [product_config!]!

  """
  fetch aggregated fields from the table: "product_config"
  """
  product_config_aggregate(
    """distinct select on columns"""
    distinct_on: [product_config_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_config_order_by!]

    """filter the rows returned"""
    where: product_config_bool_exp
  ): product_config_aggregate!

  """fetch data from the table: "product_config" using primary key columns"""
  product_config_by_pk(product: uuid!, relative_month: Int!): product_config

  """
  fetch data from the table in a streaming manner: "product_config"
  """
  product_config_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_config_stream_cursor_input]!

    """filter the rows returned"""
    where: product_config_bool_exp
  ): [product_config!]!

  """
  fetch data from the table: "product_eod"
  """
  product_eod(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): [product_eod!]!

  """
  fetch aggregated fields from the table: "product_eod"
  """
  product_eod_aggregate(
    """distinct select on columns"""
    distinct_on: [product_eod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_eod_order_by!]

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): product_eod_aggregate!

  """fetch data from the table: "product_eod" using primary key columns"""
  product_eod_by_pk(eod_product: uuid!, product: uuid!): product_eod

  """
  fetch data from the table in a streaming manner: "product_eod"
  """
  product_eod_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_eod_stream_cursor_input]!

    """filter the rows returned"""
    where: product_eod_bool_exp
  ): [product_eod!]!

  """An array relationship"""
  product_global_dependencies(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): [product_global_dependencies!]!

  """An aggregate relationship"""
  product_global_dependencies_aggregate(
    """distinct select on columns"""
    distinct_on: [product_global_dependencies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_global_dependencies_order_by!]

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): product_global_dependencies_aggregate!

  """
  fetch data from the table: "product_global_dependencies" using primary key columns
  """
  product_global_dependencies_by_pk(global_product: uuid!, product: uuid!): product_global_dependencies

  """
  fetch data from the table in a streaming manner: "product_global_dependencies"
  """
  product_global_dependencies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_global_dependencies_stream_cursor_input]!

    """filter the rows returned"""
    where: product_global_dependencies_bool_exp
  ): [product_global_dependencies!]!

  """
  fetch data from the table: "product_maturity"
  """
  product_maturity(
    """distinct select on columns"""
    distinct_on: [product_maturity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_maturity_order_by!]

    """filter the rows returned"""
    where: product_maturity_bool_exp
  ): [product_maturity!]!

  """
  fetch aggregated fields from the table: "product_maturity"
  """
  product_maturity_aggregate(
    """distinct select on columns"""
    distinct_on: [product_maturity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_maturity_order_by!]

    """filter the rows returned"""
    where: product_maturity_bool_exp
  ): product_maturity_aggregate!

  """
  fetch data from the table: "product_maturity" using primary key columns
  """
  product_maturity_by_pk(value: String!): product_maturity

  """
  fetch data from the table in a streaming manner: "product_maturity"
  """
  product_maturity_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_maturity_stream_cursor_input]!

    """filter the rows returned"""
    where: product_maturity_bool_exp
  ): [product_maturity!]!

  """An array relationship"""
  product_overrides(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """An aggregate relationship"""
  product_overrides_aggregate(
    """distinct select on columns"""
    distinct_on: [product_overrides_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_overrides_order_by!]

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): product_overrides_aggregate!

  """
  fetch data from the table: "product_overrides" using primary key columns
  """
  product_overrides_by_pk(organisation: Int!, product: uuid!): product_overrides

  """
  fetch data from the table in a streaming manner: "product_overrides"
  """
  product_overrides_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_overrides_stream_cursor_input]!

    """filter the rows returned"""
    where: product_overrides_bool_exp
  ): [product_overrides!]!

  """
  fetch data from the table: "product_source"
  """
  product_source(
    """distinct select on columns"""
    distinct_on: [product_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_source_order_by!]

    """filter the rows returned"""
    where: product_source_bool_exp
  ): [product_source!]!

  """
  fetch aggregated fields from the table: "product_source"
  """
  product_source_aggregate(
    """distinct select on columns"""
    distinct_on: [product_source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_source_order_by!]

    """filter the rows returned"""
    where: product_source_bool_exp
  ): product_source_aggregate!

  """fetch data from the table: "product_source" using primary key columns"""
  product_source_by_pk(value: String!): product_source

  """
  fetch data from the table in a streaming manner: "product_source"
  """
  product_source_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_source_stream_cursor_input]!

    """filter the rows returned"""
    where: product_source_bool_exp
  ): [product_source!]!

  """
  fetch data from the table in a streaming manner: "product"
  """
  product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_stream_cursor_input]!

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch data from the table: "product_summary_type"
  """
  product_summary_type(
    """distinct select on columns"""
    distinct_on: [product_summary_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_summary_type_order_by!]

    """filter the rows returned"""
    where: product_summary_type_bool_exp
  ): [product_summary_type!]!

  """
  fetch aggregated fields from the table: "product_summary_type"
  """
  product_summary_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_summary_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_summary_type_order_by!]

    """filter the rows returned"""
    where: product_summary_type_bool_exp
  ): product_summary_type_aggregate!

  """
  fetch data from the table: "product_summary_type" using primary key columns
  """
  product_summary_type_by_pk(value: String!): product_summary_type

  """
  fetch data from the table in a streaming manner: "product_summary_type"
  """
  product_summary_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_summary_type_stream_cursor_input]!

    """filter the rows returned"""
    where: product_summary_type_bool_exp
  ): [product_summary_type!]!

  """
  fetch data from the table: "product_type"
  """
  product_type(
    """distinct select on columns"""
    distinct_on: [product_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_type_order_by!]

    """filter the rows returned"""
    where: product_type_bool_exp
  ): [product_type!]!

  """
  fetch aggregated fields from the table: "product_type"
  """
  product_type_aggregate(
    """distinct select on columns"""
    distinct_on: [product_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_type_order_by!]

    """filter the rows returned"""
    where: product_type_bool_exp
  ): product_type_aggregate!

  """fetch data from the table: "product_type" using primary key columns"""
  product_type_by_pk(value: String!): product_type

  """
  fetch data from the table in a streaming manner: "product_type"
  """
  product_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_type_stream_cursor_input]!

    """filter the rows returned"""
    where: product_type_bool_exp
  ): [product_type!]!

  """
  fetch data from the table: "product_uom"
  """
  product_uom(
    """distinct select on columns"""
    distinct_on: [product_uom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_uom_order_by!]

    """filter the rows returned"""
    where: product_uom_bool_exp
  ): [product_uom!]!

  """
  fetch aggregated fields from the table: "product_uom"
  """
  product_uom_aggregate(
    """distinct select on columns"""
    distinct_on: [product_uom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_uom_order_by!]

    """filter the rows returned"""
    where: product_uom_bool_exp
  ): product_uom_aggregate!

  """fetch data from the table: "product_uom" using primary key columns"""
  product_uom_by_pk(value: String!): product_uom

  """
  fetch data from the table in a streaming manner: "product_uom"
  """
  product_uom_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_uom_stream_cursor_input]!

    """filter the rows returned"""
    where: product_uom_bool_exp
  ): [product_uom!]!

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(folio_user: String!, is_mobile: Boolean!): session

  """
  fetch data from the table in a streaming manner: "session"
  """
  session_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_stream_cursor_input]!

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch data from the table: "session_type"
  """
  session_type(
    """distinct select on columns"""
    distinct_on: [session_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_type_order_by!]

    """filter the rows returned"""
    where: session_type_bool_exp
  ): [session_type!]!

  """
  fetch aggregated fields from the table: "session_type"
  """
  session_type_aggregate(
    """distinct select on columns"""
    distinct_on: [session_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_type_order_by!]

    """filter the rows returned"""
    where: session_type_bool_exp
  ): session_type_aggregate!

  """fetch data from the table: "session_type" using primary key columns"""
  session_type_by_pk(value: String!): session_type

  """
  fetch data from the table in a streaming manner: "session_type"
  """
  session_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_type_stream_cursor_input]!

    """filter the rows returned"""
    where: session_type_bool_exp
  ): [session_type!]!

  """
  fetch data from the table: "shared_instrument"
  """
  shared_instrument(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]!

  """
  fetch aggregated fields from the table: "shared_instrument"
  """
  shared_instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [shared_instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [shared_instrument_order_by!]

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): shared_instrument_aggregate!

  """
  fetch data from the table: "shared_instrument" using primary key columns
  """
  shared_instrument_by_pk(month: date!, product: uuid!): shared_instrument

  """
  fetch data from the table in a streaming manner: "shared_instrument"
  """
  shared_instrument_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [shared_instrument_stream_cursor_input]!

    """filter the rows returned"""
    where: shared_instrument_bool_exp
  ): [shared_instrument!]!

  """
  fetch data from the table: "sharing_agreement"
  """
  sharing_agreement(
    """distinct select on columns"""
    distinct_on: [sharing_agreement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sharing_agreement_order_by!]

    """filter the rows returned"""
    where: sharing_agreement_bool_exp
  ): [sharing_agreement!]!

  """
  fetch aggregated fields from the table: "sharing_agreement"
  """
  sharing_agreement_aggregate(
    """distinct select on columns"""
    distinct_on: [sharing_agreement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sharing_agreement_order_by!]

    """filter the rows returned"""
    where: sharing_agreement_bool_exp
  ): sharing_agreement_aggregate!

  """
  fetch data from the table: "sharing_agreement" using primary key columns
  """
  sharing_agreement_by_pk(id: Int!): sharing_agreement

  """
  fetch data from the table in a streaming manner: "sharing_agreement"
  """
  sharing_agreement_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sharing_agreement_stream_cursor_input]!

    """filter the rows returned"""
    where: sharing_agreement_bool_exp
  ): [sharing_agreement!]!

  """
  fetch data from the table: "source"
  """
  source(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): [source!]!

  """
  fetch aggregated fields from the table: "source"
  """
  source_aggregate(
    """distinct select on columns"""
    distinct_on: [source_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [source_order_by!]

    """filter the rows returned"""
    where: source_bool_exp
  ): source_aggregate!

  """fetch data from the table: "source" using primary key columns"""
  source_by_pk(id: Int!): source

  """
  fetch data from the table in a streaming manner: "source"
  """
  source_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [source_stream_cursor_input]!

    """filter the rows returned"""
    where: source_bool_exp
  ): [source!]!

  """
  fetch data from the table: "user_right"
  """
  user_right(
    """distinct select on columns"""
    distinct_on: [user_right_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_right_order_by!]

    """filter the rows returned"""
    where: user_right_bool_exp
  ): [user_right!]!

  """
  fetch aggregated fields from the table: "user_right"
  """
  user_right_aggregate(
    """distinct select on columns"""
    distinct_on: [user_right_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_right_order_by!]

    """filter the rows returned"""
    where: user_right_bool_exp
  ): user_right_aggregate!

  """fetch data from the table: "user_right" using primary key columns"""
  user_right_by_pk(value: String!): user_right

  """
  fetch data from the table in a streaming manner: "user_right"
  """
  user_right_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_right_stream_cursor_input]!

    """filter the rows returned"""
    where: user_right_bool_exp
  ): [user_right!]!

  """
  fetch data from the table: "user_storage"
  """
  user_storage(
    """distinct select on columns"""
    distinct_on: [user_storage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_storage_order_by!]

    """filter the rows returned"""
    where: user_storage_bool_exp
  ): [user_storage!]!

  """
  fetch aggregated fields from the table: "user_storage"
  """
  user_storage_aggregate(
    """distinct select on columns"""
    distinct_on: [user_storage_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_storage_order_by!]

    """filter the rows returned"""
    where: user_storage_bool_exp
  ): user_storage_aggregate!

  """fetch data from the table: "user_storage" using primary key columns"""
  user_storage_by_pk(value: String!): user_storage

  """
  fetch data from the table in a streaming manner: "user_storage"
  """
  user_storage_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_storage_stream_cursor_input]!

    """filter the rows returned"""
    where: user_storage_bool_exp
  ): [user_storage!]!

  """
  fetch data from the table: "users_active_last_day"
  """
  users_active_last_day(
    """distinct select on columns"""
    distinct_on: [users_active_last_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_active_last_day_order_by!]

    """filter the rows returned"""
    where: users_active_last_day_bool_exp
  ): [users_active_last_day!]!

  """
  fetch aggregated fields from the table: "users_active_last_day"
  """
  users_active_last_day_aggregate(
    """distinct select on columns"""
    distinct_on: [users_active_last_day_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_active_last_day_order_by!]

    """filter the rows returned"""
    where: users_active_last_day_bool_exp
  ): users_active_last_day_aggregate!

  """
  fetch data from the table in a streaming manner: "users_active_last_day"
  """
  users_active_last_day_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_active_last_day_stream_cursor_input]!

    """filter the rows returned"""
    where: users_active_last_day_bool_exp
  ): [users_active_last_day!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_right"
"""
type user_right {
  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): [permission!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permission_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permission_order_by!]

    """filter the rows returned"""
    where: permission_bool_exp
  ): permission_aggregate!
  value: String!
}

"""
aggregated selection of "user_right"
"""
type user_right_aggregate {
  aggregate: user_right_aggregate_fields
  nodes: [user_right!]!
}

"""
aggregate fields of "user_right"
"""
type user_right_aggregate_fields {
  count(columns: [user_right_select_column!], distinct: Boolean): Int!
  max: user_right_max_fields
  min: user_right_min_fields
}

"""
Boolean expression to filter rows from the table "user_right". All fields are combined with a logical 'AND'.
"""
input user_right_bool_exp {
  _and: [user_right_bool_exp!]
  _not: user_right_bool_exp
  _or: [user_right_bool_exp!]
  permissions: permission_bool_exp
  permissions_aggregate: permission_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "user_right"
"""
enum user_right_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  user_right_pkey
}

enum user_right_enum {
  broadcast
  list
  read
  write
}

"""
Boolean expression to compare columns of type "user_right_enum". All fields are combined with logical 'AND'.
"""
input user_right_enum_comparison_exp {
  _eq: user_right_enum
  _in: [user_right_enum!]
  _is_null: Boolean
  _neq: user_right_enum
  _nin: [user_right_enum!]
}

"""
input type for inserting data into table "user_right"
"""
input user_right_insert_input {
  permissions: permission_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type user_right_max_fields {
  value: String
}

"""aggregate min on columns"""
type user_right_min_fields {
  value: String
}

"""
response of any mutation on the table "user_right"
"""
type user_right_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_right!]!
}

"""
input type for inserting object relation for remote table "user_right"
"""
input user_right_obj_rel_insert_input {
  data: user_right_insert_input!

  """upsert condition"""
  on_conflict: user_right_on_conflict
}

"""
on_conflict condition type for table "user_right"
"""
input user_right_on_conflict {
  constraint: user_right_constraint!
  update_columns: [user_right_update_column!]! = []
  where: user_right_bool_exp
}

"""Ordering options when selecting data from "user_right"."""
input user_right_order_by {
  permissions_aggregate: permission_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: user_right"""
input user_right_pk_columns_input {
  value: String!
}

"""
select columns of table "user_right"
"""
enum user_right_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "user_right"
"""
input user_right_set_input {
  value: String
}

"""
Streaming cursor of the table "user_right"
"""
input user_right_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_right_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_right_stream_cursor_value_input {
  value: String
}

"""
update columns of table "user_right"
"""
enum user_right_update_column {
  """column name"""
  value
}

input user_right_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_right_set_input

  """filter the rows which have to be updated"""
  where: user_right_bool_exp!
}

"""
columns and relationships of "user_storage"
"""
type user_storage {
  value: String!
}

"""
aggregated selection of "user_storage"
"""
type user_storage_aggregate {
  aggregate: user_storage_aggregate_fields
  nodes: [user_storage!]!
}

"""
aggregate fields of "user_storage"
"""
type user_storage_aggregate_fields {
  count(columns: [user_storage_select_column!], distinct: Boolean): Int!
  max: user_storage_max_fields
  min: user_storage_min_fields
}

"""
Boolean expression to filter rows from the table "user_storage". All fields are combined with a logical 'AND'.
"""
input user_storage_bool_exp {
  _and: [user_storage_bool_exp!]
  _not: user_storage_bool_exp
  _or: [user_storage_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "user_storage"
"""
enum user_storage_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  user_storage_pkey
}

enum user_storage_enum {
  broadcast
  local
}

"""
Boolean expression to compare columns of type "user_storage_enum". All fields are combined with logical 'AND'.
"""
input user_storage_enum_comparison_exp {
  _eq: user_storage_enum
  _in: [user_storage_enum!]
  _is_null: Boolean
  _neq: user_storage_enum
  _nin: [user_storage_enum!]
}

"""
input type for inserting data into table "user_storage"
"""
input user_storage_insert_input {
  value: String
}

"""aggregate max on columns"""
type user_storage_max_fields {
  value: String
}

"""aggregate min on columns"""
type user_storage_min_fields {
  value: String
}

"""
response of any mutation on the table "user_storage"
"""
type user_storage_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_storage!]!
}

"""
on_conflict condition type for table "user_storage"
"""
input user_storage_on_conflict {
  constraint: user_storage_constraint!
  update_columns: [user_storage_update_column!]! = []
  where: user_storage_bool_exp
}

"""Ordering options when selecting data from "user_storage"."""
input user_storage_order_by {
  value: order_by
}

"""primary key columns input for table: user_storage"""
input user_storage_pk_columns_input {
  value: String!
}

"""
select columns of table "user_storage"
"""
enum user_storage_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "user_storage"
"""
input user_storage_set_input {
  value: String
}

"""
Streaming cursor of the table "user_storage"
"""
input user_storage_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_storage_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_storage_stream_cursor_value_input {
  value: String
}

"""
update columns of table "user_storage"
"""
enum user_storage_update_column {
  """column name"""
  value
}

input user_storage_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_storage_set_input

  """filter the rows which have to be updated"""
  where: user_storage_bool_exp!
}

"""
columns and relationships of "users_active_last_day"
"""
type users_active_last_day {
  folio_user: String
  organisation: Int
}

"""
aggregated selection of "users_active_last_day"
"""
type users_active_last_day_aggregate {
  aggregate: users_active_last_day_aggregate_fields
  nodes: [users_active_last_day!]!
}

"""
aggregate fields of "users_active_last_day"
"""
type users_active_last_day_aggregate_fields {
  avg: users_active_last_day_avg_fields
  count(columns: [users_active_last_day_select_column!], distinct: Boolean): Int!
  max: users_active_last_day_max_fields
  min: users_active_last_day_min_fields
  stddev: users_active_last_day_stddev_fields
  stddev_pop: users_active_last_day_stddev_pop_fields
  stddev_samp: users_active_last_day_stddev_samp_fields
  sum: users_active_last_day_sum_fields
  var_pop: users_active_last_day_var_pop_fields
  var_samp: users_active_last_day_var_samp_fields
  variance: users_active_last_day_variance_fields
}

"""aggregate avg on columns"""
type users_active_last_day_avg_fields {
  organisation: Float
}

"""
Boolean expression to filter rows from the table "users_active_last_day". All fields are combined with a logical 'AND'.
"""
input users_active_last_day_bool_exp {
  _and: [users_active_last_day_bool_exp!]
  _not: users_active_last_day_bool_exp
  _or: [users_active_last_day_bool_exp!]
  folio_user: String_comparison_exp
  organisation: Int_comparison_exp
}

"""aggregate max on columns"""
type users_active_last_day_max_fields {
  folio_user: String
  organisation: Int
}

"""aggregate min on columns"""
type users_active_last_day_min_fields {
  folio_user: String
  organisation: Int
}

"""Ordering options when selecting data from "users_active_last_day"."""
input users_active_last_day_order_by {
  folio_user: order_by
  organisation: order_by
}

"""
select columns of table "users_active_last_day"
"""
enum users_active_last_day_select_column {
  """column name"""
  folio_user

  """column name"""
  organisation
}

"""aggregate stddev on columns"""
type users_active_last_day_stddev_fields {
  organisation: Float
}

"""aggregate stddev_pop on columns"""
type users_active_last_day_stddev_pop_fields {
  organisation: Float
}

"""aggregate stddev_samp on columns"""
type users_active_last_day_stddev_samp_fields {
  organisation: Float
}

"""
Streaming cursor of the table "users_active_last_day"
"""
input users_active_last_day_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_active_last_day_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_active_last_day_stream_cursor_value_input {
  folio_user: String
  organisation: Int
}

"""aggregate sum on columns"""
type users_active_last_day_sum_fields {
  organisation: Int
}

"""aggregate var_pop on columns"""
type users_active_last_day_var_pop_fields {
  organisation: Float
}

"""aggregate var_samp on columns"""
type users_active_last_day_var_samp_fields {
  organisation: Float
}

"""aggregate variance on columns"""
type users_active_last_day_variance_fields {
  organisation: Float
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

